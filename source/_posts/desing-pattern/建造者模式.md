---
title: 建造者模式
date: 2019-11-06 14:56:25
tags: 设计模式
---

## 什么是建造者模式
> 不关心产品构建的过程， 只关心结果
> 将一个**复杂对象**的创建与**具体部位**创建分离，使得同样的构建过程可以创建不同的具体部位，比如电脑的各个部件。

- 建造者模式可以将一个产品的部件的生成过程和其组装过程分开，一步一步创建一个复杂的对象
- 用户只需要指定复杂对象的类型就可以得到该对象，而无须知道其内部的具体构造细节

## 建造者模式组成
- 抽象建造者
- 具体建造者
- 具体产品
- 指挥类（隔离了客户与生产过程；控制产品的生成过程）

## 建造者模式uml
![建造者模式](/建造者模式.jpg)

## 建造者模式举例
中关村电脑装机
小明（Client）要一台可以流畅吃鸡的游戏主机(Product)， 店老板(Director)让小美(Builder)去配置

店老板针对不同的人、不同的配置分别让小美或者其他装机员去装机， 但是装机流程是一样的， 这就是一个典型的建造者模式

### 具体代码
```java
public interface Builder {

    void createMainBoard(String mainBoard);

    void createCPU(String cpu);

    void createHardDisk(String hardDisk);

    void createMemory(String memory);

    Computer createComputer();
}

```

```java
public class AssembleComputerBuilder implements Builder {

    Computer computer = new Computer();

    @Override
    public void createMainBoard(String mainBoard) {
        computer.setMainBoard(mainBoard);
    }

    @Override
    public void createCPU(String cpu) {
        computer.setCpu(cpu);
    }

    @Override
    public void createHardDisk(String hardDisk) {
        computer.setHardDisk(hardDisk);
    }

    @Override
    public void createMemory(String memory) {
        computer.setMemory(memory);
    }

    @Override
    public Computer createComputer() {
        return computer;
    }
}

```

```java
public class Director {

    private Builder builder;

    public Director(Builder builder) {
        this.builder = builder;
    }

    public Computer createGameComputer(String mainBoard, String cpu, String memory, String hardDisk) {
        // 控制生产顺序
        builder.createCPU(cpu);
        builder.createHardDisk(hardDisk);
        builder.createMainBoard(mainBoard);
        builder.createMemory(memory);
        return builder.createComputer();
    }
}
```

```java
public class Computer {
    private String cpu ;
    private String hardDisk ;
    private String mainBoard ;
    private String memory ;

}
```

```java
public class Client {
    public static void main(String[] args) {
        Builder builder = new AssembleComputerBuilder();
        Director director = new Director(builder);

        Computer computer = director.createComputer("技嘉B360", "Intel-9400F", "Hyper 8G", "希捷 2T");

        System.out.println(computer.toString());
    }
}

```

## 建造者模式优缺点
> **优点**
> * 易于解耦，产品本身与创建过程进行解耦， 相同的创建过程得到不同的产品
> * 更精细地控制创建过程，将复杂产品的创建步骤分解到不同方法中， 创建过程更清晰
> * 易于拓展， 增加新的具体建造者无需修改原有类库，符合开闭原则 

> **缺点**
> * 要求所建造的产品有许多的相同点， 组成部分相似， 没办法让电脑装机店去盖房子
> * 产品内部变化复杂， 可能会需要很多具体建造者实现这种变化

## 建造者模式使用场景
* 需要生成的产品对象有复杂的内部结构，这些产品对象具备多个相同的成员属性；
* 隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品。
* 需要生成的产品对象的属性相互依赖，需要指定其生成顺序。

## 建造者模式与工厂模式的区别
* 工厂模式是将对象的全部创建过程封装在工厂类中，由工厂类向客户端提供最终的产品；
* 建造者类一般只提供产品类中各个组件的建造，而将具体建造过程交付给导演类。由导演类负责将各个组件按照特定的规则组建为产品，然后将组建好的产品交付给客户端。
