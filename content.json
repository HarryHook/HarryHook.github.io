{"meta":{"title":"harryhook's blog","subtitle":null,"description":null,"author":"HarryHook","url":"https://coderunning.fun","root":"/"},"pages":[{"title":"","date":"2019-10-18T07:56:05.000Z","updated":"2020-04-24T15:03:26.698Z","comments":true,"path":"about/index.html","permalink":"https://coderunning.fun/about/index.html","excerpt":"","text":"自我介绍 会写点代码的跑步爱好者!"},{"title":"categories","date":"2019-12-09T12:41:03.000Z","updated":"2020-04-24T15:03:26.702Z","comments":true,"path":"categories/index.html","permalink":"https://coderunning.fun/categories/index.html","excerpt":"","text":""},{"title":"分类&标签","date":"2019-11-30T04:32:44.000Z","updated":"2020-04-24T15:03:26.702Z","comments":true,"path":"tags/index.html","permalink":"https://coderunning.fun/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"LeetCode 148. Sort List","slug":"leetcode/linkedlist/sort-list","date":"2020-05-13T14:59:43.000Z","updated":"2020-05-13T15:12:14.677Z","comments":true,"path":"2020/05/13/leetcode/linkedlist/sort-list/","link":"","permalink":"https://coderunning.fun/2020/05/13/leetcode/linkedlist/sort-list/","excerpt":"Sort a linked list in O(n log n) time using constant space complexity.","text":"Sort a linked list in O(n log n) time using constant space complexity. Example 1 Input: 4-&gt;2-&gt;1-&gt;3 Output: 1-&gt;2-&gt;3-&gt;4 Example 2 Input: -1-&gt;5-&gt;3-&gt;4-&gt;0 Output: -1-&gt;0-&gt;3-&gt;4-&gt;5 题意给出一个链表， 使用常量空间，O(n log n)时间复杂度下对链表进行排序。 思路 首先常量空间意味着不能借助于辅助的数据结构， 比如数组、栈之类的； 其次 n log n 的时间复杂度， 可以采用插入排序、选择排序或者归并排序； 在 insertion-sort-list 中采用了插入排序， 在本题中采用归并排序来解决这个问题。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public ListNode sortList(ListNode head) &#123; if(head == null || head.next == null) return head; ListNode pre = null; ListNode slow = head; ListNode fast = head; while (fast != null &amp;&amp; fast.next != null) &#123; pre = slow; slow = slow.next; fast = fast.next.next; &#125; pre.next = null; ListNode l1 = sortList(head); ListNode l2 = sortList(slow); return mergeSort(l1, l2);&#125;public ListNode mergeSort(ListNode l1, ListNode l2) &#123; ListNode p = new ListNode(-1); ListNode dummyNode = p; while (l1 != null &amp;&amp; l2 != null) &#123; if(l1.val &lt; l2.val) &#123; p.next = l1; l1 = l1.next; &#125; else &#123; p.next = l2; l2 = l2.next; &#125; p = p.next; &#125; if (l1 != null) &#123; p.next = l1; &#125; if (l2 != null) &#123; p.next = l2; &#125; return dummyNode.next;&#125;","categories":[{"name":"每周一题","slug":"每周一题","permalink":"https://coderunning.fun/categories/每周一题/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://coderunning.fun/tags/leetcode/"},{"name":"linkedlist","slug":"linkedlist","permalink":"https://coderunning.fun/tags/linkedlist/"}]},{"title":"LeetCode 147. Insertion Sort List","slug":"leetcode/linkedlist/insertion-sort-list","date":"2020-05-12T11:59:20.000Z","updated":"2020-05-13T14:08:18.922Z","comments":true,"path":"2020/05/12/leetcode/linkedlist/insertion-sort-list/","link":"","permalink":"https://coderunning.fun/2020/05/12/leetcode/linkedlist/insertion-sort-list/","excerpt":"Sort a linked list using insertion sort.","text":"Sort a linked list using insertion sort. Example 1 Input: 4-&gt;2-&gt;1-&gt;3 Output: 1-&gt;2-&gt;3-&gt;4 Example 2 Input: -1-&gt;5-&gt;3-&gt;4-&gt;0 Output: -1-&gt;0-&gt;3-&gt;4-&gt;5 题意给出一个链表， 采用插入排序对链表进行排序 思路 利用虚拟头结点使得所有结点按同样的逻辑处理； 通过 pre 指针遍历链表， 找到第一个比之前结点小的结点， 记录 pre 信息； 进行插入操作。 示意图 代码12345678910111213141516171819202122232425public ListNode insertionSortList(ListNode head) &#123; if(head == null || head.next == null) return head; ListNode dummyHead = new ListNode(-1); ListNode pre = dummyHead; ListNode cur = head; ListNode next = null; while(cur != null) &#123; // 下次遍历的起点 next = cur.next; // 找到待插入的结点 while(pre.next != null &amp;&amp; pre.next.val &lt; cur.val) &#123; pre = pre.next; &#125; // 断链 cur.next = pre.next; pre.next = cur; // pre 回到虚拟头结点重新遍历 pre = dummyHead; cur = next; &#125; return dummyHead.next;&#125;","categories":[{"name":"每周一题","slug":"每周一题","permalink":"https://coderunning.fun/categories/每周一题/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://coderunning.fun/tags/leetcode/"},{"name":"linkedlist","slug":"linkedlist","permalink":"https://coderunning.fun/tags/linkedlist/"}]},{"title":"组合模式","slug":"design-pattern/组合模式","date":"2020-05-11T08:34:58.000Z","updated":"2020-05-12T15:56:24.952Z","comments":true,"path":"2020/05/11/design-pattern/组合模式/","link":"","permalink":"https://coderunning.fun/2020/05/11/design-pattern/组合模式/","excerpt":"文件夹的设计就是最经典的组合模式。","text":"文件夹的设计就是最经典的组合模式。 一个容器对象可以存放多种不同的子对象以及容器对象，好似一个树一样有叶子和树枝。由于叶子对象和容器对象具有差异，在使用这些对象的代码的时候会差异化处理，但是在实际情况下我们希望按照统一的逻辑进行处理，因为区别对待可能使得代码很复杂。 什么是组合模式组合多个对象形成一个树形的“整体-部分”结构，使得整体（容器）和部分（叶子对象）具有一样的处理逻辑，组合模式又称为“整体-部分”（Whole-Part）模式， 属于结构型模式。 组合模式组成Component: 抽象构件，接口或者抽象类。 定义组合对象与叶子对象的共同方法。 Leaf: 叶子构件，在组合结构中表示叶子节点对象。叶子节点没有子节点，实现了抽象构件中定义的行为。 Composite: 容器构件，在组合结构中表示容器节点对象，容器节点包含子节点，子节点可以是容器节点也可以是叶子节点。 容器构件实现了抽象构件中定义的行为， 也可以自己定义特殊的行为。 组合模式 uml 组合模式代码实现定义 Component 12345public abstract class Component &#123; public void print() &#123; System.out.println(\"不支持打印操作\"); &#125;&#125; 定义 Leaf 12345678910111213public class File extends Component &#123; private String name; public File(String name) &#123; this.name = name; &#125; @Override public void print() &#123; System.out.println(\"file name: \" + name); &#125;&#125; 定义 Composite 12345678910111213141516171819202122232425262728293031public class Folder extends Component &#123; private String name; private List&lt;Component&gt; componentList = new ArrayList&lt;Component&gt;(); public Folder(String name) &#123; this.name = name; &#125; @Override public void print() &#123; System.out.println(\"fold name: \" + this.name); for (Component component : componentList) &#123; component.print(); &#125; &#125; public void addComponent(Component component) &#123; componentList.add(component); &#125; public void remove(Component component) &#123; if (componentList.contains(component)) &#123; componentList.remove(component); &#125; &#125; public List&lt;Component&gt; getChildren() &#123; return componentList; &#125;&#125; 客户端调用： 12345678910111213141516171819202122public class CompositePatternClient &#123; public static void main(String[] args) &#123; Folder DSFolder = new Folder(\"自学成才资料\"); File file1 = new File(\"深入理解 java 虚拟机\"); DSFolder.addComponent(file1); DSFolder.print(); Folder subFolder = new Folder(\"设计模式\"); File finalPaper = new File(\"组合模式.md\"); subFolder.addComponent(finalPaper); DSFolder.addComponent(subFolder); DSFolder.print(); &#125;&#125; 输出： fold name: 自学成才资料 file name: 深入理解 java 虚拟机 fold name: 自学成才资料 file name: 深入理解 java 虚拟机 fold name: 五年高考三年模拟 file name: 组合模式.md组合模式优缺点优点： 可以清晰地定义分层次的复杂对象，让客户端忽略层次差异，按同样逻辑进行处理。 加入新的构件不会影响现有的客户端使用， 符合开闭原则。 缺点： 设计更复杂，客户端需要花很多时间理清类之间的关系。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://coderunning.fun/categories/设计模式/"}],"tags":[{"name":"结构型模式","slug":"结构型模式","permalink":"https://coderunning.fun/tags/结构型模式/"}]},{"title":"LeetCode 143. Reorder List","slug":"leetcode/linkedlist/reorder-list","date":"2020-05-10T15:04:48.000Z","updated":"2020-05-10T15:20:53.937Z","comments":true,"path":"2020/05/10/leetcode/linkedlist/reorder-list/","link":"","permalink":"https://coderunning.fun/2020/05/10/leetcode/linkedlist/reorder-list/","excerpt":"Given a singly linked list L: L0→L1→…→Ln-1→Ln,reorder it to: L0→Ln→L1→Ln-1→L2→Ln-2→…","text":"Given a singly linked list L: L0→L1→…→Ln-1→Ln,reorder it to: L0→Ln→L1→Ln-1→L2→Ln-2→… You may not modify the values in the list’s nodes, only nodes itself may be changed. Example 1: Given 1-&gt;2-&gt;3-&gt;4, reorder it to 1-&gt;4-&gt;2-&gt;3. Example 2: Given 1-&gt;2-&gt;3-&gt;4-&gt;5, reorder it to 1-&gt;5-&gt;2-&gt;4-&gt;3. 题意给出一个链表， 将 1-2-3-4 这样的顺序重新排序成 1-4-2-3 思路 将链表分成两半(利用快慢指针找到中间结点) 后半部分链表翻转 同时遍历两个链表将对应的结点进行链接， l0-&gt;ln, l1-&gt;ln-1 代码1234567891011121314151617181920212223242526272829303132333435363738394041public void reorderList(ListNode head) &#123; if(head == null || head.next == null) return ; ListNode pre = null; ListNode slow = head; ListNode fast = head; while(fast != null &amp;&amp; fast.next != null) &#123; pre = slow; slow = slow.next; fast = fast.next.next; &#125; // 断开前后链表 pre.next = null; // 后半部分链表翻转 ListNode secondList = reverse(slow); ListNode l1 = head; ListNode l2 = secondList; // 合并 while(l1 != null) &#123; ListNode n1 = l1.next, n2 = l2.next; l1.next = l2; if(n1 == null) break; l2.next = n1; l2 = n2; l1 = n1; &#125; &#125;public ListNode reverse(ListNode head) &#123; if(head == null || head.next == null) return head; ListNode newHead = reverse(head.next); head.next.next = head; head.next = null; return newHead;&#125;","categories":[{"name":"每周一题","slug":"每周一题","permalink":"https://coderunning.fun/categories/每周一题/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://coderunning.fun/tags/leetcode/"},{"name":"linkedlist","slug":"linkedlist","permalink":"https://coderunning.fun/tags/linkedlist/"}]},{"title":"模板方法模式","slug":"design-pattern/模板方法模式","date":"2020-05-07T06:56:19.000Z","updated":"2020-05-07T13:38:55.122Z","comments":true,"path":"2020/05/07/design-pattern/模板方法模式/","link":"","permalink":"https://coderunning.fun/2020/05/07/design-pattern/模板方法模式/","excerpt":"模板方法模式的核心其实还是面向对象设计的体现: 封装、继承、多态。","text":"模板方法模式的核心其实还是面向对象设计的体现: 封装、继承、多态。 什么是模板方法模式模板方法模式（Template Method）， 公开定义一个算法结构，将一些步骤的具体实现延迟到子类。模板方法模式使得子类可以不改变算法结构即可重新定义该算法的某些步骤。模板方法模式属于对象行为模式。 模板方法模式组成AbstractTemplate: 抽象模板角色，定义一组基本方法供子类实现，定义并实现组合了基本方法的模板方法。 ConcreteTemplate: 具体模板角色， 实现抽象模板角色定义的一系列基本方法。 基本方法 抽象方法：由抽象模板角色声明， abstract 修饰， 具体模板角色实现 钩子方法：由抽象模板角色声明并实现， 具体模板角色进行扩展。 具体方法: 由抽象模板角色声明并实现，private修饰。 模板方法: 由抽象模板角色声明并实现， final 修饰， 不允许具体角色重写。 模板方法模式 UML 模板方法模式代码实现定义抽象模板 12345678910111213141516171819202122232425262728293031323334353637public abstract class OrderProcessTemplate &#123; private boolean isGift; public OrderProcessTemplate() &#123; isGift = isGift(); &#125; // 通用方法 private void giftWrap() &#123; System.out.println(\"给礼品进行包装\"); &#125; // 交给子类扩展的方法 protected abstract void doSelect(); // 交给子类扩展的方法 protected abstract void doPayment(); // 交给子类扩展的方法 protected abstract void doDelivery(); // hook method, 子类自行扩展 protected boolean isGift() &#123; return false; &#125; // 定义的模板方法，设计具体的逻辑 public final void processOrder() &#123; doSelect(); doPayment(); if (isGift) &#123; giftWrap(); &#125; doDelivery(); &#125;&#125; 定义模板子类： 1234567891011121314151617public class NetOrder extends OrderProcessTemplate &#123; @Override public void doSelect() &#123; System.out.println(\"线上购物，加入购物车\"); &#125; @Override public void doPayment() &#123; System.out.println(\"进行线上支付\"); &#125; @Override public void doDelivery() &#123; System.out.println(\"根据收货地址进行邮寄\"); &#125;&#125; 12345678910111213141516171819202122public class StoreOrder extends OrderProcessTemplate &#123; @Override public void doSelect() &#123; System.out.println(\"顾客线下进行选购\"); &#125; @Override public void doPayment() &#123; System.out.println(\"顾客线下进行支付，刷卡/现金结算\"); &#125; @Override public void doDelivery() &#123; System.out.println(\"物品已送至柜台\"); &#125; @Override public boolean isGift() &#123; return true; &#125;&#125; 客户端调用： 1234567891011public class Client &#123; public static void main(String[] args) &#123; OrderProcessTemplate netOrder = new NetOrder(); netOrder.processOrder(); System.out.println(\"==================\"); OrderProcessTemplate storeOrder = new StoreOrder(); storeOrder.processOrder(); &#125;&#125; 输出： 线上购物，加入购物车 进行线上支付 给礼品进行包装 根据收货地址进行邮寄 ======================= 顾客线下进行选购 顾客线下进行支付，刷卡/现金结算 物品已送至柜台模板方法适用场景 一次性实现算法不变的部分，将可变的行为交给子类实现。 多个子类具有同样的行为，可以将公共行为抽取，集中到父类中。 控制子类扩展， 每个子类根据自身特性进行扩展。 模板方法模式优缺点优点： 提高代码复用性， 相同的代码放在父类。 提高代码可扩展性，不同的子类具有不同的行为。 实现反向控制， 父类调用子类进行操作。 缺点： 引入抽象类， 每个不同的行为表现都需要一个子类来实现，导致类的个数增加系统也会更庞大。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://coderunning.fun/categories/设计模式/"}],"tags":[{"name":"行为型模式","slug":"行为型模式","permalink":"https://coderunning.fun/tags/行为型模式/"}]},{"title":"中介者模式","slug":"design-pattern/中介者模式","date":"2020-05-05T13:24:59.000Z","updated":"2020-05-06T13:21:58.845Z","comments":true,"path":"2020/05/05/design-pattern/中介者模式/","link":"","permalink":"https://coderunning.fun/2020/05/05/design-pattern/中介者模式/","excerpt":"当飞机起飞或者着陆时， 如果没有塔台将会发生什么？","text":"当飞机起飞或者着陆时， 如果没有塔台将会发生什么？ 什么是中介者模式中介者模式（Mediator Pattern）, 将一系列的对象交互封装起来, 使两个模块不需要频繁地相互显式引用， 从而使其松耦合。 中介者模式又称之为调停模式, 是一种对象行为模式。 为什么使用中介者模式通常情况下多个类交互如下图所示，类之间的关系呈网状结构， 当任一对象发生变化时都有可能影响到多个对象，对象间之间关联形成了紧耦合， 这种设计很难做到类的复用， 而且一旦一个类发生变更， 关联的类也需要做相应的修改。 如果类之间的交互改成如下的星型模式，任何一个类的变动都只会影响到类本身和中介者，其他方是无感知的，这样就减少了类之间的耦合。 中介者模式就是将类之间的逻辑关系抽象出来，维护在中介者中。 中介者模式组成Mediator: 抽象中介者。定义同事对象到中介的接口。 ConcreteMediator: 具体中介者。实现抽象中介者的方法，需要知道所有的具体同事类， 接收同事类发生的消息。 Collegue: 抽象同事类。 ConcreteCollegue: 具体同事类。实现抽象同事类的方法， 每个同事类可以有一套属于自己的方法， 但是所有的具体同事类都知晓中介类。 中介者模式 UML 中介者模式代码实现抽象中介者, 此处为塔台的抽象 12345678910public interface IATCMediator &#123; void registerRunway(Runway runway); void registerFlight(Flight flight); boolean isLandingOk(); void setLandingStatus(Boolean landingStatus);&#125; 具体中介者， 塔台的实现： 123456789101112131415161718192021222324252627public class ATCMediator implements IATCMediator &#123; private Flight flight; private Runway runway; public boolean isLanded; @Override public void registerRunway(Runway runway) &#123; this.runway = runway; &#125; @Override public void registerFlight(Flight flight) &#123; this.flight = flight; &#125; @Override public boolean isLandingOk() &#123; return isLanded; &#125; @Override public void setLandingStatus(boolean landingStatus) &#123; isLanded = landingStatus; &#125;&#125; 抽象同事类 123public interface Command &#123; void land();&#125; 具体同事类， 分别是航班（Flight）和跑道（Runway） 12345678910111213141516171819202122public class Flight implements Command &#123; private IATCMediator atcMediator; public Flight(IATCMediator atcMediator) &#123; this.atcMediator = atcMediator; &#125; @Override public void land() &#123; if (atcMediator.isLandingOk()) &#123; System.out.println(\"successfully landed!\"); atcMediator.setLandingStatus(true); &#125; else &#123; System.out.println(\"Waiting for landing.\"); &#125; &#125; public void getReady() &#123; System.out.println(\"Ready for landing.\"); &#125;&#125; 1234567891011121314public class Runway implements Command &#123; private IATCMediator atcMediator; public Runway(IATCMediator atcMediator) &#123; this.atcMediator = atcMediator; &#125; @Override public void land() &#123; System.out.println(\"Landing permission granted.\"); atcMediator.setLandingStatus(true); &#125;&#125; 客户端调用： 1234567891011121314151617181920212223public class Client &#123; public static void main(String[] args) &#123; IATCMediator atcMediator = new ATCMediator(); Flight flight = new Flight(atcMediator); Runway runway = new Runway(atcMediator); atcMediator.registerFlight(flight); atcMediator.registerRunway(runway); //航班 ready flight.getReady(); // 航班准备着陆 flight.land(); // 跑道就位 runway.land(); // 着陆 flight.land(); &#125;&#125; 输出： Ready for landing. Waiting for landing. Landing permission granted. successfully landed!中介者模式应用场景中介者模式适用于： 系统中对象之间存在复杂的引用关系，系统结构混乱且难以理解。 一个对象引用了多个对象并直接和这些对象通信， 导致该对象不能复用。 想通过一个中间类来封装多个类中的行为，而又不想生成过多的子类。在中介类中定义对象交互的公共行为， 如果需要改变行为可以增加新的具体中介类。 中介者模式优缺点优点： 简化了对象间的交互， 将对象间的交互逻辑进行封装， 将各个同事类进行解耦，使得各个对象相互独立。 使用中介者模式将对象一对多的关联转变成一对一的关联，增加新的中介者和新的同事类都比较方便，便于维护。 减少了同事类的设计，将原本分布在多个同事类的方法集中在一起，使得同事类可以被重用， 无需对原有的同事类进行扩展。 缺点： 中介者类封装了系统中各个对象之间的相互关系，使得中介者的逻辑非常复杂， 维护成本高。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://coderunning.fun/categories/设计模式/"}],"tags":[{"name":"行为型模式","slug":"行为型模式","permalink":"https://coderunning.fun/tags/行为型模式/"}]},{"title":"状态模式","slug":"design-pattern/状态模式","date":"2020-04-29T06:49:40.000Z","updated":"2020-04-30T13:12:53.387Z","comments":true,"path":"2020/04/29/design-pattern/状态模式/","link":"","permalink":"https://coderunning.fun/2020/04/29/design-pattern/状态模式/","excerpt":"当代码中存在大量的 if…else 进行状态判断时状态模式就能派上用场了。","text":"当代码中存在大量的 if…else 进行状态判断时状态模式就能派上用场了。 什么是状态模式状态模式（State Pattern）属于行为型模式， 类的行为会随着状态的改变而改变。 状态模式组成State: 抽象类或者接口，是一个具有所有状态的接口。 ConcreteState: 具体状态类，实现State接口，处理来自Context的请求。 Context: 上下文角色或者环境角色， 串联各个状态。 状态模式 UML 为什么要使用状态模式假设现在需要实现一个电风扇， 有四个状态，分别是关闭、低速、中速、高速， 每拉一次绳就变一次速， 接下来我们代码实现： 123456789101112131415161718192021222324public class CellingFanChain &#123; private int currentState; public CellingFanChain() &#123; currentState = 0; &#125; // 实现风扇的拉绳方法， 分别对四种状态进行处理， 状态之间两两变化 public void pull() &#123; if (currentState == 0) &#123; currentState = 1; System.out.println(\"\\t low speed\"); &#125; else if (currentState == 1) &#123; currentState = 2; System.out.println(\"\\t medium speed\"); &#125; else if (currentState == 2) &#123; currentState = 3; System.out.println(\"\\t high speed\"); &#125; else &#123; currentState = 0; System.out.println(\"\\t turning off\"); &#125; &#125;&#125; 客户端发起调用 1234567891011121314151617181920212223public class Client &#123; public static void main(String[] args) &#123; CellingFanChain cellingFanChain = new CellingFanChain(); while (true) &#123; System.out.print(\"Press ENTER\"); nextPull(); cellingFanChain.pull(); &#125; &#125; static String nextPull() &#123; BufferedReader in = new BufferedReader(new InputStreamReader(System.in)); String line = null; try &#123; line = in.readLine(); &#125; catch (IOException ex) &#123; ex.printStackTrace(); &#125; return line; &#125;&#125; 输出： Press ENTER low speed Press ENTER medium speed Press ENTER high speed Press ENTER turning off Press ENTER low speed Press ENTER medium speed Press ENTER high speed可以看到上面代码的实现并不是面向对象的， 没有将具体的状态抽象出来， 也没有对变化进行封装， 状态之间的转换隐藏在条件语句中，如果要加入一个新的状态或者说加一个风扇摇头的动作改起来影响面是比较大的。 状态模式代码实现State 类 123public interface State &#123; void pull(CellingFanChain cellingFanChain);&#125; ConcreteState 类 1234567891011121314151617181920212223242526272829public class Off implements State &#123; @Override public void pull(CellingFanChain cellingFanChain) &#123; System.out.println(\"\\t low speed\"); cellingFanChain.setContextState(new Low()); &#125;&#125;public class Low implements State &#123; @Override public void pull(CellingFanChain cellingFanChain) &#123; System.out.println(\"\\t medium speed\"); cellingFanChain.setContextState(new Medium()); &#125;&#125;public class Medium implements State &#123; @Override public void pull(CellingFanChain cellingFanChain) &#123; System.out.println(\"\\t high speed\"); cellingFanChain.setContextState(new High()); &#125;&#125;public class High implements State &#123; @Override public void pull(CellingFanChain cellingFanChain) &#123; System.out.println(\"\\t turning off\"); cellingFanChain.setContextState(new Off()); &#125;&#125; Context 类 123456789101112131415public class CellingFanChain &#123; private State contextState; public void setContextState(State state) &#123; contextState = state; &#125; public CellingFanChain() &#123; contextState = new Off(); &#125; public void pull() &#123; contextState.pull(this); &#125;&#125; 客户端发起调用 1234567891011121314151617181920212223public class Client &#123; public static void main(String[] args) &#123; CellingFanChain cellingFanChain = new CellingFanChain(); while (true) &#123; System.out.print(\"Press ENTER\"); nextPull(); cellingFanChain.pull(); &#125; &#125; static String nextPull() &#123; BufferedReader in = new BufferedReader(new InputStreamReader(System.in)); String line = null; try &#123; line = in.readLine(); &#125; catch (IOException ex) &#123; ex.printStackTrace(); &#125; return line; &#125;&#125; 输出： Press ENTER low speed Press ENTER medium speed Press ENTER high speed Press ENTER turning off Press ENTER low speed Press ENTER medium speed Press ENTER high speed状态模式与策略模式的区别 相似点： 两者的 UML 是一样的。 区别： 两个模式的意图不一样。 状态模式是将一组状态封装在状态对象中， context 对象可以随时委托到状态对象中的某一个， context 的行为会随着状态的改变而改变， 且用户对对象的状态并不是很关心。 策略模式是用户主动指定 context 所要组合的对象是具体哪一个（最优的那个）。 状态模式优缺点优点： 封装了转换规则。 对象的行为是状态的结果， 行为随着状态的改变而改变。 不再有大量 if … else 或者 switch … case 代码。 内聚性更高， 将不同的状态抽离与具体行为绑定在一起。 缺点： 增加了系统类和对象的个数。 对于“开闭原则”不友好， 对于可切换状态的状态模式， 增加新的状态类就需要修改负责状态转换的代码； 修改某个状态类的行为时也需要修改对应类的源码。 状态模式应用场景以下这些情况可以使用状态模式： 对象的行为依赖于它的状态并可以根据它的状态改变而改变相关的行为。 代码中保护大量与对象状态相关的语句，大量的 if…else 语句会导致代码的可维护性变差， 不能方便的删除或者增加新的类。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://coderunning.fun/categories/设计模式/"}],"tags":[{"name":"行为型模式","slug":"行为型模式","permalink":"https://coderunning.fun/tags/行为型模式/"}]},{"title":"命令模式","slug":"design-pattern/命令模式","date":"2020-04-26T10:17:23.000Z","updated":"2020-04-30T13:12:53.386Z","comments":true,"path":"2020/04/26/design-pattern/命令模式/","link":"","permalink":"https://coderunning.fun/2020/04/26/design-pattern/命令模式/","excerpt":"将请求的发起方与请求的执行方进行解耦是命令模式最显著的特征。","text":"将请求的发起方与请求的执行方进行解耦是命令模式最显著的特征。 什么是命令模式命令模式（Command Pattern）属于行为模式， 又称为行动（Action）模式或事务（Transaction）模式。软件系统中，“行为请求者”和“行为实现者”常常耦合在一起，但是行为出现特出处理（如记录、撤销、事务）等，紧耦合是无法满足要求的。 将一组行为抽象成对象，将行为请求与行为实现松耦合就是命令模式的特点。 命令模式组成Command: 定义所有命令的抽象类接口 ConcreteCommand: 具体命令角色，实现 Command 接口，接受者与行为之间的弱耦合，负责调用接受者的相应操作。 Invoker: 请求者角色， 负责调用 Client下达的对象执行请求。 Receiver: 接受者角色， 负责具体实施和执行请求者的请求。在简单的业务场景下 Receiver可省略， 直接在 ConcreteCommand类中实现具体的处理逻辑。 Client: 客户端。 命令模式 UML 命令模式代码实现Command 角色 123public interface Command &#123; void execute();&#125; ConcreteCommand 角色, 以遥控器举例， 有开、关两种操作 1234567891011121314151617181920212223242526public class LightOnCommand implements Command &#123; private Light light; public LightOnCommand(Light light) &#123; this.light = light; &#125; @Override public void execute() &#123; light.on(); &#125;&#125;public class LightOffCommand implements Command &#123; private Light light; public LightOffCommand(Light light) &#123; this.light = light; &#125; @Override public void execute() &#123; light.off(); &#125;&#125; Receiver 角色 12345678910public class Light &#123; public void off() &#123; System.out.println(\"关灯！\"); &#125; public void on() &#123; System.out.println(\"开灯！\"); &#125;&#125; Invoker角色 123456789101112131415161718192021public class RemoteControl &#123; private Command lightOnCommand; private Command lightOffCommand; public void setLightOffCommand(Command lightOffCommand) &#123; this.lightOffCommand = lightOffCommand; &#125; public void setLightOnCommand(Command lightOnCommand) &#123; this.lightOnCommand = lightOnCommand; &#125; public void turnOn() &#123; lightOnCommand.execute(); &#125; public void turnOff() &#123; lightOffCommand.execute(); &#125;&#125; 客户端调用： 1234567891011121314151617public class Client &#123; public static void main(String[] args) &#123; Light light = new Light(); Command lightOnCommand = new LightOnCommand(light); Command lightOffCommand = new LightOffCommand(light); RemoteControl remoteControl = new RemoteControl(); remoteControl.setLightOnCommand(lightOnCommand); remoteControl.turnOn(); remoteControl.setLightOffCommand(lightOffCommand); remoteControl.turnOff(); &#125;&#125; 输出： 开灯！ 关灯！利用 Command角色， 可以让 Invoker 角色不必关心调用的是 Light 对象还是其他对象， 只需要下发命令， 让 Light 执行相应的操作即可。 命令模式的 undo 操作这里的Command 角色只有 execute()一个方法， 在很多情况下需要撤销指令的时候新增 undo()方法来撤销前一个操作， 比如开灯之后按一下遥控器的按钮就可以撤销。以 LightOnCommand 为例 123456789101112131415161718192021222324public interface Command &#123; void execute(); // command 角色新增 undo()操作 void undo();&#125;// LightOnCommand 重写 undo() 方法， 执行关灯操作public class LightOnCommand implements Command &#123; private Light light; public LightOnCommand(Light light) &#123; this.light = light; &#125; @Override public void execute() &#123; light.on(); &#125; @Override public void undo() &#123; light.off(); &#125;&#125; 相应的 Invoker 也要做出相应的调整，在记录 command 请求时一并记录 undoCommand 1234567891011121314151617181920212223242526272829public class RemoteControl &#123; private Command lightOnCommand; private Command lightOffCommand; private Command undoCommand; public void setLightOnCommand(Command lightOnCommand) &#123; this.lightOnCommand = lightOnCommand; // 记录 undo 指令 this.undoCommand = lightOnCommand; &#125; public void setLightOffCommand(Command lightOffCommand) &#123; this.lightOffCommand = lightOffCommand; // 记录 undo 指令 this.undoCommand = lightOffCommand; &#125; public void turnOn() &#123; lightOnCommand.execute(); &#125; public void turnOff() &#123; lightOffCommand.execute(); &#125; // undo 操作 public void undo() &#123; undoCommand.undo(); &#125;&#125; 客户端调用： 123456789101112131415161718192021public class Client &#123; public static void main(String[] args) &#123; Light light = new Light(); Command lightOnCommand = new LightOnCommand(light); Command lightOffCommand = new LightOffCommand(light); RemoteControl remoteControl = new RemoteControl(); // 开灯操作 remoteControl.setLightOnCommand(lightOnCommand); remoteControl.turnOn(); remoteControl.undo(); // 关灯操作 remoteControl.setLightOffCommand(lightOffCommand); remoteControl.turnOff(); remoteControl.undo(); &#125;&#125; 输出： 开灯！ 关灯！ 关灯！ 开灯！命令模式要点 命令模式将发出请求的对象（Invoker）与执行请求的对象（Receiver）解耦。 被解耦的两者之间是通过命令对象（Command）进行沟通的， 命令对象封装了接受者的一个或者一组动作。 发出请求的对象通过 execute()发出请求，使得接受者的动作被调用。 命令可以支持撤销， 通过实现 undo() 方法来回到 execute()被执行前的状态。 命令模式优缺点优点： 降低系统耦合度，将请求发起者与请求执行者解耦， 双方都不知道对方的存在。 新的命令很容易加入的系统中，符合开闭原则。 若有多个命令需要一起执行， 可以实现命令队列或者宏命令（组合命令）。 支持 undo()、redo()操作 缺点： 使用命令模式可能会导致系统有过多的具体命令类。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://coderunning.fun/categories/设计模式/"}],"tags":[{"name":"行为型模式","slug":"行为型模式","permalink":"https://coderunning.fun/tags/行为型模式/"}]},{"title":"观察者模式","slug":"design-pattern/观察者模式","date":"2020-04-25T14:29:10.000Z","updated":"2020-04-25T14:43:53.465Z","comments":true,"path":"2020/04/25/design-pattern/观察者模式/","link":"","permalink":"https://coderunning.fun/2020/04/25/design-pattern/观察者模式/","excerpt":"当对象间存在一对多的关系且一个对象修改会影响到其他对象时，自动通知其他对象被依赖的对象作出改变即观察者模式。","text":"当对象间存在一对多的关系且一个对象修改会影响到其他对象时，自动通知其他对象被依赖的对象作出改变即观察者模式。 什么是观察者模式观察者模式（Observer Pattern）属于对象行为型模式。当一个对象与多个对象存在一对多的关系时， 当一个对象进行修改需要通知关注该对象的多个对象作出相应的修改。 在什么情况下使用观察者模式 对象间存在一对多的关系 被观察者发生变更时需要通知其他观察者 跨系统的消息交互 观察者模式组成Subject: 被观察者， 抽象类或者接口。 ConcreteSubject：具体被观察者，被观察者的实现，含有队列维护观察对象列表，订阅以及取消订阅方法。 Observer：观察者， 抽象类或者接口。 ConcreteObserver： 具体观察者， 观察者的实现， 当被观察者更新时观察者立马响应发生变更。 观察者模式 UML 观察者模式代码示例以微信公众号订阅为例， 用户觉得某篇文章不错开始订阅（attach）， 定期接受公众号的推送(notifyAll)， 但是发现作者的文章质量越来越差，于是部分用户取消订阅(detach)。 被观察者（Subject） 123456789public interface Subject &#123; // 对应attach方法 void register(Observer observer); // 对应detach方法 void unRegister(Observer observer); // 对应notifyAll方法 void notifyAllObservers();&#125; 具体被观察者（ConcreteSubject），这里指的是被订阅的公众号 123456789101112131415161718192021222324252627public class SubscribeSubject implements Subject &#123; // 观察者队列 private List&lt;Observer&gt; observerList = new ArrayList&lt;&gt;(); @Override public void register(Observer observer) &#123; if (observer != null) &#123; System.out.println(observer.toString() + \", 新增订阅\"); observerList.add(observer); &#125; &#125; @Override public void unRegister(Observer observer) &#123; if (observerList.contains(observer)) &#123; System.out.println(observer.toString() + \", 取消订阅\"); observerList.remove(observer); &#125; &#125; @Override public void notifyAllObservers() &#123; for (Observer observer : observerList) &#123; observer.update(observer.toString() +\", 新的订阅内容更新了！\"); &#125; &#125;&#125; 观察者（Observer） 123public interface Observer &#123; void update(String content);&#125; 具体被观察者（ConcreteObserver）， 代表订阅公众号的微信用户 123456789101112131415161718public class WeChatUser implements Observer &#123; private String name; public WeChatUser(String name) &#123; this.name = name; &#125; @Override public void update(String content) &#123; System.out.println(content); &#125; @Override public String toString() &#123; return this.name; &#125;&#125; 客户端调用： 12345678910111213141516171819202122public class Client &#123; public static void main(String[] args) &#123; // 创建订阅用户 Observer observer1 = new WeChatUser(\"Filo\"); Observer observer2 = new WeChatUser(\"Krook\"); Observer observer3 = new WeChatUser(\"HarryHook\"); Subject subject = new SubscribeSubject(); // 用户关注公众号 subject.register(observer1); subject.register(observer2); subject.register(observer3); // 通知用户公众号内容更新 subject.notifyAllObservers(); // 用户取消关注公众号 subject.unRegister(observer2); &#125;&#125; 输出： Filo, 新增订阅 Krook, 新增订阅 HarryHook, 新增订阅 Filo, 新的订阅内容更新了！ Krook, 新的订阅内容更新了！ HarryHook, 新的订阅内容更新了！ Krook, 取消订阅观察者模式优缺点优点： 解除耦合， 让双方面向接口交互 缺点： 被观察者需要维护观察者对象，将所有观察者都通知一遍，若一个观察者卡顿将会影响到其他的观察者， 所有一般采用异步通知。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://coderunning.fun/categories/设计模式/"}],"tags":[{"name":"行为型模式","slug":"行为型模式","permalink":"https://coderunning.fun/tags/行为型模式/"}]},{"title":"策略模式","slug":"design-pattern/策略模式","date":"2020-04-24T09:02:47.000Z","updated":"2020-04-30T13:12:53.388Z","comments":true,"path":"2020/04/24/design-pattern/策略模式/","link":"","permalink":"https://coderunning.fun/2020/04/24/design-pattern/策略模式/","excerpt":"对不同算法进行封装， 让客户端决定去使用哪种算法就是策略模式。","text":"对不同算法进行封装， 让客户端决定去使用哪种算法就是策略模式。 什么是策略模式策略模式针对一组算法，将每个算法封装到具有共同接口的独立类中， 使它们可以相互替换。 策略模式使得算法可以在不影响到客户端的情况下发生变化。 策略模式组成Context: 上下文角色, 持有 Strategy 引用。 Strategy: 抽象策略角色, 通常由一个接口或者抽象类实现。 ConcreteStrategy: 具体策略角色, 实现具体的策略算法。 策略模式 UML 策略模式代码实现123456789101112131415161718192021222324252627282930313233343536373839404142// Strategy接口public interface OperatorStrategy &#123; int operation(int num1, int num2);&#125;// ContreteStrategy接口public class AddOperateStrategy implements OperatorStrategy &#123; @Override public int operation(int num1, int num2) &#123; return num1 + num2; &#125;&#125;// ContreteStrategy接口public class SubOperateStrategy implements OperatorStrategy &#123; @Override public int operation(int num1, int num2) &#123; return num1 - num2; &#125;&#125;// ContreteStrategy接口public class MultiplyOperateStrategy implements OperatorStrategy &#123; @Override public int operation(int num1, int num2) &#123; return num1 * num2; &#125;&#125;// Context 类public class Operator &#123; private OperatorStrategy strategy; public Operator(OperatorStrategy operatorStrategy) &#123; this.strategy = operatorStrategy; &#125; public int execute(int num1, int num2) &#123; return this.strategy.operation(num1, num2); &#125;&#125; // 客户端调用 1234567891011121314151617public class Client &#123; public static void main(String[] args) &#123; Operator addOperator = new Operator(new AddOperateStrategy()); System.out.println(addOperator.execute(1, 2)); Operator subOperator = new Operator(new SubOperateStrategy()); System.out.println(subOperator.execute(1, 2)); Operator multiplyOperator = new Operator(new MultiplyOperateStrategy()); System.out.println(multiplyOperator.execute(1, 2)); &#125;&#125; 输出： 1 + 2 = 3 1 - 2 = -1 1 * 2 = 2策略模式优缺点优点： 算法可以自由切换。 扩展性好，增加新的策略很方便， 新增一个策略类即可。 缺点： 策略类的数量增多。 所有的策略类都需要对外暴露，上层模块必须知道所有的策略才能决定使用哪个策略。 策略模式在 JDK 中的应用JDK 的线程池中可以看下 ThreadPoolExecutor 的构造方法中的 handler 12345678910111213141516171819202122232425/** * Handler called when saturated or shutdown in execute. */private volatile RejectedExecutionHandler handler;public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; //.... this.handler = handler;&#125;/** * Invokes the rejected execution handler for the given command. * Package-protected for use by ScheduledThreadPoolExecutor. */final void reject(Runnable command) &#123; handler.rejectedExecution(command, this);&#125; 其中 RejectedExecutionHandler 的执行就是策略模式的实现。 reject 执行拒绝策略有四种实现： 直接抛出异常、使用调用者的线程来处理、直接丢掉这个任务、丢掉最老的任务。 策略模式与工厂模式对比相似点： 结构相似，都是对象的继承与多态。差异： 工厂模式是创建型模式，运行时创建对象；策略模式是行为模式，让对象在不同情况下选择行为。 工厂模式关注对象的创建，策略模式关注行为的封装。 工厂模式是黑盒，策略模式是白盒。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://coderunning.fun/categories/设计模式/"}],"tags":[{"name":"行为型模式","slug":"行为型模式","permalink":"https://coderunning.fun/tags/行为型模式/"}]},{"title":"LeetCode 142. Linked List Cycle II","slug":"leetcode/linkedlist/linked-list-cycle-ii","date":"2020-04-19T09:00:52.000Z","updated":"2020-04-24T15:03:26.676Z","comments":true,"path":"2020/04/19/leetcode/linkedlist/linked-list-cycle-ii/","link":"","permalink":"https://coderunning.fun/2020/04/19/leetcode/linkedlist/linked-list-cycle-ii/","excerpt":"Given a linked list, return the node where the cycle begins. If there is no cycle, return null.","text":"Given a linked list, return the node where the cycle begins. If there is no cycle, return null. To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list. Note: Do not modify the linked list. Example 1: Input: head = [3,2,0,-4], pos = 1 Output: tail connects to node index 1 Explanation: There is a cycle in the linked list, where tail connects to the second node. 题意给出一个链表， 判断是否有环， 有环的话返回环开始的结点。 若环不存在，返回 null 思路返回环相交的结点需要分两步 判断环是否存在， 不存在返回 null， 此处需要利用快慢指针 若环存在， 需要利用以下公式 假设头结点到环开始的位置为 x1， 环开始的结点到相交的结点 x2, ， 相遇结点到环开始的结点 x3， 环的长度为 N 。 因为快指针是慢指针走过路程的两倍, 所以有以下结论 慢指针走过的距离： x1 + x2快指针走过的距离： x1 + x2 + x3 + x2环的长度：N = x2 + x3 2(x1 + x2) = x1 + x2 + x3 + x2 =====&gt;&gt;&gt;&gt; x1 = x3， 所以当快慢指针相遇时从头结点遍历到与慢指针相遇即为环形结点开始处。 详细推导： 2*(x1 + x2) + 2n*(x3 + x2) = (x1 + x2 + x3 + x2) + m*(x3 + x2) x1 + 2n*(x3 + x2) = x3 + m*(x3 + x2) x1 = x3 + (x3 + x2)*(m - 2n)代码1234567891011121314151617181920212223242526public ListNode detectCycle(ListNode head) &#123; if(head == null || head.next == null) &#123; return null; &#125; ListNode fast = head; ListNode slow = head; while(fast != null &amp;&amp; fast.next != null) &#123; fast = fast.next.next; slow = slow.next; // 快慢指针相遇 if(slow == fast) &#123; break; &#125; &#125; // 环不存在 if(fast != slow) return null; fast = head; // fast 从头结点遍历， slow 指针从相遇处遍历， 再次相遇即为环开始处 while(fast != slow) &#123; fast = fast.next; slow = slow.next; &#125; return fast;&#125;","categories":[{"name":"每周一题","slug":"每周一题","permalink":"https://coderunning.fun/categories/每周一题/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://coderunning.fun/tags/leetcode/"},{"name":"linkedlist","slug":"linkedlist","permalink":"https://coderunning.fun/tags/linkedlist/"}]},{"title":"LeetCode 141. Linked List Cycle","slug":"leetcode/linkedlist/linked-list-cycle","date":"2020-04-19T03:33:05.000Z","updated":"2020-04-24T15:03:26.677Z","comments":true,"path":"2020/04/19/leetcode/linkedlist/linked-list-cycle/","link":"","permalink":"https://coderunning.fun/2020/04/19/leetcode/linkedlist/linked-list-cycle/","excerpt":"Given a linked list, determine if it has a cycle in it.","text":"Given a linked list, determine if it has a cycle in it. To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list. Example 1: Input: head = [3,2,0,-4], pos = 1 Output: true Explanation: There is a cycle in the linked list, where tail connects to the second node. 题意给出一个链表， 判断链表是否存在环。 思路判断是否有环， 与无环的链表相比， 无环的链表如果进行遍历最终会走向 null 结点。有环的结点因为环的存在会在环内循环， 所以利用快慢指针， 判断快慢指针是否会重合。 代码1234567891011121314151617181920public boolean hasCycle(ListNode head) &#123; if(head == null || head.next == null) &#123; return false; &#125; ListNode fast = head; ListNode slow = head; while(fast != null &amp;&amp; fast.next != null) &#123; fast = fast.next.next; slow = slow.next; // 快慢指针相遇 if(fast == slow)&#123; return true; &#125; &#125; return false; &#125;","categories":[{"name":"每周一题","slug":"每周一题","permalink":"https://coderunning.fun/categories/每周一题/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://coderunning.fun/tags/leetcode/"},{"name":"linkedlist","slug":"linkedlist","permalink":"https://coderunning.fun/tags/linkedlist/"}]},{"title":"享元模式","slug":"design-pattern/享元模式","date":"2020-04-17T12:53:49.000Z","updated":"2020-04-24T15:03:26.658Z","comments":true,"path":"2020/04/17/design-pattern/享元模式/","link":"","permalink":"https://coderunning.fun/2020/04/17/design-pattern/享元模式/","excerpt":"享元模式是一种支持细粒度对象复用的结构型设计模式，又称为 轻量级模式。","text":"享元模式是一种支持细粒度对象复用的结构型设计模式，又称为 轻量级模式。 什么是享元模式享元模式 (FlyWeight Pattern) 是为了解决系统运行中产生的对象太多，导致运行代价过高、系统性能下降的问题。比如文本字符串中有很多相同的字符，若每一个字符都用单独的对象去表示将会占用很多的内存空间，而享元模式通过共享实现了对象的重用，使出现的每一个字符在内存中共享一个对象。 什么情况下需要使用享元模式 当我们需要大量细粒度对象且只有几个参数， 并且大多数特性是相同的。 当需要创建更少的对象并将它们共享来空盒子大量对象的内存消耗。 内部状态和外部状态享元对象具有两种状态：内部状态 (Intrinsic State) 和外部状态 (Extrinsic State). 享元对象中共享的状态为内部状态。内部状态是存储在享元对象内部并且不会随着环境改变而改变的状态，例如字符 a 在任何环境下始终是 a。 由外部环境设置不能共享的内容称为外部状态。外部状态会随环境改变而改变，外部状态之间是相互独立的，例如字符的颜色或者字号大小，外部状态独立变化相互之间没有影响。 外部状态可以通过对象创建的时候传递给享元对象。 享元模式组成享元模式可以分为单纯享元与复合享元两种模式。 单纯享元模式 FlyWeight(抽象享元类)：抽象类或者接口，在接口中定义了具体享元类的公共方法，公共方法向外部提供享元对象的内部数据（内部状态），也可以通过公共方法设置外部数据（外部方法）。 ConcreteFlyWeight(具体享元类)： 实现了抽象享元类， 其实例成为享元对象；在具体享元类为内部状态提供存储空间。 FlyWeightFactory(享元工厂类)： 享元工厂创建并管理享元对象， 针对抽象享元类将各种具体享元对象存储在一个享元池中（通常是 Map ）。使用工厂模式创建享元实例， 如果不存在将其存储在享元池中， 如果存在直接从享元池中提供实例。 单纯享元模式代码实现以画圆举例，需要在不同的坐标上不同颜色 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788// 抽象享元类public interface Shape &#123; void draw(int x, int y, int radius);&#125;// 具体享元类public class Circle implements Shape &#123; // 内部状态可共享 private String color; // 外部状态 private int x; // 外部状态 private int y; // 外部状态 private int radius; public Circle(String color) &#123; this.color = color; &#125; @Override public void draw(int x, int y, int radius) &#123; this.x = x; this.y = y; this.radius = radius; System.out.println(\"draw a circle: \" + \"color: \" + color + \", x: \" + x + \", y \" + y + \", radius \" + radius); &#125;&#125;// 享元工厂类public class ShapeFactory &#123; // 享元池 private static HashMap&lt;String, Shape&gt; circleMap = new HashMap&lt;&gt;(); public Shape getCircle(String color) &#123; Shape circle = circleMap.get(color); if (circle == null) &#123; circle = new Circle(color); circleMap.put(color, circle); &#125; return circle; &#125; public int poolSize() &#123; return circleMap.size(); &#125;&#125;// 客户端调用public class Client &#123; public static void main(String[] args) &#123; ShapeFactory shapeFactory = new ShapeFactory(); Shape blackCircle1 = shapeFactory.getCircle(\"Black\"); blackCircle1.draw(getRandomX(), getRandomY(), getRandomRadius()); Shape blackCircle2 = shapeFactory.getCircle(\"Black\"); blackCircle2.draw(getRandomX(), getRandomY(), getRandomRadius()); System.out.println( blackCircle1 == blackCircle2); System.out.println(\"pool size: \" + shapeFactory.poolSize()); System.out.println(\"pool size: \" + shapeFactory.poolSize()); &#125; private static int getRandomRadius() &#123; return (int) (Math.random() * 100); &#125; private static int getRandomY() &#123; return (int) (Math.random() * 100); &#125; private static int getRandomX() &#123; return (int) (Math.random() * 100); &#125;&#125; 输出结果： draw a circle: color: Black, x: 23, y 72, radius 4 draw a circle: color: Black, x: 77, y 79, radius 44 true pool size: 1复合享元模式 复合享元模式组成: 抽象享元角色(Flyweight) 具体享元角色(ConcreteFlyweight) 复合享元角色(ConcreteCompositeFlyweight) 享元工厂角色(FlyweightFactory) 复合享元模式相比于单纯享元模式多了 复合享元对象 (ConcreteComositeFlyWeight)：复合享元角色所代表的对象是不可以共享的，一个复合享元对象可以有多个具体享元对象组成。 因此提供 add()方法来聚集管理单纯享元角色， 且多了一个 map 对象。 复合享元模式代码实现复合享元类——CompositeConcreteFlyweight 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596public class CompositeCircle implements Shape &#123; // 单纯享元对象集合 private Map&lt;String, Shape&gt; flyWeights = new HashMap&lt;&gt;(); /** * flyWeights 是单纯享元对象集合，具有相同的外部状态extrinsicState * 该示例中extrinsicState则是相同的 x, y, radius */ @Override public void draw(int x, int y, int radius) &#123; for (Map.Entry&lt;String, Shape&gt; entry : flyWeights.entrySet()) &#123; entry.getValue().draw(x, y, radius); &#125; &#125; public void add(String color, Shape shape) &#123; flyWeights.put(color, shape); &#125;&#125;public class ShapeFactory &#123; private static HashMap&lt;String, Shape&gt; flyWeights = new HashMap&lt;&gt;(); public Shape getCircle(String color) &#123; Shape circle = flyWeights.get(color); if (circle == null) &#123; circle = new Circle(color); flyWeights.put(color, circle); &#125; return circle; &#125; public Shape getCircle(List&lt;String&gt; colors) &#123; CompositeCircle compositeCircle = new CompositeCircle(); for (String color : colors) &#123; // 调用单纯享元工厂模式方法， 使用 add() 方法加入的单纯享元对象是可以共享的 compositeCircle.add(color, this.getCircle(color)); &#125; return compositeCircle; &#125; public int poolSize() &#123; return flyWeights.size(); &#125;&#125;客户端调用：public class Client &#123; private static final String colors[] = &#123;\"Red\", \"Green\", \"Blue\", \"White\", \"Black\"&#125;; public static void main(String[] args) &#123; List&lt;String&gt; compositeState = new ArrayList&lt;&gt;(); compositeState.add(getRandomColor()); compositeState.add(getRandomColor()); compositeState.add(getRandomColor()); compositeState.add(getRandomColor()); ShapeFactory shapeFactory = new ShapeFactory(); Shape circle1 = shapeFactory.getCircle(compositeState); Shape circle2 = shapeFactory.getCircle(compositeState); // 复合享元对象不可共享 System.out.println(circle1 == circle2); // 多个单处享元对象具有相同的外部状态 circle1.draw(getRandomX(), getRandomY(), getRandomRadius()); circle2.draw(getRandomX(), getRandomY(), getRandomRadius()); System.out.println(\"pool size: \" + shapeFactory.poolSize()); &#125; private static String getRandomColor() &#123; return colors[(int) (colors.length * Math.random())]; &#125; private static int getRandomRadius() &#123; return (int) (Math.random() * 100); &#125; private static int getRandomY() &#123; return (int) (Math.random() * 100); &#125; private static int getRandomX() &#123; return (int) (Math.random() * 100); &#125;&#125; 输出： false draw a circle: color: White, x: 89, y 50, radius 16 draw a circle: color: Blue, x: 89, y 50, radius 16 draw a circle: color: Black, x: 89, y 50, radius 16 draw a circle: color: White, x: 41, y 60, radius 35 draw a circle: color: Blue, x: 41, y 60, radius 35 draw a circle: color: Black, x: 41, y 60, radius 35 pool size: 3享元模式的优缺点优点： 实现了对象共享 使用享元模式减少了对象的创建，减少了内存的使用 缺点： 需要分离出内部状态和外部状态，系统更复杂","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://coderunning.fun/categories/设计模式/"}],"tags":[{"name":"结构型模式","slug":"结构型模式","permalink":"https://coderunning.fun/tags/结构型模式/"}]},{"title":"LeetCode 138. Copy List with Random Pointer","slug":"leetcode/linkedlist/copy-list-with-random-pointer","date":"2020-04-12T14:27:21.000Z","updated":"2020-04-24T15:03:26.676Z","comments":true,"path":"2020/04/12/leetcode/linkedlist/copy-list-with-random-pointer/","link":"","permalink":"https://coderunning.fun/2020/04/12/leetcode/linkedlist/copy-list-with-random-pointer/","excerpt":"A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.","text":"A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null. Return a deep copy of the list. The Linked List is represented in the input/output as a list of n nodes. Each node is represented as a pair of [val, random_index] where: val: an integer representing Node.valrandom_index: the index of the node (range from 0 to n-1) where random pointer points to, or null if it does not point to any node. Example 1: Input: head = [[7,null],[13,0],[11,4],[10,2],[1,0]] Output: [[7,null],[13,0],[11,4],[10,2],[1,0]] 题意给出有个链表， 结点含有 value域， next 指针、random 指针， 其中 next 指针指向下一个结点， random 指向任意结点， 现在需要复制一个给定链表。 思路： 先复制 next 结点 再复制 random 结点 连接新的链表 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/*// Definition for a Node.class Node &#123; int val; Node next; Node random; public Node(int val) &#123; this.val = val; this.next = null; this.random = null; &#125;&#125;*/class Solution &#123; public Node copyRandomList(Node head) &#123; generateNext(head); connectRandom(head); return reconnectList(head); &#125; public static void generateNext(Node head) &#123; Node pNode = head; while(pNode != null) &#123; Node pCloned = new Node(pNode.val); pCloned.next = pNode.next; pNode.next = pCloned; pNode = pCloned.next; &#125; &#125; public static void connectRandom(Node head) &#123; Node pNode = head; Node pCloned = null; while(pNode != null) &#123; pCloned = pNode.next; if(pNode.random != null) &#123; pCloned.random = pNode.random.next; &#125; pNode = pCloned.next; &#125; &#125; public static Node reconnectList(Node head) &#123; Node pNode = head; Node cloneHead = null; Node pCloned = null; if(pNode != null) &#123; pCloned = cloneHead = head.next; pNode.next = pCloned.next; pNode = pCloned.next; &#125; while(pNode != null) &#123; pCloned.next = pNode.next; pCloned = pCloned.next; pNode.next = pCloned.next; pNode = pCloned.next; &#125; return cloneHead; &#125;&#125;","categories":[{"name":"每周一题","slug":"每周一题","permalink":"https://coderunning.fun/categories/每周一题/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://coderunning.fun/tags/leetcode/"},{"name":"linkedlist","slug":"linkedlist","permalink":"https://coderunning.fun/tags/linkedlist/"}]},{"title":"MySQL 负载均衡","slug":"mysql/note11-load-banlancing","date":"2020-04-11T09:21:46.000Z","updated":"2020-04-24T15:03:26.688Z","comments":true,"path":"2020/04/11/mysql/note11-load-banlancing/","link":"","permalink":"https://coderunning.fun/2020/04/11/mysql/note11-load-banlancing/","excerpt":"负载均衡的目的在于将流量平均的分发到集群中的机器。","text":"负载均衡的目的在于将流量平均的分发到集群中的机器。 负载均衡的目的在于： 提高可扩展性：读写分离是从备库读取数据 高效性：可以把更多的工作分配给性能更好的机器 可用性：时刻都有可用的机器 透明性：客户端无感知负载方案 一致性：负载防止状态丢失，而无需应用去跟踪 负载均衡通常与数据分片和复制相关， 需要关心的是读写策略， 一般来说有直接连接， 采用中间件以及一主多备间的负载均衡 直接连接负载均衡并不只是配置在应用以及 MySQL 之间的东西，也可以直接连接到服务器。 复制上的读写分离如何避免因为读写分离引起的脏数据的问题， 当一个用户进行了修改新增了一条评论， 但是刷新页面后却没有看到更新，这种通常都是因为从备库读取到了脏数据。 常见的读写分离的方法有： 基于查询分离 将不能接受有脏数据的读写操作分配给主库， 始终保证数据是最新的。但是有很少的查询允许脏数据， 大多数的查询都分配给主库， 主从就没有意义了。基于脏数据分离： 让应用检查复制延迟，确认备库数据是否太旧。 很多报表类的应用都是晚上加载数据复制到备库即可，并不关心是否100%跟上了主库， 每晚更新一次。基于会话分离： 判断用户是否可以从备库读取数据的另一种方式： 先判断用户是否修改了数据。 用户只关心自己做的更新， 在会话层设置一个标记位，表明做了更新就将该用户的查询在一段时间内指向主库。基于版本分离： 跟踪对象的版本号以及时间戳， 如果备库的数据太旧，就从主库读取最新的数据。 基于全局版本/会话分离： 在应用执行写操作时，提交事务后执行一次 SHOW MASTER STATUS 操作，在缓存中存储主库日志坐标，作为被修改对象/会话的版本号， 连接从库时执行 SHOW SLAVE STATUS 并将备库的坐标与缓存中的版本号相对比， 如果备库的记录点和主库的不一致就读取主库数据。修改应用的配置应用的配置不要写死， 而是将配置存储在服务器或者缓存中， 这样更灵活。 修改 DNS 名称 为不同服务器指定一个合适的名字， 为只读服务器分配一个 DNS 名， 为专门写操作的服务器起另外一个 DNS 名称。 如果备库能够跟上主库， 就将只读 DNS 名称指定给备库， 当出现延迟时， 再将 DNS 名指定给主库。 这种修改 DNS 名称的技术很容易实现， 但是有很多缺点，最大的问题是无法控制 DNS。 修改 DNS 并不是立马生效， 也不是原子操作。 DNS 数据会缓存， 且失效时间并不是强制的。 可能需要应用或服务器重启才能使修改后的 DNS 完全生效。 多个 IP 地址共用一个 DNS 名 并依赖轮询来均衡请求。 所有通常不建议使用这种方式。 转移 IP 地址为每一个物理服务器分配一个固定的 IP 地址， 再为每个逻辑上的服务使用一个虚拟的 IP 地址。 引入中间件 之前讨论的方案是应用与 MySQL 直连， 实际上很多解决方案会引入中间件， 作为网络代理一边接受所有的通信请求， 另一边将这些请求派发到指定的机器上。 如图所示的解决方案 负载均衡器 负载均衡器更多用在 WEB 服务商， 因为大多数的负载均衡器都支持HTTP， MySQL 的链接都是 TCP/IP 链接， 所以在 MySQL上使用多用途负载均衡器， 但是由于缺少 MySQL 专有的特性， 会有许多限制。 除非负载均衡器知道 MySQL 的负载， 否则无法做到恨到的负载均衡。 负载均衡器不知道如何把单个 HTTP 请求与 MySQL服务器绑定。 连接池和长连接会阻碍负载均衡器分发请求。 MySQL不接受到 3306 端口的 HTTP 请求， 所以不能通过 HTTP 请求进行负载检查， 所以需要在 MySQL服务器额外安装一个 HTTP 服务器软件， 这个软件检查MySQL服务器的状态并返回一个对应的状态值。 负载均衡算法随机： 从可用的服务池中选择一个服务器处理请求 轮询： 按照循环顺序发送请求到服务器。 最少连接数： 下一个请求分配给拥有最少活跃连接的服务器。 最快响应： 按照处理请求的响应时间分配请求。 哈希： 根据连接的源 IP 进行哈希， 映射到池中的同一服务器。 权重： 对应集群中有单核 CPU 与双核 CPU 时， 负载均衡器会分配两倍的请求给双 CPU 机器。 具体哪种算法更合适需要根据实际场景测试得出。 从服务器池中新增/移除服务器新增的服务器可能未缓存数据， 第一次查询需要很长时间。 在通知负载均衡器有新机器加入之前可以暂时把查询映射到一台活跃的服务器上， 然后在新开启的服务器上读取和重放活跃服务器的日志文件， 或者捕捉生产服务器上的网络通信。 一主多备间的负载均衡对于最常见的复制拓扑结构， 以下的方法可以更好的结合负载均衡。 功能分区： 对于特定目的可以通过配置备库或一组备库来扩大容量。过滤和数据分区： 使用复制过滤技术对相似的备库进行分区例如将 A-M 开头的用户名的读操作分配给一个给定的备库， N-Z 开头的分配给另一个。 将部分写操作转移到备库： 分解写查询， 在备库执行一部分 保证备库跟上主库： 使用函数 MASTER_POS_WAIT() 阻塞直到备库赶上主库设置的同步点。 同步写操作： 每个备库轮流执行 MASTER_POS_WAIT()， 不到万不得已不要使用， 可能会阻塞很长时间。选择合适的分片策略并不是说在应用设计初期就需要考虑分区分表， 做出来才是最重要的。","categories":[{"name":"数据库","slug":"数据库","permalink":"https://coderunning.fun/categories/数据库/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://coderunning.fun/tags/MySQL/"}]},{"title":"MySQL 扩展","slug":"mysql/note10-scaling-mysql","date":"2020-04-06T15:31:32.000Z","updated":"2020-04-24T15:03:26.688Z","comments":true,"path":"2020/04/06/mysql/note10-scaling-mysql/","link":"","permalink":"https://coderunning.fun/2020/04/06/mysql/note10-scaling-mysql/","excerpt":"当 MySQL 规模变的越来越大时， 如何保证高效且经济？","text":"当 MySQL 规模变的越来越大时， 如何保证高效且经济？ 可扩展性可扩展性表明当需要增加资源以执行更多工作时系统能获得收益的同等提升。 缺乏扩展能力的系统达到收益递减的转折点后， 将无法进一步增长。 系统是否需要扩展一般从哪个四个因素进行衡量： 数据量 用户量 用户活跃度 相关数据集大小 增加服务器并不能完全增加系统的吞吐率， 大多数情况下都属于 USL 扩展 如何扩展 MySQLMySQL 扩展通常分为”垂直”扩展和”水平”扩展。 垂直扩展就是增加更多的机器， 水平扩展是将任务拆分分配到多台机器上。 知晓系统的底线 应用的功能是否都开发完毕了？ 是否到了需要扩展的阶段了。 预期的最大负载是多少？ 如果局部失效如何防范。 扩展前先优化 优化性能 升级硬件 向上扩展-垂直扩展建议使用更新的 MySQL 版本， 最大的配置是 256G RAM， 32 核 CPU， 再之后收益就递减了。但是向上扩展的开销太大了， 并不是很好的选择。 向外扩展-水平扩展向外扩展可以分为三步：复制、拆分和数据分片 最简单的做法是通过复制将数据分发到多个服务器上， 通过备库进行读查询， 对以读为主的应用很有效。 此外常见的做法是工作负载到多个节点， 其中节点可能是一个服务器， 也可能是一个集群， 通常有以下几种： 一个主-主复制双机机构， 一个主动，一个被动； 一主多备 一个主动服务器，使用分布式复制设备作为备库 一个基于存储区域网络的集群 下面是一些不同的分布负载方案 按功能拆分不同的节点执行不同的任务，比如门户网站将论坛、新闻、知识库等不同的功能所需的数据存在不同的数据库中。 此外也可以对单台服务器的数据进行划分， 前提是表与表之间不会进行关联操作。 实际上不能通过功能划分进行无限扩展， 当一个功能与单个 MySQL 绑定后就只能垂直扩展了。 数据分片在扩展大型 MySQL 应用的方案中，数据分片是最通用且最成功的方法。在数据分片前需要考虑当前的应用是否需要分片， 比如正在搭建的博客网站， 预计有 1000 万用户，这个时候就算把所以用户数据放在内存中也是可行的， 但是当用户达到 5 亿时就可能需要对数据进行分片了。 如果在设计之初就已经预计到分片， 之后分片就会容易很多。 单台服务器的功能划分： 继续演进， 通过用户 ID 对文章和内容进行分片： 如果事先知道应用会扩展到很大规模且了解功能划分的局限性， 就可以跳过中间步骤， 直接从单个节点升级为分片数据存储。 选择分区键数据分片的挑战在于查找与获取数据， 对经常查询的数据减少分片， 最关键的点在于为数据选择一个或多个分区键， 因为分区键决定了每一行分配在哪一个分片中。 当知道一个对象的分区键， 就知道了 应该从哪里存储数据 应该从哪里查询数据 一个好的分区键通常是数据库中一个非常重要的实体的主键， 例如通过用户 ID 来分割数据， 分片的单元就是用户。 选择分区键的时候尽可能选择能够避免跨分片查询的键， 同时也让分片足够小以免过大的数据导致问题。 多个分区键复杂数据分区困难时， 会拥有多个分区键。 例如需要对博客的数据按照用户 ID 和 文章 ID 进行分片， 这样即可以根据用户 ID 获取该用户的所有文章， 还可以通过文章 ID 获取该文章的所有评论。 跨分片查询大多数分片应用都有一些查询需要对多个分片的数据进行聚合或关联操作。 例如获取当前网站最受欢迎的用户， 就需要把所有分片访问一遍， 实际上需要拆分成多条并行执行的查询， 每个分片执行一条。 在并行查询时， 某些语言比如PHP对并行支持的并不好， 会利用 C 或者 JAVA 写一个辅助应用来执行聚合查询 同样的， 使用汇总表也可以提升跨分片查询的效率， 可以遍历所有分片来生成汇总表并将结果在每个分片上冗余存储。 分片与节点分片和节点并不是一对一的关系， 尽可能让分片的大小小于节点的容量。 首先分片足够小便于管理， 使得数据的备份和恢复更加容易， 假设100 G 的数据， 分为 100 个 1G 的分片， 存储在单个节点上， 对数据加索引时， 单个100 G 的表的执行时间会比 100 个 1G 的分片执行的时间更长。 其次， 小的分片更方便转移。 节点上部署分片通常有一下几种方法部署数据分片： 每个分片使用单一数据库，且数据库名相同。对应的应用场景是多实例应用， 每个应用对应一个分片。 将多个分片的表放在一个数据库中， 每个表名包含分片号。 每个分片使用一个数据库， 数据库中包含所有应用需要的表， 库名中包含分片号但表名不包含分片号。 当应用连接到数据库病不指定数据库名时， 则无须为每个分片编写专门的查询。 每个分片使用一个数据库， 并在数据库名和表名包含分片号。 每个节点运行多个MySQL示例， 每个实例有一个或多个分片。 固定分配与动态分配将数据分配到分片中有两种主要的做法： 固定分配和动态分配。两个方法都需要分区函数，行的分区键值作为输入，存储改行的分片作为输出。 固定分配的好处在于分区函数仅仅依赖于分区键的值， 这样做简单，开销低， 比如使用 CRC32() 做哈希， CRC32(111) % 100 = 81。 动态分配将每个数据单元映射到一个分片， 假设数据表有 用户ID 与 分片 ID， 根据分区键（用户ID）就可以查到 分片号， 如果没有查到对应分片号， 可以选择将目标分片号与当前用户ID绑定或者延迟更新。 混合分配混合使用固定分配和动态分配， 映射目录不大时， 动态分配很好胜任， 分片单元太多效果会变差。 显式分配很少使用， 不适合在已有数据上分片。 重新均衡分片数据在分片间移动数据达到负载均衡。例如需要升级硬件时， 将用户数据从旧分片转移到新分片上， 无需暂停整个分片的服务， 也无需将其设置为只读。 但是进行均衡分片时会影响到用户的使用。 生成全局唯一 ID通常单一数据存储时使用 AUTO_INCREMENT 列来获取唯一 ID， 但是涉及到多台服务器时就不生效了， 此时需要生产全局的唯一 ID， 通常有以下几种做法： 使用 auto_increment_inncrement 和 auto_increment_offset 假设两台服务器， 一个偏移量为 1，另一台偏移量为 2， 这样一台服务器始终包含偶数， 一台服务器始终包含奇数。需要仔细配置。全局节点创建表： 在一个全局数据库节点中创建一个包含 AUTO_INCREMENT 列的表， 通过这个表生成唯一的数字。使用 memcached memcached的 api 有一个 incr()函数，自动增长一个数字并返回结果。memcached不具备持久性，重启后会初始化缓存的值会从磁盘中查询最大的值，过程慢切不能保证原子性。批量分配数字 从全局节点中请求一批数字。使用复合值 使用复合值作为唯一 ID。使用 GUID 值 使用 UUID() 函数生成全局唯一值使用全局分配器产生唯一 ID 需要注意避免单点争用成为性能瓶颈。 分片工具使用抽象层可以避免直接让应用访问多个数据源， 而是将数据源隐藏在抽象层，抽象层主要完成以下工作： 连接到正确的分片并进行查询 分布式一致性校验 跨分片结果集聚合 跨分片关联操作 锁和事务管理 创建新的数据分片 常见的分片工具有 Hibernnate Shards 和 HiveDB。 多实例扩展不要在一台服务器上只运行一个服务器实例，让数据分片足够小， 使每台机器都能放置多个分片， 这是一种向上扩展和向外扩展的组合方案。 通过集群扩展对比 MySQL 与 NoSQL MySQL ClusterMySQL Cluster 由 NDB 数据库和 MySQL 存储引擎组成。 其中 NDB 是一个分布式、具备容错性、非共享的数据库， 提供同步复制以及节点间的数据自动分片。 NDB 是一个键-值数据存储， 无法执行类似聚合或者联结操作。 ClustrixClustrix 是一个分布式数据库， 支持 MySQL 协议， 它可以直接替代 MySQL， 支持 ACID， 支持 MVCC 的事务型SQL 的数据库。与MySQL Cluster 的不同点在于 Clustrix 是完全分布式且能兼容 MySQL 协议。 ScaleBaseScaleBase是一个代理器， 处于应用和多个后端 MySQL 服务器之间， 会把发起的查询进行分裂并将其分发到后端服务器并发执行， 然后汇总结果给应用。 GenieDB不支持 ACID， 最初用在地理上分布部署的 NoSQL 文档存储。 Akiban查询加速器， 存储物理数据来匹配查询模式， 可以进行低开销的跨表关联操作。 向内扩展对不断增长的数据最简单的做法对不再需要的数据进行归档和清理， 设计和清理时需要考虑以下几点： 对应用的影响 要归档的行 维护数据的一致性 避免数据丢失 解除归档","categories":[{"name":"数据库","slug":"数据库","permalink":"https://coderunning.fun/categories/数据库/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://coderunning.fun/tags/MySQL/"}]},{"title":"LeetCode 109. Convert Sorted List to Binary Search Tree","slug":"leetcode/linkedlist/convert-sorted-list-to-binary-search-tree","date":"2020-03-29T02:33:37.000Z","updated":"2020-04-24T15:03:26.673Z","comments":true,"path":"2020/03/29/leetcode/linkedlist/convert-sorted-list-to-binary-search-tree/","link":"","permalink":"https://coderunning.fun/2020/03/29/leetcode/linkedlist/convert-sorted-list-to-binary-search-tree/","excerpt":"Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.","text":"Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. ExampleGiven the sorted linked list: [-10,-3,0,5,9], One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST: 0 / \\ -3 9 / / -10 5题意给定一个升序链表， 转换成高度平衡二叉树。其实就是中序遍历变前序遍历， 关键点是找到树的根结点， 也就是升序链表的中间结点， 然后递归遍历。 示意图 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; *//** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode sortedListToBST(ListNode head) &#123; if (head == null) &#123; return null; &#125; ListNode fast = head; ListNode slow = head; ListNode temp = null; while (fast != null &amp;&amp; fast.next != null) &#123; temp = slow; fast = fast.next.next; slow = slow.next; &#125; // 断开链表 if (temp != null) &#123; temp.next = null; &#125; else &#123; head = null; &#125; TreeNode root = new TreeNode(slow.val); root.left = sortedListToBST(head); root.right = sortedListToBST(slow.next); return root; &#125;&#125;","categories":[{"name":"每周一题","slug":"每周一题","permalink":"https://coderunning.fun/categories/每周一题/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://coderunning.fun/tags/leetcode/"},{"name":"linkedlist","slug":"linkedlist","permalink":"https://coderunning.fun/tags/linkedlist/"}]},{"title":"MySQL 复制存在的问题","slug":"mysql/note9-replica-problems","date":"2020-03-28T04:13:27.000Z","updated":"2020-04-24T15:03:26.698Z","comments":true,"path":"2020/03/28/mysql/note9-replica-problems/","link":"","permalink":"https://coderunning.fun/2020/03/28/mysql/note9-replica-problems/","excerpt":"MySQL 复制存在哪些问题?","text":"MySQL 复制存在哪些问题? 复制的问题及解决方案数据损坏或丢失当服务器崩溃、掉电、磁盘损坏等情况下， MySQL 复制并不能很好的恢复。需要从某个节点开始重启复制。一下是意外关闭服务器，没有把数据及时刷新到磁盘带来的复制问题： master 意外关闭 如果没有设置master 的 sync_binlog 选项， master 崩溃前没有将最后的二进制日志文件刷新到磁盘中，slave 也会因为读不到尚未写入磁盘的事件。 slave 意外关闭 slave 意外关闭， 会去读 master.info 文件找到上次停止复制的位置， 但是该文件并没有同步写到磁盘，存储的信息就是错的。 master 的二进制文件损坏 slave 的中继日志损坏 二进制日志与 InnoDB 事务日志不同步 数据改变，事件仍是有效的 SQL 数据改变且事件是无效的SQL 数据遗漏且事件的长度是错误的 某些事件已经损坏，或者偏移量也是错的 使用非事务型表非事务型表更新发送错误时，可能会导致 master 和 slave 的数据不一致， 例如在查询过程中被 kill。如果是使用 MyISAM 表， 关闭 MySQL 之前需要确保已经运行了 STOP SLAVE。 混合事务型和非事务型表如果混合使用了事务型和非事务型表， 发生回滚时， MySQL 会回滚事务型表的更新， 但非事务型表则被永久地更新了。此时日志会记录一条 ROLLBACK 语句到日志中， 同样的语句也会在 slave 执行。一般不要事务型表与非事务型表进行混用。除非是基于行的复制 不确定的语句基于语句的复制， 当通过不确定的方式更改数据也会导致主备不一致。 比如 LIMIT..UPDTAE 进行更新数据， 取决于查找行的顺序， 除非能保证主备库上的顺序是相同的。 主备间使用了不同的存储引擎主备使用不同的存储引擎时， 基于语句的复制可能会造成主备上执行相同的语句得到的结果不同 备库数据发送改变备库数据发送改表时， 执行：INSERT INTO tb1 SELECT * FROM tb2;会导致主备数据不一致。 不唯一的服务器 ID不小心将两台服务器设置了相同的服务器 ID， 在主库上回发现两台备库只有一台连接到了主库， 在备库的错误日志中会发现反复的重连和断开信息。 未定义的服务器 ID如果没有在 my.cnf 中定义服务器 ID， 可以通过 CHANGE MASTER TO 设置备库，但是无法启动复制， 因为没有显式的为当前服务器设置服务器 ID。 对未复制数据的依赖性避免主库上创建备库不存在的表。 丢失的临时表临时表与基于语句复制的方式是不相容的， 当备库崩溃或者正常关闭时， 复制线程用于的临时表会丢失， 而依赖于临时表的语句都会失败。 不复制索引的更新错误地使用 SET SQL_LOG_BIN = 0 或者没有理解过滤规则， 备库可能会丢失主库上已经发生的更新。 InnoDB 加锁读引起的锁竞争正常情况下， InnoDBd 读操作是非阻塞的， 但是在基于语句复制的方式下，执行 INSERT…SELECT会锁定表上的所有行。加锁会导致主库上的语句串行化， 以确保和备库上的执行方式相符。第一种缓解方法， 在主库尽快地提交事务以释放锁。另外一种替换 INSERT…SELECT语句， 在主库先执行 SELECT INTO OUTFILE, 再执行 LOAD DATA INFILE， 这种方法更快且不需要加锁 主-主模式下写入数据到两台主库之前有提到过使用 AUTO_INCREMENT 自增主键解决自增列冲突问题。但自增主键也会带来一些其他的问题: 很难再复制拓扑间做故障转移 数字之间有间隙， 会引起键空间浪费 很多时候并不会使用 AUTO_INCREMENT 作为主键 替代方法有使用 serverId 作为主键， 对 serverId 进行位运算, 可以采用 MD5()或者 UUID()等函数获取伪随机数 过大的复制延迟复制产生延迟一般有两种方式： 突然产生延迟再跟上（通常是由于一条运行很长时间的查询导致的）， 或者稳定的延迟增大。 为了避免过大的延迟， 有以下措施： 不要重复写操作中代价较高的部分 复制之外并行写入 为复制线程预取缓存 来自主库过大的包主库的 max_allowd_packet 的值与备库的值不匹配 受限制的复制带宽使用受限的带宽进行复制， 可以开启备库的 slave_compressed_protocol 选项。 磁盘空间不足当二进制日志、中继日志或临时文件将磁盘撑满，尤其是主库执行了 LOAD DATA INFILE 查询并在备库开启了 log_slave_updates。 延迟越严重，接收到尚未执行的中继日志就越多，占用的磁盘空间也越大。 可以通过监控磁盘并设置 relay_log_space 避免这种问题。 复制的局限性大量的SQL 函数和编程不能被可靠的复制（基于语句的复制), 很难确保代码中不会出现这样的问题。另一个局限性是服务器的 bug， 大多数 MySQL 都存储历史遗留的复制 bug。","categories":[{"name":"数据库","slug":"数据库","permalink":"https://coderunning.fun/categories/数据库/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://coderunning.fun/tags/MySQL/"}]},{"title":"LeetCode 92. Reverse Linked List II","slug":"leetcode/linkedlist/reverse-linked-list-ii","date":"2020-03-22T15:47:35.000Z","updated":"2020-04-24T15:03:26.680Z","comments":true,"path":"2020/03/22/leetcode/linkedlist/reverse-linked-list-ii/","link":"","permalink":"https://coderunning.fun/2020/03/22/leetcode/linkedlist/reverse-linked-list-ii/","excerpt":"Reverse a linked list from position m to n. Do it in one-pass.","text":"Reverse a linked list from position m to n. Do it in one-pass. Note: 1 ≤ m ≤ n ≤ length of list. Example: Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4 Output: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL 思路题意为给定 m、n， 翻转从第 m 到第 n 个结点。 具体分三步： 先遍历 m-1 个节点， 找到待翻转的结点为尾节点 遍历 n-m-1 次， 依次翻转 示意图 代码123456789101112131415161718192021222324public ListNode reverseBetween(ListNode head, int m, int n) &#123; ListNode dummyHead = new ListNode(-1); dummyHead.next = head; ListNode pre = dummyHead; // 先遍历 m 个结点 for (int i = 0; i &lt; m - 1; i++) &#123; pre = pre.next; &#125; // 翻转前的尾结点 ListNode tail = pre.next; ListNode temp; // 依次翻转 for (int i = 0; i &lt; n - m; i++) &#123; temp = pre.next; pre.next = tail.next; tail.next = tail.next.next; pre.next.next = temp; &#125; return dummyHead.next;&#125;","categories":[{"name":"每周一题","slug":"每周一题","permalink":"https://coderunning.fun/categories/每周一题/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://coderunning.fun/tags/leetcode/"},{"name":"linkedlist","slug":"linkedlist","permalink":"https://coderunning.fun/tags/linkedlist/"}]},{"title":"MySQL 复制概述","slug":"mysql/note8-replication-basic","date":"2020-03-21T09:12:19.000Z","updated":"2020-04-24T15:03:26.696Z","comments":true,"path":"2020/03/21/mysql/note8-replication-basic/","link":"","permalink":"https://coderunning.fun/2020/03/21/mysql/note8-replication-basic/","excerpt":"复制是构建大规模、高性能应用的基础。","text":"复制是构建大规模、高性能应用的基础。 复制可以让一台 MySQL 服务器与其他服务器保持同步， 提升集群的可用性， 避免因为一台MySQL 服务器挂掉导致整个系统不可用。 复制概述复制的类型MySQL 有两种复制方式： 基于行的复制和基于语句的复制。二者都是通过记录主库的二进制日志来进行复制。 基于语句的复制：在主服务器执行的 SQL 语句，在从服务器执行相同的语句， 基于语句的复制是mysql 默认的复制方式， 效率高。 基于行的复制：从 5.1 版本开始支持， 把改变的内容复制过去。 混合复制： 当发现基于语句的复制不能执行下去时， 转换为基于行的复制。 MySQL 的复制是向后兼容的， 新版本的服务器可以做为旧版本的服务器的备库。 复制并不会增加主库的开销， 主要是启动二进制日志带来的开销。 复制解决了什么问题MySQL 复制具有以下一些用途： 数据分布 负载均衡 备份 高可用性和故障切换 MySQL 升级测试 复制是如何工作的复制分三步： 主库 (master) 将数据的更改记录到二进制日志 (binary log）中; 备库 (slave) 从主库的日志复制到自身的中继日志 (relay log); 备库读取中继日志中的事件， 修改和主库相对应的数据。 复制配置有两台 MySQL 服务器 master 和 slave, master 为主服务器， slave 为从服务器， 初始状态时两台服务器数据相同， 当 master 服务器发生变化时， slave 也跟着发生相应的变化， 使得 master 与 slave 的数据信息同步达到备份的目的。 创建账号在 master 数据库创建一个备份账户，进行复制操作的用户被赋予 REPLICATION SLAVE 权限。 12mysql&gt; GRANT REPLICATION SLAVE,RELOAD,SUPER ON *.* TO backup@'10.26.15.167' IDENTIFIED BY '1234';Query OK, 0 rows affected (0.00 sec) 建立一个帐户backup，并且只能允许从 10.26.15.167 这个地址上来登陆，密码是1234。 拷贝数据将主库的数据拷贝到从库中去， 拷贝的过程中， 禁止在主库和从库进行写操作， 这样做的目的是为了保持两数据库中的数据一致。 设置主库、备库假设主库是 server1， 需要在主库的 my.cnf 下增加或修改相应的内容： 12log_bin = mysql-bin server_id = 10 备库的配置也需要在 my.cnf 中增加类似的配置， 配置完成后重启服务器。 12345log_bin = mysql-bin server_id = 2 relay_log = /var/lib/mysql/mysql-relay-bin # 中继日志log_slave_updates = 1read_only = 1 实际情况中， 以上的这些参数只有 server_id 是必需的。 启动slave接下来就是让 slave 连接 master，并开始重做 master 二进制日志中的事件。具体操作通过 CHANGE MASTER TO 来执行， 替代了 my.cnf 中相应的配置。 12345mysql&gt; CHANGE MASTER TO MASTER_HOST='server1',-&gt; MASTER_USER='repl',-&gt; MASTER_PASSWORD='p4ssword',-&gt; MASTER_LOG_FILE='mysql-bin.000001',-&gt; MASTER_LOG_POS=0; MASTER_LOG_POS 被置为 0 ，因为它是日志开始的地方。设置完毕后通过 SHOW SLAVE STATUS 来查看备库是否成功启动。 12345678910111213141516mysql&gt; SHOW SLAVE STATUS\\G*************************** 1. row *************************** Slave_IO_State: Master_Host: server1 Master_User: repl Master_Port: 3306 Connect_Retry: 60 Master_Log_File: mysql-bin.000001 Read_Master_Log_Pos: 4 Relay_Log_File: mysql-relay-bin.000001 Relay_Log_Pos: 4 Relay_Master_Log_File: mysql-bin.000001 Slave_IO_Running: No Slave_SQL_Running: No ...omitted... Seconds_Behind_Master: NULL 其中 Slave_IO_State，Slave_IO_Running， Slave_SQL_Running 置为 No， 表示还没有开始复制。Relay_Log_Pos 为 4 意味着日志的起始位置是 4 而不是 0， 因为 0 只是日志文件开始的位置，并不是日志位置，MySQL 知道第一个事件起始于 4。 开启复制： 1mysql&gt; START SLAVE; 现在再用 SHOW SLAVE STATUS 命令检查： 1234567891011121314151617mysql&gt; SHOW SLAVE STATUS\\G*************************** 1. row *************************** Slave_IO_State: Waiting for master to send event Master_Host: server1 Master_User: repl Master_Port: 3306 Connect_Retry: 60 Master_Log_File: mysql-bin.000001 Read_Master_Log_Pos: 164 Relay_Log_File: mysql-relay-bin.000001 Relay_Log_Pos: 164 Relay_Master_Log_File: mysql-bin.000001 Slave_IO_Running: Yes Slave_SQL_Running: Yes ...omitted... Seconds_Behind_Master: 0 可以看到 I/O 线程和 SQL 线程已经开始运行。Seconds_Behind_Master 也不再为 NULL, 日志的位置也发生了变化。 查看下线程列表中的复制线程， 在主库可以看到由备库 I/O 线程向主库发起的连接。 123456789101112131415161718192021mysql&gt; show processlist \\G*************************** 1. row *************************** Id: 1 User: root Host: localhost:2096 db: testCommand: Query Time: 0 State: NULL Info: show processlist*************************** 2. row *************************** Id: 2 User: repl Host: localhost:2144 db: NULLCommand: Binlog Dump Time: 1838 State: Has sent all binlog to slave; waiting for binlog to be updated Info: NULL2 rows in set (0.00 sec) 在slave服务器上运行该语句， 其中行 1是 I/O 线程， 行 2 是 SQL 线程 12345678910111213141516171819202122232425262728293031mysql&gt; show processlist \\G*************************** 1. row *************************** Id: 1 User: system user Host: db: NULLCommand: Connect Time: 2291 State: Waiting for master to send event Info: NULL*************************** 2. row *************************** Id: 2 User: system user Host: db: NULLCommand: Connect Time: 1852 State: Has read all relay log; waiting for the slave I/O thread to update it Info: NULL*************************** 3. row *************************** Id: 5 User: root Host: localhost:2152 db: testCommand: Query Time: 0 State: NULL Info: show processlist3 rows in set (0.00 sec) 增加新的 SLAVE 服务器前面讲到的例子是主备两台服务器的数据相同， 并且知道当前主库的二进制日志。 但是大多数情况下是有一个已经运行了一段时间的主库， 然后用新安装的备库与之同步， 此时备库还没有数据。 有几种方法来初始化备库或者从其他服务器克隆数据到备库。 包括从主库复制数据、从另一台备库克隆数据， 以及使用最近的一次备份启动备库。 需要三个条件让主库、备库保持一致： master 某个时间点的数据快照。 master 当前的二进制日志文件， 和获得数据快照时在该二进制日志文件中的偏移量， 通过这两个值可以确定二进制日志的位置。 master从快照时间到现在的二进制日志。 可以通过以下几种方法从 master 克隆到 slave： 冷拷贝(cold copy)关闭master， 将数据复制到 slave， 复制完毕后重启 master。 缺点： 复制时需要关闭 master。 热拷贝(warm copy)仅限于 MyISAM表， 可以在 master 运行时使用 mysqlhotcopy 或 rsync 来复制数据。 使用mysqldump 锁表， 避免其他连接修改数据库。 否则会造成数据不一致的问题 mysql&gt; FLUSH TABLES WITH READ LOCK; 在另一个连接使用 mysqldum 创建一个你想进行复制的数据库的存储：shell&gt; mysqldump –all-databases –lock-all-tables &gt;dbdump.db 对表释放锁 复制的原理之前介绍的是一些复制的基本概念， 接下来深入地了解复制， 看看复制是如何工作的， 有哪些优缺点。 基于语句的复制MySQL5.0 及之前更老的版本是只支持基于语句的复制（逻辑复制）。 在基于语句的复制模式下， 主库会记录那些造成数据更改的查询， 当备库读取并重放这些事件时， 实际上是把主库执行过的语句再执行一遍。 基于语句的复制十分简单，理论上将简单地记录和执行这些语句即可让主备保持同步， 另一个好处是二进制日志更加紧凑， 所以基于语句的复制不会占用太多的带宽。 但是在基于语句复制的过程中还依赖于其他的元素，比如当前的时间戳，除此之外还存在一些无法被正确复制的SQL， 例如使用 CURRENT_USER()函数的语句； 另一个问题是更新必须是串行的，需要更多的锁。 基于行的复制MySQL5.1 开始支持基于行的复制， 这种方式会将实际数据记录在二进制日志中。 优点是任何语句都可以正确的工作， 一些语句的效率更高。 缺点是二进制文件可能很大而且不直观。 对于一些语句，基于行的复制能够更有效的工作，如： 1234mysql&gt; INSERT INTO summary_table(col1, col2, sum_col3) -&gt; SELECT col1, col2, sum(col3) -&gt; FROM enormous_table -&gt; GROUP BY col1, col2; 假设，只有三种唯一的col1和col2的组合，但是，该查询会扫描原表的许多行，却仅返回三条记录。此时，基于行的复制效率更高。 另一方面，下面的语句，基于语句的复制更有效： 1mysql&gt; UPDATE enormous_table SET col1 = 0; 此时使用基于行的复制代价会非常高。由于两种方式不能对所有情况都能很好的处理，所以，MySQL 5.1支持在基于语句的复制和基于记录的复制之前动态交换。你可以通过设置session变量binlog_format来进行控制。 基于语句复制与基于行复制的优缺点 优点 缺点 基于语句的复制模式 基于语句的复制更灵活， 哪怕是主备表不同单类型能够兼容或者是列不同等， 而且基于语句出现问题容易排查 对触发器和存储过程不友好， 有很多 bug 基于行的复制模式 SQL 构造器、触发器、存储过程都能正确执行，应用广阔。不需要太多的锁。占用更少的 CPU 无法判断执行了哪些SQL， 出现问题难以排查 复制文件复制中除了二进制日志和中继日志文件呢， 还用到了以下的一些文件： mysql-bin.index： 当在服务器开启二进制日志时， 同时会生成一个和二进制日志同名但以.index 为后缀的文件，它用来定位磁盘上的二进制日志文件。 mysql-relay-bin-index： 中继日志的索引文件， 和mysql-bin.index 的作用类似。 master.info: 保存 master 库的信息， 不能删除， 否则 slave 无法连接到 master。 relay-log.info： 包含当前备库复制的二进制日志和中继日志坐标， 同样不能删除， 否则无法获知从哪个位置开始复制。 发送复制事件到其他 slave当开启 log_slave_updates 选项可以让 slave 变成其他服务器的master。 slave 把执行过的事件记录在自己的二进制日志中， 它的slave 就可以从日志中检索并执行事件 复制过滤器复制过滤器可以让你只复制一部分数据， 有两种复制过滤：master 上过滤记录到二进制日志文件的事件， slave 上过滤记录到中继日志的事件。 复制的常见拓扑结构复制体系结构有以下一些基本原则： 一个 MySQL slave 实例只能有一个 master。 每个 slave 必须有一个唯一的 server id。 一个 master 可以有多个 slave 如果打开了 log_slave_updates 选项， 一个 slave 可以将主库的数据变化传播给其他的 slave。 一个 master 多个 slave一主多备是最简单的拓扑结构， slave 之间没有交互。当少量写大量读时这种结构非常有用， 将读操作分摊到多个 slave， 从而减小 master 的压力。但是当 slave 增加到一定程度时， slave 对 master 的负载以及网络带宽都会成为性能瓶颈。 这种结构虽然简单， 但是很灵活， 足以满足大多数需求， 一些建议： 不同的 slave 起到不同的作用（使用不同的索引或者不同的存储引擎）。 用一个 slave 当做代用的 master， 只进行复制。 用一个远程 slave， 作为灾备 主动-主动模式下的 Master-Master 复制Master-Master 复制的两台服务器，既是 master，又是另一台服务器的 slave。任何一方的变更都会同步给另一方。 master-master 模式带来的最大问题是如何解决冲突， 如果两台服务器同时修改一条记录。 在 MySQL5.0 之后通过 auto_increment_inrement 和auto_increment_offset， 可以让 MySQL 自动为 INSERT 语句选择不互相冲突的值， 但这仅仅解决了同时想一个包含 AUTO_INCREMENT 列的表插入数据造成的冲突。在两台主库上同时写入数据还是很危险， 假设同时执行下面的两条语句： 第一台 master 上： msyql&gt; UPDATE tbl SET col = col + 1; 第二台 master 上： msyql&gt; UPDATE tbl SET col = col * 2; 结果可能是一台服务器上值为 4， 一台服务器上值为 3， 而且没有报任何错误。所以这种模式很少使用。 主动-被动模式下的 Master-Master 复制这是master-master结构变化而来的，它避免了M-M的缺点，实际上，这是一种具有容错和高可用性的系统。它的不同点在于其中一个服务只能进行只读操作。如图： 这种拓扑结构使得反复切换主动和被动服务器很方便， 可以应用在故障转移和故障恢复中。 用于备库的主-主结构(Master-Master with Slaves) 这种配置的有点事增加了冗余， 对于不同地理位置的复制拓扑， 能够献出单点失效的问题， 同样的， 查询还是分配在 slave 上。","categories":[{"name":"数据库","slug":"数据库","permalink":"https://coderunning.fun/categories/数据库/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://coderunning.fun/tags/MySQL/"}]},{"title":"桥接模式","slug":"design-pattern/桥接模式","date":"2020-03-15T15:18:59.000Z","updated":"2020-04-24T15:03:26.665Z","comments":true,"path":"2020/03/15/design-pattern/桥接模式/","link":"","permalink":"https://coderunning.fun/2020/03/15/design-pattern/桥接模式/","excerpt":"当前有一个需求，既需要画出三角形、正方形， 同时还需要对它们上不同的颜色， 你会采取什么样的设计?","text":"当前有一个需求，既需要画出三角形、正方形， 同时还需要对它们上不同的颜色， 你会采取什么样的设计? 什么是桥接模式桥接模式(Bridge Pattern)是结构型模式的一种。提供抽象化与实现化之间的桥接，将抽象与实现解耦，使得二者可以独立变化的一种设计模式。 桥接模式组成 Abstraction: 抽象类，拥有一个 Implementor 类型的对象引用 RefinedAbstraction: 扩充抽象类，扩展 Abstraction 的接口定义 Implementor: 实现类接口 ConcreteImplementor: 具体实现类，实现 Implementor 接口，给出具体实现 桥接模式UML 为什么使用桥接模式还是拿画图来举例子， 现在不仅需要画出圆形、正方形、三角形， 还需要对不同的形状上色，如红、绿、蓝色等。 此时有两种方案： 第一种设计方案为每种图形都提供一套各种颜色的版本 第二种根据实际对需要的形状和颜色组合 方案一很容易让大家想到工厂模式， 但是工厂模式的抽象产品中加入颜色的定义不仅带来了耦合， 还会带来类爆炸的问题， 如果新增一种颜色， 对继承的类不是很友好。方案二则是桥接模式应用，将继承关系转化为组合关联关系，降低了类与类间的耦合，同时也减少了代码量。 用代码示例， 现在的需求是画出圆、正方形 12345678910111213141516171819202122232425public abstract class Shape &#123; public abstract void draw();&#125;public class Circle extends Shape &#123; public void draw() &#123; System.out.println(\"draw a circle\"); &#125;&#125;public class Recntangle extends Shape &#123; public void draw() &#123; System.out.println(\"draw a recntangle\"); &#125;&#125;// 调用public class Client &#123; public static void main(String[] args) &#123; Shape circle = new Circle(); circle.draw(); Shape rectangle = new Rectangle(); rectangle.draw(); &#125;&#125; 现在需求变更， 想要对图形上色， 分别有红、绿、蓝三种颜色 1234567891011121314151617public class RedCircle extends Shape &#123; public void draw() &#123; System.out.println(\"draw a red circle\"); &#125;&#125;public class GreenCircle extends Shape &#123; public void draw() &#123; System.out.println(\"draw a red circle\"); &#125;&#125;public class BlueCircle extends Shape &#123; public void draw() &#123; System.out.println(\"draw a red circle\"); &#125;&#125;//......省略 按上面的做法，Recntangle 也需要实现三个类， 2*3 = 6 现在需要维护六个类， 保不齐哪天再发生变化，维护的类实在是太多了。接下来看下采用桥接模式如何来做 桥接模式的示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// 首先是实现类接口public interface DrawApi &#123; void drawWithColor();&#125;// 抽象类public abstract class Shape &#123; public abstract void draw(); public DrawApi drawApi; public Shape(DrawApi drawApi) &#123; this.drawApi = drawApi; &#125;&#125;// 具体实现类， 分别为Circle 与 Recntangle 类public class Circle extends Shape &#123; public Circle(DrawApi drawApi) &#123; super(drawApi); &#125; @Override public void draw() &#123; drawApi.drawWithColor(); &#125;&#125;public class Rectangle extends Shape &#123; public Rectangle(DrawApi drawApi) &#123; super(drawApi); &#125; @Override public void draw() &#123; drawApi.drawWithColor(); &#125;&#125;// 接口实现类， 为具体形状上色public class GreenCircle implements DrawApi &#123; @Override public void drawWithColor() &#123; System.out.println(\"draw a green circle\"); &#125;&#125;public class RedRectangle implements DrawApi &#123; @Override public void drawWithColor() &#123; System.out.println(\"draw a red rectangle\"); &#125;&#125;// 调用public class BridgePatternClient &#123; public static void main(String[] args) &#123; Shape readCircle = new Circle(new GreenCircle()); readCircle.draw(); Shape redRectangle = new Rectangle(new RedRectangle()); redRctangle.draw(); &#125;&#125; 输出： draw a green circle draw a red rectangle 可以看到采用桥接模式后， 维护的类大大减少， 而且还可以将画图与上色两个功能分离开。 桥接模式的特点优点： 分离抽象接口及其实现部分, Client 和 Abstraction 交互, 不暴露 Implementation 的细节.； 桥接模式有时类似于多继承方案，但是多继承方案违背了类的单一职责原则（即一个类只有一个变化的原因），桥接模式是比多继承方案更好的解决方法； 桥接模式提升了系统的可扩展性，扩展一个新的特性不需要修改原有系统，符合“开闭原则； 缺点： 桥接模式的引入增加了系统的设计难度，不易理解， 由于聚合关系建立在抽象层， 要求对抽象进行设计； 桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围具有一定的局限性，如何正确识别两个独立维度也需要一定的经验积累。 桥接模式的应用JDK中的桥接模式JDBC：JDBC连接数据库的时候，在各个数据库之间进行切换，基本不需要动太多的代码，甚至丝毫不动，原因就是JDBC提供了统一接Connection，每个数据库提供各自的实现，用一个叫做数据库驱动的程序来桥接就行了。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://coderunning.fun/categories/设计模式/"}],"tags":[{"name":"结构型模式","slug":"结构型模式","permalink":"https://coderunning.fun/tags/结构型模式/"}]},{"title":"MySQL 优化器与特定类型优化","slug":"mysql/note7-query-optimize2","date":"2020-03-12T14:46:32.000Z","updated":"2020-04-24T15:03:26.696Z","comments":true,"path":"2020/03/12/mysql/note7-query-optimize2/","link":"","permalink":"https://coderunning.fun/2020/03/12/mysql/note7-query-optimize2/","excerpt":"优化器存在哪些问题？ 日常的查询需要注意哪些点？","text":"优化器存在哪些问题？ 日常的查询需要注意哪些点？ 查询优化器存在的问题关联子查询常见的一种查询， 希望找到 Sakila 数据库中， 演员 PG(actor_id = 1) 所参演的影片信息, 一般来讲我们都会以下面的方式完成子查询： 123mysql&gt; SELECT * FROM sakila.film-&gt; WHERE film_id IN(-&gt; SELECT film_id FROM sakila.film_actor WHERE actor_id = 1); 大多数情况下我们都会以为上面的语句执行时会按照下面的顺序执行： 12345-- SELECT GROUP_CONCAT(film_id) FROM sakila.film_actor WHERE actor_id = 1;-- Result: 1,23,25,106,140,166,277,361,438,499,506,509,605,635,749,832,939,970,980 SELECT * FROM sakila.filmWHERE film_id IN(1,23,25,106,140,166,277,361,438,499,506,509,605,635,749,832,939,970,980); 但是时间情况却是MySQL 会先全表扫描 film 表， 然后进行子查询，依次比对 film 表中的 film_id 与 file_actor 表中 actor_id = 1的 film_id， sql 在执行时将会改写成以下语句： 1234SELECT * FROM sakila.film WHERE EXISTS ( SELECT * FROM sakila.film_actor WHERE actor_id = 1 AND film_actor.film_id = film.film_id); 如果外层的表 film 数据量并不是很大的时候， 对性能的影响不会引起注意， 如果外层的表很大， 这个查询的性能就会很糟糕， 常见的一个优化的方式为： 123mysql&gt; SELECT film.* FROM sakila.film-&gt; INNER JOIN sakila.film_actor USING(film_id) -&gt; WHERE actor_id = 1; 至于使用子查询还是内/外连接， 需要看具体的执行计划， 并不一定说内/外连接的性能一定比子查询好。 UNION 限制UNION 的限制条件只对已联合的数据生效， 如果想得到更好的性能则需要在联合前就对数据做出限制： 比如, actor 有 200 条数据， customer 有 599 条数据，按 last_name 合并后， 会生成一张含有 799 条数据的临时表， 然后再从临时表去除 20 条数据： 123456(SELECT first_name, last_name FROM sakila.actorORDER BY last_name)UNION ALL(SELECT first_name, last_nameFROM sakila.customerORDER BY last_name) LIMIT 20; 数据量很大时， 临时表可能会很大， 可以在 UNION 的子查询中加上 LIMIT 来减少临时表的数据： 1234567(SELECT first_name, last_name FROM sakila.actorORDER BY last_nameLIMIT 20)UNION ALL(SELECT first_name, last_nameFROM sakila.customer ORDER BY last_name LIMIT 20)LIMIT 20; 索引合并优化当查询语句中有 OR 时, 会求并集。查询SELECT * FROM TB1 WHERE c1=”xxx” OR c2=””xxx”时，如果c1和c2列上分别有索引，可以按照c1和c2条件进行查询，再将查询结果合并（union）操作。 当查询语句中有 OR 时, 会求交集。如查询SELECT * FROM TB1 WHERE c1=”xxx” AND c2=””xxx”时，如果c1和c2列上分别有索引，可以按照c1和c2条件进行查询，再将查询结果取交集（intersect）操作。 索引索引合并的性能并不及复合索引。 等值传递非常大的 IN()列表 MySQL 优化器会将这个列表的值与另一个表做关联，类似于子查询是对 IN 语句的改写。 哈希关联MySQL 的查询都是嵌套循环查询， 不支持哈希关联。 松散索引扫描MySQL 的索引扫描需要指定起点和终点。假设有索引 key(a,b), 如何查询的语句中只要字段 b， MySQL 是无法使用这个索引的， 只能通过全表扫描查找数据。 而松散索引是先扫描 a 列对应的 b 列的范围，再跳到 a 列第二个不同值扫描对应 b 列的范围。更好的做法是为 b 增加一个索引，但是也会遇到第一列为范围查询， 第二列为等值查询的情况。 最大最小值优化1SELECT MIN(actor_id) FROM sakila.actor WHERE first_name = 'PENELOPE'; first_name 没有索引时， 会进行全表扫描。 当进行主键扫描时（actor_id）为主键， 读到的第一行记录就是最小值。此时采用 LIMIT 将查询重写： 12mysql&gt; SELECT actor_id FROM sakila.actor USE INDEX(PRIMARY) -&gt; WHERE first_name = 'PENELOPE' LIMIT 1; 虽然进行了优化， 但是会让人产生迷惑，不知到这个 sql 语句想表达什么。 同一个表的查询与更新MySQL 不允许对同一张表同时进行查询和更新。 优化特定的类型优化 COUNT()COUNT()函数有两个作用： 统计某个列值的数量。 统计列值时要求列值是非空的（NOT NULL）或者表达式的值补不为NULL。 统计结果集的行数。COUNT(*）时， * 并不会扩展成所有列，而是直接统计行数。 MyISAM count()的速度很快是因为前提条件是没有任何WERE条件的COUNT()。技巧1： 查询一个很多行时， 反向查询SELECT (SELECT COUNT() FROM CITY ) - COUNT(*) FROM CITY WHERE id &lt;= 5; 可以迅速查的id大于5的城市技巧2：COUNT 替代SUMSELECT COUNT(color = ‘blue’ OR NULL) as blue, COUNT(color = ‘red’ OR NULL) as red FR0M ITEMS; 优化关联查询 当表 A 与表 B 关联是， 只需要在关联顺序的第二张表相应列创建索引即可 GROUP BY 和 ORDER BY 只涉及到一个表的列才能使 MySQL 索引生效 优化子查询子查询尽量使用关联来代替， “尽可能地使用关联”，但不一定正确。 优化 GROUP BY无法使用索引时， GROUP BY 使用临时表或者文件排序来实现分组 优化 LIMIT分页LIMIT 分页时需要留意偏移量， 特别是偏移量非常大的时候， 例如 LIMIT 1000, 20, 只返回了最后20条数据， 前面的 1000 条被丢弃。采用延迟关联, 获取需要访问的数据后再根据关联列会原表查询所需要的列 1234567SELECT film_id, description FROM film ORDER BY title LIMIT 50, 5;改写成：SELECT film_id, description FROM film INNER JOIN( SELECT film_id FROM film ORDER BY title LIMIT 50, 5 ) AS lim UNSING(film_id); 或者将 LIMIT 查询转换成已知位置查询SELECT film_id, description FROM film WHERE position； BETWEEN 50 AND 54 ORDER BY position； OFFSET 在使用时可以记录上一次查询的位置配合 LIMIT 使用 123SELECT * FROM rental WHERE ORDER BY rental_id DESC LIMIT 16049, 20;SELECT * FROM rental WHERE rental_id &lt; 16030 ORDER BY rental_id DESC LIMIT 20; 优化 UNIONUNION在使用时要注意是否是UNION ALL， 否则在查询时还需要对临时表去重 使用自定义变量使用自定义变量需要注意： 使用自定义变量时， 无法查询缓存； 不能在使用常量、标识符的地方使用自定义变量，例如表名、列名、LIMIT 子句中； 用户的自定义变量只在一个session中有效， 不能做为连接间的通信； 不能显示声明自定义变量的类型；赋值为0默认为整形， 0.0为浮点型， ‘’为字符串； 赋值符号 := 的优先级非常低； 自定义变量不会产生语法错误。","categories":[{"name":"数据库","slug":"数据库","permalink":"https://coderunning.fun/categories/数据库/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://coderunning.fun/tags/MySQL/"}]},{"title":"MySQL 查询过程及优化","slug":"mysql/note6-query-optimize","date":"2020-03-08T08:29:26.000Z","updated":"2020-04-24T15:03:26.695Z","comments":true,"path":"2020/03/08/mysql/note6-query-optimize/","link":"","permalink":"https://coderunning.fun/2020/03/08/mysql/note6-query-optimize/","excerpt":"MySQL 查询过程一共分几步？","text":"MySQL 查询过程一共分几步？ MySQL 查询基础查询过程分为以下五步： 客户端发送查询指令给服务器 服务器先查询缓存， 如果命中缓存立刻返回缓存中的结果。否则下一阶段 服务器对查询语句进行 SQL 解析、预处理， 再由优化器生成响应的执行计划 MySQL 根据优化器生成执行计划， 调用存储引擎层的 api 来执行查询 将查询结果返回给客户端 客户端/服务端间的通信协议客户端与服务端之间是“半双工”， 一端发送数据时，另一端只能接收。 一般来说服务端返回的数据很大， 客户端完整的接收数据需要花费很长的时间， 所以必要的时候需要对查询增加 LIMIT 限制。 查询缓存在解析 sql 语句之前， 如果缓存是打开的， MySQL 会优先检查是否命中缓存中的数据， 如果命中了数据， 返回结果前还要验证一次用户权限， 权限没有问题会直接返回缓存中查得的数据。 查询优化处理查询优化包含多个子阶段： 解析 sql， 预处理， 优化 sql 执行计划。 语法解析器与预处理MySQL 通过关键字对 SQL 语句进行解析， 生成一颗解析树。在这一步解析器将验证关键字是否正确， 关键字的顺序是否正确， 还会验证引号是否前后正确匹配。 查询优化器此时语法树是合法的，优化器会将其转化成执行计划， 一条语句可能由多种执行方式，优化器的作用就是找到其中最好的的执行计划。 查询优化可以简单分为两种：静态优化和动态优化。 静态优化对解析树进行分析，例如通过简单的代数变换将 WHERE 条件转换成另一种形式，第一次完成后一直有效， 不受参数变化的影响； 动态优化与查询的上下文有关， 比如 WHERE 条件的取值、索引中条目对应的数据行等， 每次查询都需重新评估。 以下是 MySQL 可以优化的类型： 重新定义关联表的顺序 将外连接转化成内链接 使用等价变换原则 优化 COUNT(), MAX(), MIN() 预估并转化为常数表达式 覆盖索引扫描 子查询优化 提前终止查询 等值传播 列表 IN() 的比较 数据和索引的统计信息大多数情况下，数据和索引的统计信息都在存储引擎层维护。 关联查询MySQL 关联 查询时先将子查询的结果放到一个临时表中， 将临时表也当做一个普通表对待。MySQL 先将一系列的查询结果放到一个临时表中，然后再嵌套循环到下一个表中寻找匹配的行， 直到找到所有的匹配行为止。 执行计划MySQL 的执行计划从一个表开始嵌套循环、回溯完成所有表的关联。 关联查询优化器关联优化查询器通过评估不同顺序的成本选择一个代价最小的关联顺序。 排序优化当不能只有索引生成的排序结果时， MySQL 需要自己进行排序。如果数据量小可以在内存中排序， 数据量大时在磁盘中排序， 两种情况统称为文件排序(file sort)， 有以下2种排序规则： 两次传输排序： 需要读取两次数据表， 成本高， 旧版本使用 单次传输排序： 先从数据表读取所有列， 再排序， 直接返回排序结果 file sort 带来的问题是有可能排序产生的临时表比磁盘的原有文件还要大， 所以查看EXPLAIN 时如果出现 “Using temporary; Using filesort”时需要留意。 查询执行引擎在解析和优化阶段， MySQL 将生成查询对应的执行计划。 查询过程中每个表对应一个 handler， 存储引擎提供查询的接口供优化器使用， 这些接口包含获取表的相关信息， 表的列名、索引统计信息等。 返回结果给客户端如果查询的结果可以被缓存， MySQL 会将查得的结果缓存起来。 MySQL 返回结果的过程并不是一次将所有结果返回， 而是一个逐步的过程， 以关联表为例， 处理器在处理完最后一个关联表生成第一条结果时就开始向客户端返回数据了。 这样服务单无需存储太多的结果，也不会因为返回太多结果而占销毁太多内存。 要想查询速度快不要做哪些查询了不需要的数据查询了不需要的数据可以在查询条件中新增 LIMIT ， 返回自己需要的条数。 多表关联时返回全部的列1234SELECT * FROM AINNER JOIN B INNER JOIN CWHERE XXX; 这样的操作会返回 A、B、C 的全部列。 正确的做法是只取需要的列： 1234SELECT A.* FROM AINNER JOIN B INNER JOIN CWHERE XXX; 总是取出全部列禁止使用 SELECT * 。 使用 SELECT * 查询会带来额外的 I/O、内存和 CPU 的消耗。 重复查询相同的数据如果重复执行相同的查询， 并总是返回完全相同的数据。 对这些很少发生变化的数据， 将它缓存起来。 是否扫描了额外的记录衡量指标： 响应时间： 服务时间 + 阻塞时间 服务时间指的是数据库处理查询花费的时间； 阻塞时间指的是服务器在等待资源过程中花的时间， I/O 操作、行锁等 扫描的行数 理想情况下扫描的行数应该和返回的行数相同。 扫描的类型 访问的类型有： 全表扫描(ALL)、索引扫描(ref)、范围扫描(range)、唯一索引(unique)、常数引用(const)。 速度依次由慢到快 MySQL 会在以下三种情况使用 WHERE 条件： 在索引中使用 WHERE 条件过滤不匹配的记录， 属于存储引擎层的操作； 索引覆盖扫描（无需回表)返回记录， 从索引中过滤不需要的记录并返回名字的结果， 属于服务器层操作； 从数据表中返回数据， 过滤不满足条件的记录。 如果发现查询需要扫描大量的数据但只返回了少数的行， 可以尝试以下操作优化： 使用索引覆盖扫描， 无需回表； 改变库表结果， 使用单独的汇总表； 重写复杂的查询， 让 MySQL 更优地处理。 重构查询方式以提升查询效率将查询进行转换， 可以使得返回同样的结果，但是速度更快。 使用一个复杂查询还是多个简单查询MySQL 的连接和端口的开销很小， 所以对 MySQL 来说网络通信、查询解析和优化的成本比以前小了很多。 有必要时将浮躁查询分解成多个查询。 切分查询将一个大查询切分成小查询， 每个小查询只完成一小部分， 返回一小部分结果。 批量删除旧数据， 每次限制 10000 条数据。 拆分关联查询对关联查询进行分解， 将分解得到的数据在应用层或者说在内存中进行处理。 123456789SELECT * FROM tag JOIN tag_post on tag_post.tag_id = tag.id JOIN post on tag_post.post_id = post.idwhere tag.tag = 'mysql';-- 分解成如下：SELECT * FROM tag WHERE tag = 'mysql';SELECT * FROM tag_post WHERE tag_id= 1234;SELECT * FROM post WHERE post_id in (123, 456, 789, 0992)'; 这样做的好处是： 让缓存效率更高。分解后的语句查询的结果更容易被缓存， 而联表查询的零时表缓存的命中率并不高？（因为关联的一张表发生变化就会导致缓存失效）； 查询分解， 减少锁竞争； 应用层关联， 利于数据库的拆分， 扩展性更高； 查询效率更高， 使用 in 操作可以让查询按 ID 顺序查询。","categories":[{"name":"数据库","slug":"数据库","permalink":"https://coderunning.fun/categories/数据库/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://coderunning.fun/tags/MySQL/"}]},{"title":"聚簇索引、二级索引与覆盖索引","slug":"mysql/note5-cluster-index","date":"2020-03-04T13:08:29.000Z","updated":"2020-04-24T15:03:26.692Z","comments":true,"path":"2020/03/04/mysql/note5-cluster-index/","link":"","permalink":"https://coderunning.fun/2020/03/04/mysql/note5-cluster-index/","excerpt":"聚簇索引到底是什么索引？ 覆盖索引又是怎么回事？","text":"聚簇索引到底是什么索引？ 覆盖索引又是怎么回事？ 聚簇索引定义： 聚簇索引并不是一种新数据结构， 而是 B-Tree 索引的一种存储方式，保存的是 B-Tree 索引和数据行。在 InnoDB 引擎下， 聚簇索引与主键索引是等价的。 当数据表定义主键时，InnoDB 使用主键做为聚簇索引； 如果表中未定义主键， MySQL 会自动选择第一个唯一索引 (UNIQUE INDEX)、且所在列 NOT NULL 时作为聚簇索引； 如果表中即未定义主键， 也没有合适的唯一索引， InnoDB会隐式地创建一个名为 GEN_CLUST_INDEX 的索引作为聚簇索引， 该索引包含了 6 个字节的 row id 聚簇索引结构如下， 同时也是 B+Tree 索引 特性： 数据行的逻辑顺序与聚簇索引的顺序一致，B+树中叶子结点以链表的形式串联的，叶子节点中数据行的逻辑顺序只有一种，所以一张表只能有一个聚簇索引。 叶子结点包含了数据行的完整数据，非叶子节点只包含索引列数据。 通过聚簇索引，能够更快地找到数据所在的页，如果表中数据很多，能够有效节省磁盘 IO 次数。 二级索引（非聚簇索引）InnoDB 中除过主键索引， 其余的统称为二级索引，二级索引会在叶子节点保存主键。当通过二级索引进行查找时， 二级索引会通过叶子结点找到主键， 然后再根据主键找到数据所在的行， 这样做的好处是减少了数据行移动和页分裂时二级索引的维护工作, 但是通过二级索引查找数据时相当于利用了两个 B 树, 要解决这种问题需要引入覆盖索引， 覆盖索引接下来我们会讲到。 在实际的查找过程如下： 以 Tom 为例， 在二级索引key(b, c)中， 先找到 b = 22 and c = tom 的行， 同时得到row id = 30， 根据 row id 回到主键索引， 就能找到 row id = 30 的所有数据。 聚簇索引的优缺点优点： 聚簇索引将索引与数据行保存在同一个 B-Tree 中， 查询通过聚簇索引就能够直接得到数据，而非聚簇索引则需要多次 IO， 所以聚簇索引的查询速度比非聚簇索引的速度更快； 聚簇索引对主键的范围查询效率很高， 因为聚簇索引的数据是按主键排列的； 覆盖索引扫描的查询可以直接使用页节点中的主键值。 缺点： 聚簇索引的优势在于减少 IO， 如果查询的数据都在内存中那么对访问顺序就没那么重要了； 插入的速度严重依赖于插入的顺序，按主键的顺序插入是最快的，否则会出现页分裂这种情况。对于 InnoDB 引擎的表都会定义一个自增 id； 聚簇索引在更新和插入新的数据时，可能会导致页分裂的问题：当插入的已满的叶子节点时，B+树会分裂成两个页来容纳新增的数据。页分裂会导致表占用更多的磁盘空间； 聚簇索引会导致全表扫描变慢，尤其是行比较稀疏，或者由于页分裂导致数据存储不连续的时候（所以不要使用 uuid 作为主键）。 二级索引（非聚簇索引）可能比想象的要更大，因为在二级索引的叶子节点包含了引用行的主键列。 覆盖索引定义： 覆盖索引（covering index）指一个查询语句的执行只用从索引中就能够取得，不必从数据表中读取。也称之为索引覆盖。举个例子, 此时 tb_user 中只有主键索引： 1234567891011121314151617-- 添加覆盖索引前mysql&gt; select count(name) from tb_user where name like 'jSMfqpA%';+-------------+| count(name) |+-------------+| 2 |+-------------+1 row in set (0.15 sec) # 耗时 0.15 秒-- 新增索引mysql&gt; create index idx_tb_user_name on tb_user(name);+----------+------------+--------------------------------------------------------------+| Query_ID | Duration | Query |+----------+------------+--------------------------------------------------------------+| 10 | 0.00029900 | select count(name) from tb_user where name like 'jSMfqpA%' |+----------+------------+--------------------------------------------------------------+ name 字段新增索引后耗时 0.29 毫秒， 与之前无索引时性能差了近千倍。 对比下同样是有索引的字段， 但不是覆盖索引的查询： 12345+----------+------------+--------------------------------------------------------------------+| Query_ID | Duration | Query |+----------+------------+--------------------------------------------------------------------+| 16 | 0.00863500 | select count(name) from tb_user where birth &gt; '2020-01-01' |+----------+------------+--------------------------------------------------------------------+ 可以看到同样是索引的字段， 覆盖索引查询与非覆盖索引的查询也相差一个量级， 索引与非索引的查询性能更是相差千倍。 1234567891011121314151617181920212223242526272829303132mysql&gt; explain select count(name) from tb_user where name like 'jSMfqpA%' \\G;*************************** 1. row *************************** id: 1 select_type: SIMPLE table: tb_user partitions: NULL type: rangepossible_keys: idx_tb_user_name key: idx_tb_user_name key_len: 13 ref: NULL rows: 2 filtered: 100.00 Extra: Using where; Using index # 使用到索引查询且未覆盖索引1 row in set, 1 warning (0.00 sec)mysql&gt; explain select count(name) from tb_user where birth &gt; '2020-01-01' \\G;*************************** 1. row *************************** id: 1 select_type: SIMPLE table: tb_user partitions: NULL type: rangepossible_keys: idx_tb_user_birth key: idx_tb_user_birth key_len: 4 ref: NULL rows: 2962 filtered: 100.00 Extra: Using index condition # 使用到索引查询，但非覆盖索引1 row in set, 1 warning (0.00 sec) 总结： 当一条查询语句符合覆盖索引条件时，MySQL 只需要通过索引就可以返回查询所需要的数据，这样避免了查到索引后再回表查询，减少I/O提高效率。 InnoDB使用聚集索引存储数据，如果二级索引中包含查询所需的数据，就不再需要在聚集索引中查找了。","categories":[{"name":"数据库","slug":"数据库","permalink":"https://coderunning.fun/categories/数据库/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://coderunning.fun/tags/MySQL/"}]},{"title":"B-Tree 索引实践","slug":"mysql/note4-btree-practice","date":"2020-02-29T10:20:42.000Z","updated":"2020-04-24T15:03:26.692Z","comments":true,"path":"2020/02/29/mysql/note4-btree-practice/","link":"","permalink":"https://coderunning.fun/2020/02/29/mysql/note4-btree-practice/","excerpt":"看下 B-Tree 索引在实际的数据查询中起到了什么作用。","text":"看下 B-Tree 索引在实际的数据查询中起到了什么作用。 准备测试数据新建表12345create table tb_user( id int auto_increment primary key, name varchar(10), birth date); 利用存储过程造数据存储过程可以理解为 MySQL 的一个函数， 调用存储过程就可以执行函数中相应的操作； 在创建存储过程之前需要对 “,” 特殊处理下， 因为MySQL 将 “,” 作为一条语句的终结符号，为了是创建的存储过程中的 “,” 生效， 需要提前使用 delimiter 将终结符 “,” 替换成其他符号。 比如使用 delimiter $$， 就将 “,” 替换成了 $$。 创建生成随机字符串与随机数生成的方法： 1234567891011121314151617181920212223delimiter $$# 生成随机字符串create function rand_str(n int) returns varchar(10)begin declare CHARS char(52) default 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'; declare result varchar(255) default ''; declare i int default 1; while i &lt; n do set result = concat(result, substr(CHARS, floor(1 + RAND()*52), 1)); set i = i + 1; end while; return result;end$$# 生成随机数(i &lt;= R &lt; j)create function rand_num(i int, j int) returns intbegin return floor(i + rand() * (j - i));end$$delimiter ; 创建测试数据生成的存储过程： 12345678910111213141516delimiter $$create procedure insert_tb_user(c int)begin declare start_date int default TO_DAYS(STR_TO_DATE('1970-01-1','%Y-%m-%e')); declare end_date int default TO_DAYS(CURDATE()); declare i int default 0; set autocommit = 0; repeat set i = i + 1; insert into tb_user(name, birth) values(rand_str(10), FROM_DAYS(rand_num(start_date, end_date))); until i = c end repeat; set autocommit = 1;end$$delimiter ; 调用存储过程生成一百万条随机数据： 1call insert_tb_user(1000000); 可能需要几分钟的时间，我的电脑上生成一百万条数据花费 286 秒。 使用主键查询为了能更细致地看到每条语句的耗时， 我们需要把 profiles 打开 123456789101112131415161718mysql&gt; set profiling=1;Query OK, 0 rows affected, 1 warning (0.00 sec)mysql&gt; select * from tb_user where id = 10000;+-------+-----------+------------+| id | name | birth |+-------+-----------+------------+| 10000 | jSMfqpAKV | 1994-01-25 |+-------+-----------+------------+1 row in set (0.00 sec)mysql&gt; show profiles;+----------+------------+-------------------------------------------+| Query_ID | Duration | Query |+----------+------------+-------------------------------------------+| 1 | 0.0.00027100 | select * from tb_user where id = 10000 |+----------+------------+-------------------------------------------+1 row in set, 1 warning (0.00 sec) 可以看到使用主键查询时耗时 0.271毫秒 看下当前 tb_user 的索引情况 12345678910111213141516171819202122232425262728293031mysql&gt; show index from tb_user\\G;*************************** 1. row *************************** Table: tb_user Non_unique: 0 Key_name: PRIMARY Seq_in_index: 1 Column_name: id # 索引列为 id 列 Collation: A Cardinality: 978848 Sub_part: NULL Packed: NULL Null: Index_type: BTREE # 主键索引也是 B-Tree 索引 Comment:Index_comment:1 row in set (0.00 sec)mysql&gt; explain select * from tb_user where id = 10000\\G;*************************** 1. row *************************** id: 1 select_type: SIMPLE table: tb_user partitions: NULL type: constpossible_keys: PRIMARY key: PRIMARY # 用到了主键索引 key_len: 4 ref: const rows: 1 filtered: 100.00 Extra: NULL 不使用索引查询接下来我们根据 name 去查询数据， name 所在的字段现在还没有索引 1234567mysql&gt; select * from tb_user where name = 'jSMfqpAKV';+--------+-----------+------------+| id | name | birth |+--------+-----------+------------+| 10000 | jSMfqpAKV | 1994-01-25 |+--------+-----------+------------+2 rows in set (0.20 sec) 在 osx 上 mysql 并不区分大小写， 索引查询到两条数据， 接下来我们看下具体的耗时 123456+----------+------------+------------------------------------------------+| Query_ID | Duration | Query |+----------+------------+------------------------------------------------+| 2 | 0.19593300 | select * from tb_user where name = 'jSMfqpAKV' |+----------+------------+------------------------------------------------+1 rows in set, 1 warning (0.00 sec) 相比于使用 id 的主键查询， name 查询的速度慢了近千倍 1234567891011121314151617181920mysql&gt; show profile for query 2;+----------------------+----------+| Status | Duration |+----------------------+----------+| starting | 0.000050 || checking permissions | 0.000006 || Opening tables | 0.000012 || init | 0.000023 || System lock | 0.000007 || optimizing | 0.000008 || statistics | 0.000013 || preparing | 0.000009 || executing | 0.000002 || Sending data | 0.195761 | # 速度变慢的主要原因| end | 0.000008 || query end | 0.000004 || closing tables | 0.000006 || freeing items | 0.000016 || cleaning up | 0.000008 |+----------------------+----------+ 可以看到Sending data 是查询耗时的主要原因， 这个 Sending data 到底是什么东西？ 是传输数据吗？MySQL官方手册的说法是 线程正在读取并处理select语句选择的行数据，然后将数据发送给客户端。因为这个状态期间的操作偏重执行大量的磁盘访问(读取磁盘)，它通常是整个查询生命周期中运行时间最长的状态。 所以说导致查询耗时的主要原因还是磁盘 IO。 使用索引查询接下来我们对 name 字段加上索引 12345678910111213141516171819202122232425262728293031323334mysql&gt; create index idx_tb_user_name on tb_user(name);Query OK, 0 rows affected (1.44 sec)-- 目前表中的索引mysql&gt; show index from tb_user\\G;*************************** 1. row *************************** Table: tb_user Non_unique: 0 Key_name: PRIMARY Seq_in_index: 1 Column_name: id Collation: A Cardinality: 978848 Sub_part: NULL Packed: NULL Null: Index_type: BTREE Comment:Index_comment:*************************** 2. row *************************** Table: tb_user Non_unique: 1 Key_name: idx_tb_user_name Seq_in_index: 1 Column_name: name Collation: A Cardinality: 988297 Sub_part: NULL Packed: NULL Null: YES Index_type: BTREE # 可以在创建索引时默认的类型也是 BTREE 索引 Comment:Index_comment:2 rows in set (0.00 sec) 继续刚才的查询语句： 123456789mysql&gt; select * from tb_user where name = 'jSMfqpAKV';mysql&gt; show profiles;+----------+------------+------------------------------------------------+| Query_ID | Duration | Query |+----------+------------+------------------------------------------------+| 1 | 0.00028700 | select * from tb_user where name = 'jSMfqpAKV' || 2 | 0.00027100 | select * from tb_user where id = 10000 |+----------+------------+------------------------------------------------+ 此时耗时只有 0.28 毫秒, 虽然和主键查询相差无几， 但仍然没有主键查询快， 这是因为用过 name 索引是二级索引， 在查询时二级索引不会保留具体的数据行，保留的是主键 id。 查询时会根据二级索引先查询到 id， 再根据主键 id 找到数据所在的行。 使用索引时的注意事项禁止在查询语句中使用表达式123456789101112131415mysql&gt; explain select * from tb_user where id + 1 = 5\\G;*************************** 1. row *************************** id: 1 select_type: SIMPLE table: tb_user partitions: NULL type: ALL # 全部查询possible_keys: NULL key: NULL key_len: NULL ref: NULL rows: 998195 filtered: 100.00 Extra: Using where1 row in set, 1 warning (0.00 sec) 可以看到使用表达式时索引是没有生效的。 避免将索引列作为参数12345678910--- 先对 birth 创建索引mysql&gt; create index idx_tb_user_birth on tb_user(birth);mysql&gt; select count(*) from tb_user where YEAR(current_date) - YEAR(birth) &gt;= 18 \\G;+----------+------------+-----------------------------------------------------------------------------------+| Query_ID | Duration | Query |+----------+------------+-----------------------------------------------------------------------------------+| 12 | 0.14596000 | select count(*) from tb_user where YEAR(current_date) - YEAR(birth) &gt;= 18 |+----------+------------+-----------------------------------------------------------------------------------+ 可以看到索然 在 birth 字段上新增了索引， 但是查询耗时为 0.14 秒， 和之前没加索引查询的耗时是差不多的。 模糊查询时使用前缀索引有时需要索引很长的字段时， 会让索引变的很大， 通常有两种做法， 一直是采用哈希索引， 另一种就是使用模糊查询。 123456789101112131415161718192021222324252627282930313233343536373839404142434445mysql&gt; select * from tb_user where name like '%jSMfq%';+--------+-----------+------------+| id | name | birth |+--------+-----------+------------+| 312246 | jsmfQLlVW | 2017-03-03 || 654276 | jsmfQMmbv | 2019-12-07 || 629126 | jSMfqmpLL | 1991-08-12 |...| 10000 | jSMfqpAKV | 1994-01-25 || 298551 | jsmfQPAkv | 1995-12-22 || 230069 | JSmFqPcQW | 1982-06-15 |+--------+-----------+------------+81 rows in set (**0.16** sec) --耗时 0.16 秒mysql&gt; explain select * from tb_user where name like '%jSMfq%'\\G;*************************** 1. row *************************** id: 1 select_type: SIMPLE table: tb_user partitions: NULL type: ALL # 全表扫描possible_keys: NULL key: NULL key_len: NULL ref: NULL rows: 998195 filtered: 11.11 Extra: Using where1 row in set, 1 warning (0.00 sec)mysql&gt; explain select * from tb_user where name like 'jSMfq%'\\G;*************************** 1. row *************************** id: 1 select_type: SIMPLE table: tb_user partitions: NULL type: range # 范围查询possible_keys: idx_tb_user_name key: idx_tb_user_name key_len: 13 ref: NULL rows: 11 filtered: 100.00 Extra: Using index condition # 使用索引进行条件查询1 row in set, 1 warning (0.00 sec) 这是由于 BTREE 索引的数据是有序的使用 like ‘%xxx%’时是无法使用索引的。 不要对每一列都创建单独的索引为每个列创建单独的索引大部分情况下并不能提升 MySQL 的查询性能，在 MySQL5.0 及更新的版本中，引入了索引合并的策略， 将每列查询的结果进行合并， 举个例子： 123456789101112131415mysql&gt; explain select * from tb_user where id = 10000 or name like 'jSMfqp%'\\G;*************************** 1. row *************************** id: 1 select_type: SIMPLE table: tb_user partitions: NULL type: index_mergepossible_keys: PRIMARY,idx_tb_user_name key: idx_tb_user_name,PRIMARY key_len: 13,4 ref: NULL rows: 4 filtered: 100.00 Extra: Using sort_union(idx_tb_user_name,PRIMARY); Using where # MySQL 内部索引合并1 row in set, 1 warning (0.00 sec) 通过 explain 可以看到， MySQL 在实际的查询过程内还进行类内部优化， 将 通过 id 查询的数据与 name 查询的数据做了合并操作，在实际的查询过程中建立一个相关列的多列索引效果会更好。 123456789101112131415mysql&gt; explain select * from tb_user where name = 'jSMfqpAKV' and birth ='1970-01-01'\\G;*************************** 1. row *************************** id: 1 select_type: SIMPLE table: tb_user partitions: NULL type: index_mergepossible_keys: idx_tb_user_name,idx_tb_user_birth key: idx_tb_user_name,idx_tb_user_birth key_len: 13,4 ref: NULL rows: 1 filtered: 100.00 Extra: Using intersect(idx_tb_user_name,idx_tb_user_birth); Using where; Using index # 取了两部分数据的交集1 row in set, 1 warning (0.00 sec) 此时 name 与 birth 都只有单独的索引， Extra中的信息表明使用了交集来进行数据合并。 我们为 name，birth 建立一个多列索引后再进行查询 1234567891011121314151617181920mysql&gt; create index idx_name_birth on tb_user(name, birth);Query OK, 0 rows affected (1.14 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; explain select * from tb_user where name = 'jSMfqpAKV' and birth ='1970-01-01'\\G;*************************** 1. row *************************** id: 1 select_type: SIMPLE table: tb_user partitions: NULL type: refpossible_keys: idx_tb_user_name,idx_tb_user_birth,idx_name_birth key: idx_name_birth key_len: 17 ref: const,const rows: 1 filtered: 100.00 Extra: Using index # 通过索引查询1 row in set, 1 warning (0.00 sec) 可以看到在实际的查询中是走的索引进行查询， MySQL 无需再对查询的结果优化处理。 参考： MySQL性能优化[实践篇]-使用B树索引","categories":[{"name":"数据库","slug":"数据库","permalink":"https://coderunning.fun/categories/数据库/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://coderunning.fun/tags/MySQL/"}]},{"title":"LeetCode 86. Partition List","slug":"leetcode/linkedlist/partition-list","date":"2020-02-26T14:56:12.000Z","updated":"2020-04-24T15:03:26.678Z","comments":true,"path":"2020/02/26/leetcode/linkedlist/partition-list/","link":"","permalink":"https://coderunning.fun/2020/02/26/leetcode/linkedlist/partition-list/","excerpt":"Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.","text":"Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x. You should preserve the original relative order of the nodes in each of the two partitions. Example: Input: head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3 Output: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5 题意给出一个值 x ， 把两边分成两部分， 链表的结点的值比 x 小的位于大于等于 x 的节点之前， 并保持相对位置不变。给出 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3 。 比 3 小的有 1，2，2, 大于等于 3 的结点有 4，3，5分区后得到结果： 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5 思路既然分区， 分别使用两个链表存储小于 x 的结点以及大于等于 x 的结点， 遍历结束后， 将两个节点相连接； 代码123456789101112131415161718192021222324public ListNode partition(ListNode head, int x) &#123; ListNode smallHead = new ListNode(-1); ListNode bigHead = new ListNode(-1); ListNode smallNode = smallHead; ListNode bigNode = bigHead; while(head != null) &#123; if(head.val &lt; x) &#123; smallNode.next = head; smallNode = smallNode.next; &#125; else &#123; bigNode.next = head; bigNode = bigNode.next; &#125; head = head.next; &#125; smallNode.next = bigHead.next; // 断开与原始链表的链接 bigNode.next = null; return smallHead.next; &#125;","categories":[{"name":"每周一题","slug":"每周一题","permalink":"https://coderunning.fun/categories/每周一题/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://coderunning.fun/tags/leetcode/"},{"name":"linkedlist","slug":"linkedlist","permalink":"https://coderunning.fun/tags/linkedlist/"}]},{"title":"LeetCode 82. Remove Duplicates from Sorted List II","slug":"leetcode/linkedlist/remove-duplicates-from-sorted-list-ii","date":"2020-02-23T15:25:03.000Z","updated":"2020-04-24T15:03:26.679Z","comments":true,"path":"2020/02/23/leetcode/linkedlist/remove-duplicates-from-sorted-list-ii/","link":"","permalink":"https://coderunning.fun/2020/02/23/leetcode/linkedlist/remove-duplicates-from-sorted-list-ii/","excerpt":"Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list.","text":"Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. Example 1: Input: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 Output: 1-&gt;2-&gt;5 Example 2: Input: 1-&gt;1-&gt;1-&gt;2-&gt;3 Output: 2-&gt;3 思路题意是给出一个有序链表， 删除所有的重复的元素，对重复元素不做保留。 例子2 可以看到有头结点和之后元素重复的情况， 所有需要利用虚拟头结点； pre指向虚拟头结点，pre.next 指向头结点，cur 指针从头结点进行遍历； 判断否存在多个相同值的结点，若有遍历到最后一个重复元素： 当pre.next != cur时， 说明中间遍历的元素是重复的， 删除重复的元素 pre.next == cur 时， 说明前后没有重复的元素， pre 与 cur 指针分别指向下一个元素 重复 步骤 2. 继续遍历元素进行判断 示意图示意图如下： 代码12345678910111213141516171819202122232425262728public ListNode deleteDuplicates(ListNode head) &#123; ListNode dummyHead = new ListNode(-1); dummyHead.next = head; ListNode pre = dummyHead; ListNode curr = head; while(curr != null) &#123; // 遍历重复的元素， 直到最后一个 while(curr.next != null &amp;&amp; curr.val == curr.next.val) &#123; curr = curr.next; &#125; // 两个结点不同， 继续遍历 if(pre.next == curr) &#123; pre = pre.next; &#125; else &#123; //删除重复的元素 pre.next = curr.next; &#125; curr = curr.next; &#125; return dummyHead.next; &#125;","categories":[{"name":"每周一题","slug":"每周一题","permalink":"https://coderunning.fun/categories/每周一题/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://coderunning.fun/tags/leetcode/"},{"name":"linkedlist","slug":"linkedlist","permalink":"https://coderunning.fun/tags/linkedlist/"}]},{"title":"LeetCode 83.Remove Duplicates from Sorted List","slug":"leetcode/linkedlist/remove-duplicates-from-sorted-list","date":"2020-02-23T15:00:00.000Z","updated":"2020-04-24T15:03:26.680Z","comments":true,"path":"2020/02/23/leetcode/linkedlist/remove-duplicates-from-sorted-list/","link":"","permalink":"https://coderunning.fun/2020/02/23/leetcode/linkedlist/remove-duplicates-from-sorted-list/","excerpt":"Given a sorted linked list, delete all duplicates such that each element appear only once.","text":"Given a sorted linked list, delete all duplicates such that each element appear only once. Example 1: Input: 1-&gt;1-&gt;2Output: 1-&gt;2 Example 2: Input: 1-&gt;1-&gt;2-&gt;3-&gt;3Output: 1-&gt;2-&gt;3 思路题意是给出一个有序链表， 删除重复的元素只保留一个。 具体思路： 从头结点遍历， 如果下一个结点与当前结点的 value 一致，删除下一个结点， node.next = node.next.next 如果下一个结点与当前结点的 value 不一致， node = node.next， 继续遍历 代码1234567891011public ListNode deleteDuplicates(ListNode head) &#123; ListNode ref = head; while (ref != null &amp;&amp; ref.next != null) &#123; if (ref.val == ref.next.val) &#123; ref.next = ref.next.next; &#125; else &#123; ref = ref.next; &#125; &#125; return head;&#125;","categories":[{"name":"每周一题","slug":"每周一题","permalink":"https://coderunning.fun/categories/每周一题/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://coderunning.fun/tags/leetcode/"},{"name":"linkedlist","slug":"linkedlist","permalink":"https://coderunning.fun/tags/linkedlist/"}]},{"title":"LeetCode 61. Rotate List","slug":"leetcode/linkedlist/rotate-list","date":"2020-02-23T13:46:53.000Z","updated":"2020-04-24T15:03:26.682Z","comments":true,"path":"2020/02/23/leetcode/linkedlist/rotate-list/","link":"","permalink":"https://coderunning.fun/2020/02/23/leetcode/linkedlist/rotate-list/","excerpt":"Given a linked list, rotate the list to the right by k places, where k is non-negative.","text":"Given a linked list, rotate the list to the right by k places, where k is non-negative. Example 1: Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2Output: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULLExplanation:rotate 1 steps to the right: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULLrotate 2 steps to the right: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL Example 2: Input: 0-&gt;1-&gt;2-&gt;NULL, k = 4Output: 2-&gt;0-&gt;1-&gt;NULLExplanation:rotate 1 steps to the right: 2-&gt;0-&gt;1-&gt;NULLrotate 2 steps to the right: 1-&gt;2-&gt;0-&gt;NULLrotate 3 steps to the right: 0-&gt;1-&gt;2-&gt;NULLrotate 4 steps to the right: 2-&gt;0-&gt;1-&gt;NULL 思路题意从链表右边的第 k 个结点， 然后进行翻转。如果 k &lt; 链表的长度， 从链表的倒数第 k 个结点翻转；如果 k &gt; 链表的长度， 从链表的第 len - k%len 个结点翻转； 具体思路： 遍历链表得到当前链表的长度 length； 头尾相连； 若k &gt; length，从头遍历到第 k 个结点， 然后断开；若 k &gt; 链表的长度， 从链表的第 len - k%len 个结点断开。 代码12345678910111213141516171819202122232425262728public ListNode rotateRight(ListNode head, int k) &#123; if(head==null || head.next == null) return head; int len = 1; ListNode tail = head; // 计算链表长度 while(tail.next != null) &#123; len++; tail = tail.next; &#125; // 头尾相连 tail.next = head; ListNode temp = head; //找到倒数第 k 个结点 for(int i=1; i&lt;len - k%len; i++) &#123; temp = temp.next; &#125; // 新的头结点 head = temp.next; // 断开链表 temp.next = null; return head;&#125;","categories":[{"name":"每周一题","slug":"每周一题","permalink":"https://coderunning.fun/categories/每周一题/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://coderunning.fun/tags/leetcode/"},{"name":"linkedlist","slug":"linkedlist","permalink":"https://coderunning.fun/tags/linkedlist/"}]},{"title":"LeetCode 25. Reverse Nodes In k Group","slug":"leetcode/linkedlist/reverse-nodes-in-k-group","date":"2020-02-23T09:50:54.000Z","updated":"2020-04-24T15:03:26.681Z","comments":true,"path":"2020/02/23/leetcode/linkedlist/reverse-nodes-in-k-group/","link":"","permalink":"https://coderunning.fun/2020/02/23/leetcode/linkedlist/reverse-nodes-in-k-group/","excerpt":"Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.","text":"Given a linked list, reverse the nodes of a linked list k at a time and return its modified list. k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is. Example: Given this linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5 For k = 2, you should return: 2-&gt;1-&gt;4-&gt;3-&gt;5 For k = 3, you should return: 3-&gt;2-&gt;1-&gt;4-&gt;5 Note Only constant extra memory is allowed. You may not alter the values in the list’s nodes, only nodes itself may be changed. 思路题意为一次翻转链表中 k 个元素，如果 k = 2， 即每两个两个元素进行翻转，然后返回翻转后的链表。 具体思路： 每次翻转 k 个结点， 循环进行循环终止的条件是循环到最后一个节点 示意图如下： 代码123456789101112131415161718192021222324252627282930313233343536public ListNode reverseKGroup(ListNode head, int k) &#123; if (k &lt; 2) &#123; return head; &#125; ListNode dummyHead = new ListNode(-1); dummyHead.next = head; ListNode pre = dummyHead; ListNode tail = dummyHead; ListNode temp = null; while (true) &#123; int count = 0; while (count &lt; k &amp;&amp; tail != null) &#123; count++; tail = tail.next; &#125; if (tail == null) &#123; break; &#125; head = pre.next; while (pre.next != tail) &#123; temp = pre.next; pre.next = temp.next; temp.next = tail.next; tail.next = temp; &#125; tail = head; pre = head; &#125; return dummyHead.next; &#125;","categories":[{"name":"每周一题","slug":"每周一题","permalink":"https://coderunning.fun/categories/每周一题/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://coderunning.fun/tags/leetcode/"},{"name":"linkedlist","slug":"linkedlist","permalink":"https://coderunning.fun/tags/linkedlist/"}]},{"title":"B-Tree 索引和 Hash 索引","slug":"mysql/note-3-btree-and-hash","date":"2020-02-23T03:04:40.000Z","updated":"2020-04-24T15:03:26.684Z","comments":true,"path":"2020/02/23/mysql/note-3-btree-and-hash/","link":"","permalink":"https://coderunning.fun/2020/02/23/mysql/note-3-btree-and-hash/","excerpt":"什么是 B-Tree 索引与 Hash 索引？","text":"什么是 B-Tree 索引与 Hash 索引？ 索引索引的定义： 存储引擎用于快速找到记录的一种数据结构。 假设数据库是一本书， 索引就是书中的目录， 能让我们更快的找到我们需要查询的内容。 如果没有目录我们需要把整本书翻一遍， 运气不好可能需要翻到最后一页才能找到我们需要查找的内容。 索引分类按逻辑存储结构划分 B树索引（按物理结构划分又可以分为聚簇索引和非聚簇索引） Hash 索引 空间索引 全文索引 建立在单列还是多列划分 单列索引 符合索引 约束条件划分 唯一索引 主键索引 接下来介绍常见的 B-Tree 索引和 Hash 索引 B-Tree 索引数据库采用 B-Tree 索引的原因很简单： 减少随机磁盘 IO 次数。原因在于数据的量很大，大部分的数据都是存储在磁盘中， 不可能全部存储在内存中。 为什么说 B-Tree 索引更适合数据库存储数据， 咱们可以将 B-Tree 的结构和其他的数据结构做下对比， 以 B-Tree 与红黑树为例。 在这先看下红黑树与 B-树的特点： 红黑树 每个结点要么是红的，要么是黑的。 根结点是黑的。 每个叶结点（叶结点即指树尾端NIL指针或NULL结点）是黑的。 如果一个结点是红的，那么它的俩个儿子都是黑的。 对于任一结点而言，其到叶结点树尾端NIL指针的每一条路径都包含相同数目的黑结点。 红黑树的特点使得红黑树不仅是棵平衡树， 而且比平衡树更加平衡， 读取数据的次数更少。 B-树：是一种多路搜索树（并不是二叉的） 根结点至少有两个子节点。 每个中间节点(根节点和叶子节点除外)都包含k-1个元素和k个孩子节点，其中 m/2 &lt;= k &lt;= m 。m 代表树的高度， 也叫做阶。 每一个叶子节点都包含k-1个元素，其中 m/2 &lt;= k &lt;= m。 所以的值都是按顺序存储的。 每个叶子页到根的距离相同。 在对比时可以发现， 想要找到 008 的这个数， 在红黑树需要遍历三次， 而在 B-Tree 中只需要两次即可。当数据量越来越大时， B-Tree 会变的矮胖起来， 同样的数据量在 B-Tree 中需要查找的次数更少。对于相同的数据量，B树的更矮，高度更低，查找数据时经过的节点更少，所以造成的随机磁盘IO次数也就更少。(文件索引数据库索引用的都是B树) B+TreeInnoDB引擎内部使用的是 B+Tree 作为索引的存储结构。 在进行数据查找时，通过比较 key 来找到对应的 value (也就是我们要查找的数据)。B树每个数据的 Key-Value 都是存储在一起的(实际上value部分只是存储了数据行的引用)，每次比较key的时候都会把 value 也给读取出来，这就造成了不必要的磁盘IO。 另外数据库经常会出现范围查询的需求，单纯的B树进行范围查询需要回溯到父节点，这也造成了大量的I/O操作，而且这个操作相当复杂。 为了解决这些问题B树的发明者对B树进行了一些改进。 B+树是B树的变体，它的完整数据全部存储在叶子结点，非叶子节点只存储key值，这样B+树避免了不必要的磁盘I/O，由于所有的查找最终都会到叶子结点，所以也就保证了查询性能的稳定。 同时由于B+树叶子结点使用指针串联起来，这就方便了范围查询(&gt;、&lt;、between等)。 而且由于B+树索引本身的有序性，所以在很多情况下可以避免对数据的排序(对磁盘排序要用到文件外排序，而且数据量很大很耗时)。 总结起来，使用B+树作为数据库索引的存储结构有以下原因： 减少磁盘I/O，并尽量避免不必要的磁盘I/O B+树保证了查询性能的稳定 B+树方便范围查询 避免对数据进行外排序(filesort) 哈希索引hash在很多编程语言中都能见到，因为它查找速度非常快，理论上平均时间复杂度能达到O(1)。 是 Memory引擎的默认索引。 存储引擎对每一列计算出一个哈希码，将其保存在哈希表中， 同时哈希表保存每行的指针, 如果出现 hash 碰撞， 索引会以链表的形式存放多个记录到同一条哈希目录上， 结构类似于 HashTable。 举个例子： name age Jane 28 Peter 20 David 30 假设使用哈希函数f()，对每条记录生成哈希值：f(‘Jane’) = 2323f(‘Peter’) = 2456f(‘David’) = 2400 槽(slot) 值（value) 2323 第一行指针 2456 第三行指针 2400 第二行指针 看有hash 索引具体是如何工作的， 举个例子： 1select * from user where `name` = 'Jane' 执行上面这条 sql 语句会先计算 Jane 的哈希值， 然后根据哈希值 2323 对应的指针去找到对应的第一行数据。 单行查询的速度要比 B-Tree索引快很多，但hash索引在使用上有很大的局限性： 无序性，导致无法范围查找和索引排序。 between, &gt; 、&lt;、等范围查询无法使用索引。 对完整的key计算hash，所以不支持部分匹配。 比如对多个列创建hash索引，查找时条件必须这些列精确匹配，才能使用到hash索引。都精确匹配了，更别谈什么索引覆盖。 再比如，使用like ‘hash%’进行前缀匹配，也无法使用hash索引。 由于hash索引实际只保存了数据对应的行指针，所以不能避免读取数据行(说白了还是没有索引覆盖的功能)。 当产生hash碰撞(哈希值相同)的时候，数据库要遍历链表中所有的行指针，逐个取出数据行进行比较，数据量越大，冲突越多，查找代价越高。 由于hash索引的上述缺点，所以实际使用hash索引的情况很少，MySQL除了Memory存储引擎和NDB分布式存储引擎，其他大部分存储引擎默认使用B树索引。","categories":[{"name":"数据库","slug":"数据库","permalink":"https://coderunning.fun/categories/数据库/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://coderunning.fun/tags/MySQL/"}]},{"title":"Hexo + Github 搭建博客（Mac篇）","slug":"blog/git-pages-mac","date":"2020-02-18T15:12:19.000Z","updated":"2020-04-24T15:03:26.656Z","comments":true,"path":"2020/02/18/blog/git-pages-mac/","link":"","permalink":"https://coderunning.fun/2020/02/18/blog/git-pages-mac/","excerpt":"本文教你如何利用 github pages 快速白嫖一个博客！","text":"本文教你如何利用 github pages 快速白嫖一个博客！ 前言当你看到这篇文章时， 已经默认你对github pages有了一定的了解。 准备工作 git Git官网下载 安装完成后查看git是否安装成功 123git --versiongit version 2.18.0 Node.js Node.js下载 安装完成后， node -v 检查下是否安装完成 12345node -vv11.7.0npm -v6.5.0 github: xxx.github.io (其中xxx是你github的用户名) 使用邮箱注册github。 创建的用户名.github.io的仓库，比如说，如果你的github用户名是xxx，那么你就新建xxx.github.io的仓库（必须是你的用户名，其它名称无效）。 生成ssh key 为了能在本地操作github仓库， 还需要生成ssh key, ssh-keygen -t rsa -C “github 邮箱”。 vi id_rsa.pub, 拿到密钥添加到github账号设置中即可操作本地仓库同步数据到远程。 打开 GitHub_Settings_Keys 将ssh key添加进去。 不确定是否添加成功， 可以在命令行输入 ssh -T git@github.com。 12345678910cd ~/.sshssh-keygen -t rsa -C \"你的邮箱地址\" // 然后一路回车vi id_rsa.pub // 将id_rsa.pub中的key添加到github中ssh -T git@github.com // 测试key是否添加成功 // 出现这串文字提示你添加成功了Hi username! You've successfully authenticated, but GitHub does notprovide shell access. Hexo 安装使用npm命令安装Hexo，输入： 12345678910npm install -g hexo-cli hexo init blog // 可以创建一个blog// 创建一篇博客文章hexo new first_pagehexo ghexo s 然后在浏览器输入 localhost:4000 即可看到这篇文章 常见的 hexo 命令有以下几个： 1234567hexo new 文章名称 // 在hexo clean // 清空缓存， 一般不用也行hexo g //生成文章hexo s // 本地预览 更多的指令可以见： Hexo 命令 博客部署以上的操作只是在本地预览文章， 要想让我们的文章让更多的人看见， 需要把文章推送到远程仓库， 发布到xxx.github.io 打开blog目录下的 _config.yml 文件， 填上github仓库的地址 12345deploy: type: git repo: github: git@github.com:HarryHook/harryhook.github.io.git branch: master 上面的这个配置就是为了让hexo知道你要把blog部署在哪个位置，很显然，我们部署在我们GitHub的仓库里。 Git部署插件，输入命令： 1234567npm install hexo-deployer-git --save// 然后部署三连走一波hexo clean hexo g hexo d 然后在 xxx.github.io 就可以看到你的博客了 更换主题hexo 默认的主题是 landscape， 在 blog 的 themes 下可以看到你使用的主题， 这个主题也是在 _config.yml 进行配置的， 如果你想尝试其他的主题， 可以到 Themes 进行下载， 下载到 blog 的 themes 目录下即可。 主题的配置在根目录下的 _config.yml 进行配置。 1theme: yelee // 与你themes的博客主题名称一致即可 Markdown语法Mac 下推荐使用 MacDown软件 对 md 文件进行编辑， 因为创建的文章都是 .md的， 一些 markdown 的语法可以参考菜鸟教程， 多摸索多实践。 其他个性化配置 添加 gitalk 插件 PV UV 访问次数","categories":[{"name":"建站","slug":"建站","permalink":"https://coderunning.fun/categories/建站/"}],"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://coderunning.fun/tags/博客搭建/"}]},{"title":"Schema设计与数据类型优化","slug":"mysql/note-2-shcema-design","date":"2020-02-16T08:30:50.000Z","updated":"2020-04-24T15:03:26.684Z","comments":true,"path":"2020/02/16/mysql/note-2-shcema-design/","link":"","permalink":"https://coderunning.fun/2020/02/16/mysql/note-2-shcema-design/","excerpt":"MySQL常见的数据类型有哪些？ 数据库在设计的过程中应该注意哪些地方？","text":"MySQL常见的数据类型有哪些？ 数据库在设计的过程中应该注意哪些地方？ 如何选择数据类型 越小越好 越小的数据类型占用更少的磁盘、内存、CPU缓存。 但需要注意当前类型存储值的范围。 简单就好 简单的数据类型需要更少的CPU周期， 整形比字符串的代价要低。 两个例子， 使用MySQL内建的datetime或者timestamp存储日期和时间而不是用字符串存储。还有就是应该使用整形存储ip， 而不是字符串存储。 尽量避免null值 通常情况下最好指定列为not null， 查询包含null的列成本更高， 而且会使用更多的存储空间， 当NULL列被索引时， 需要额外的一个字节去存储。 常见的数据类型整数类型整数类型分别有以下： TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT。分别占用8， 16， 24， 32， 64位存储空间，以TINYINT为例， 存储范围为-2^7 ~ 2^7-1, 即-128~127。 整数类型可选UNSIGNED属性， 表示不允许为负值， 例如 TINYINT UNSIGNED可存储的范围0~255。 限定整数类型的范围是没有意义的， INY(2)与INT(20)是相同的， 只是展示字符的个数会受到限制。 实数类型实数指的是带有小数部分的数字，但不一定只用实数存储带小数的值， 还可以用DECIMAL存储比BIGINT还大的整数。 因为CPU是不支持DECIMAL的直接运算的，MySQL内部支持高精度运算。因为CPU支持浮点数的计算， 所以浮点预算的速度更快， MySQL内部是以DOUBLE作为内部浮点计算的类型。 因为需要额外的空间和计算开销， 所以只在精确计算时才使用DECIMAL， 但是当数据量比较大时， 可以考虑使用BIGINT代替DECIMAL， 将需要存储的小数乘以相应的倍数， 避免浮点数存储计算不精确和DECIMAL计算代价过高的问题。 字符串类型MySQL支持多种字符串类型， 每种类型还有很多变种。 其中VARCHAR和CHAR是最主要的两种字符串类型。 VARCHAR VARCHAR类型用于存储可变长字符串， 是最常见的数据类型， 比定长类型更节省空间。越短的字符串使用越少的空间， 但在ROW_FORMAT=FIXED时是例外情况，每一行都会使用定长存储。 VARCHAR需要使用1到2个额外的字节记录字符串的长度。 如果列的最大长度=255字节， 只需要1个字节表示，否则需要2个。 2^8 = 256， VARCHAR(10)需要11个字节的存储空间， VARCHAR(1000)需要1002个字节， 因为需要2个字节存储长度信息。 VARCHAR节省了空间， 但是当执行UPDATE操作时， 行可能变的更长， 当页内没有多余的空间可以存储时，InnoDB需要分裂页来处理，MyISAM需要将行拆成不同的片段存储， 但InnoDB会将过长VARCHAR存储为BLOB CHAR CHAR是定长的， MySQL会根据定义的字符串长度分配足够的空间。 CHAR适合存储很短的字符串， 或者所有值都接近同一长度， 例如密码的MD5值。 CHAR有一个特点， 就是会删除所有末尾的空格， 存储数据时需要注意。 例子： 12345678910111213141516171819202122232425CREATE TABLE char_test( char_col CHAR(10), varchar_col VARCHAR(10));INSERT INTO char_test(char_col) VALUES ('string1'), (' string2'), ('string3 ');INSERT INTO char_test(varchar_col) VALUES ('string1'), (' string2'), ('string3 ');select CONCAT(\"'\",char_col, \"'\") from char_test;+---------------------------+| CONCAT(\"'\",char_col, \"'\") |+---------------------------+| 'string1' || ' string2' || 'string3' |+---------------------------+select CONCAT(\"'\",varchar_col, \"'\") from char_test;+------------------------------+| CONCAT(\"'\",varchar_col, \"'\") |+------------------------------+| 'string1' || ' string2' || 'string3 ' |+------------------------------+ 可以看到char存储字符串数，string3的末尾的空格被截断了， 而varchar存储数据时不会存在这种情况。 BLOB与TEXT类型 BLOB与TEXT都是为存储很大的数据而设计的字符串数据类型， 分别采用二进制和字符方式存储， MySQL将BLOB与TEXT值当一个独立的对象处理，当BLOB和TEXT的值太大时，MySQL会专门建立一个存储区域来进行存储， 在行内用1~4个字节存储一个指针， 指向外部存储实际值的区域。 BLOG与TEXT的区别在于BLOB存储的是二进制数据， 没有排序规则或者字符集，TEXT类型有字符集和排序规则。 此外MySQL对BLOB与TEXT列进行排序与其他类型是不同的： 只对每列最前max_sort_length字节而不是整个字符串进行排序，可以动态调整max_sort_length或者ORDER BY SUNSTRING(column, length)来进行排序。 MySQL不能将BOLB与TEXT列的全部长度的字符串进行索引， Memory引擎也不支持BLOB和TEXT类型， 如果查询BLOB或者TEXT列将生成隐式临时表， 即使临时表存储在内存上系统间的调用开销也很大， 所以尽量不要使用BLOB或者TEXT类型。 万不得已使用了，在用到BLOB字段的地方使用SUBSTRING(column, length）将列值转换为字符串。 枚举 枚举代替常见的字符串 12345678910111213141516CREATE TABLE enum_test( e ENUM('fish', 'apple', 'dog') NOT NULL); --插入不属于枚举的值时--INSERT INTO enum_test(e) VALUES ('A'), ('B'), ('C');ERROR 1265 (01000): Data truncated for column 'e' at row 1select * from enum_test;+-------+| e |+-------+| dog || apple || fish |+-------+ 看一下实际枚举对应的整数是： 12345678select e + 0 from enum_test;+-------+| e + 0 |+-------+| 3 || 2 || 1 |+-------+ 可以看到枚举字段在内部存储是按照整数而不是定义的字符串进行排序的 插入的是fish(3), apple(2), dog(1), 查询的是dog(1), apple(2), fish(3)如果想要按照自定义的顺序展示， 可以使用FIELD()函数 12345678select e from enum_test order by FIELD(e, 'dog', 'apple', 'fish');+-------+| e |+-------+| dog || apple || fish |+-------+ 使用ENUM的建议： 不会做修改的列， 例如性别。ENUM值千万不要使用数值型，会带来混淆。 日期与时间类型MySQL提供两种相似的时间类型： DATETIME和TIMESTAMP DATETIME 范围比TIMESTAMP大， 从1001年到9999年， 精度为秒， 把日期封装成YYYYMMDDHHMMSS的整数中， 与时区无关， 使用8个字节存储。 TIMESTAMP 保存了1970-01-01 00:00:00 以来的秒数， 和UNIX时间戳相同。 TIMESTAMP只使用四个字节的存储空间， 范围比DATETIME小得多， 只能表示从1970年只2038年的数据， 且TIMESTAMP显示的值是区分时区的。 TIMESTAMP也有DATETIME没有的属性， 如果数据在插入时没有指定第一个TIMESTAMP列的值， MySQL会赋予这个列为当前时间。 通常使用TIMESTAMP保存时间。 MySQL现在没有提供合适的数据类型去处理比秒更小粒度的时间， 可以使用BIGINT类型存储微妙级别的时间戳 位数据类型 BIT(不推荐使用) MySQL将BIT当做字符串类型而不是整数类型， 检索BIT(1)时， 结果是一个包含二进制0或1的字符串， 而不是ASCII码的”0”或”1”， 很容易令人迷惑， 举个例子： 123456789CREATE TABLE bit_test(a bit(8));INSERT INTO bit_test VALUES(B'01000001');SELECT a, a+0 FROM BIT_TEST;+------+------+| a | a+0 |+------+------+| A | 65 |+------+------+ 当存储’01000001’字符串时， 检索出的结果为ASCII码为65的字符”A”， 在数字上下文的检索中， 得到的是数字65。 SET 唯一的缺点是修改表的成本比较高， 当保存很多的true/false时可以考虑使用SET， 这里看一下SET的用法： 123456789101112131415161718CREATE TABLE acl(perms SET('CAN_READ', 'CAN_WRITE', 'CAN_DELETE') NOT NULL);INSERT INTO acl(perms) VALUES('CAN_READ,CAN_DELETE');SELECT perms FROM acl WHERE FIND_IN_SET('CAN_READ', perms);+---------------------+| perms |+---------------------+| CAN_READ,CAN_DELETE |+---------------------+SELECT perms FROM acl WHERE FIND_IN_SET('CAN_DELETE', perms);+---------------------+| perms |+---------------------+| CAN_READ,CAN_DELETE |+---------------------+ 如何选择合适的类型作为标识列 整数类型 标识列的不二选择， 通常作为主键， 因为可以使用AUTO_INCREMENT。 ENUM与SET 不要使用ENUM,SET作为标识列， ENUM与SET适合存储固定信息，例如有序的状态、人的性别。 字符串类型 避免使用字符串作为标识列， 原因在于很消耗空间，并且比数字类型慢。 范式与反范式三范式的定义分别是： 一范式 指数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值 二范式 表中的每个实例（每行）都可以被唯一区分，为了被区分，通常为表加上一列以存储每个实例的唯一标示（主键） 三范式 数据库表不包含已在其他表的非主关键字信息，即包含已在其他数据库表中的主关键字信息（外键） 举例子来说， 下面是一张 雇员-部门-上级表： EMPLOYEE DEPARTMENT HEAD Jones Accounting Jones Simth Engineering Simth Brown Accounting Jones Green Engineering Simth 这种表满足第一范式， 每列数据都是单独的值， 但是不满足第二范式， 不能唯一的标识一列， 加入Brown接替Accounting部门， 将同时修改两行数据， 此外如果删除了Accounting部门的所有雇员， 就失去了关于这个部门的记录。为了满足第二范式， 我们将表拆分成 雇员-部门，部门-上级 这种关系。 雇员-部门 EMPLOYEE_NAME DEPARTMENT Jones Accounting Simth Engineering Brown Accounting Green Engineering 部门-上级 DEPARTMENT HEAD Accounting Jones Engineering Simth 这样就算修改任意部门的领导也主需要修改部门-上级即可， 对部门雇员的数据是没有影响的， 哪怕Accounting部门没有雇员， 对这个部门也是没有影响的。 范式的优缺点优点： 范式的更新操作通常比反范式更快。 符合范式， 很少或者没有重复数据，因此修改数据也会少很多。 范式化的表通常更小。 很少有多余的数据意味着检索数据时更少执行DISTINCT和GROUP BY操作。比如DEPARTMENT是一张单独的表， 就不需要对雇员表进行GROUP BY department操作。 缺点： 查询数据时需要进行多张表的关联。 反范式的优缺点优点: 所有数据都在一张表， 可以很好的避免关联。 缺点： 所有数据都在一张表， 带来的问题就是字段过多， 修改成本高。 缓存表与汇总表-提升查询效率 缓存表 存储从从其他查询速度较慢的表的数据 汇总表 保存的是分组后的数据 其中有一个计数器的策略很有意思， 为了避免对某行数据并发写阻塞全局， 将计数放到多行进行， 最终统计多行的数据总和即可。 提升ALTER TABLE效率对大表来说， ALTER TABLE可能需要几小时甚至数天才能完成操作， 因为ALTER操作涉及到锁表和重建表。常见的ALTER TABLE有两种操作： 先在不提供服务的机器上执行ALTER TABLE操作，然后进行主库切换； 创建一张与源表结构一致的表， 然后通过重命名与删表操作交换两张表。 其中 1ALTER TABLE table_name MODIFY COLUMN column_name ....; 执行过程是先读取表中所有数据， 再将列替换插入到新表， 所以MODIFY COLUMN操作是相当慢的 1ALTER TABLE table_name ALTER COLUMN column_name ....; 这条语句会直接修改.frm文件， 而.frm文件中存的是表的默认值， 所以这种操作是非常快的。一句话，修改表的默认值应该使用ALTER COLUMN 操作为高效地载入数据到MyISAM， 一个技巧是先禁用索引、载入数据、重启索引， 唯一的问题是这个方法对唯一索引是无效的。在InnoDB也有类似的操作， 先删除所有的非唯一索引， 增加新的列， 然后再创建新的索引。","categories":[{"name":"数据库","slug":"数据库","permalink":"https://coderunning.fun/categories/数据库/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://coderunning.fun/tags/MySQL/"}]},{"title":"MySQL架构与历史","slug":"mysql/note-1-mysql-history","date":"2020-02-08T04:03:43.000Z","updated":"2020-04-24T15:03:26.683Z","comments":true,"path":"2020/02/08/mysql/note-1-mysql-history/","link":"","permalink":"https://coderunning.fun/2020/02/08/mysql/note-1-mysql-history/","excerpt":"常说的ACID与MySQL的隔离级别到底是怎么回事？","text":"常说的ACID与MySQL的隔离级别到底是怎么回事？ MySQL的主要特征最主要的特征莫过于存储引擎， 存储引擎将查询处理、其他系统任务和数据的读写相分离； MySQL架构(三层结构)既然MySQL这么厉害， 那到底什么是存储引擎， 要搞明白存储引擎， 我们先看下MySQL的架构， 以及存储引擎在MySQL中所处什么位置，到底做了什么。 MySQL按结构划分分为三层： 第一层：面向客户端的连接层; 第二层：大多数MySQL核心功能所在的中间层，具有查询解析、优化、缓存、内置函数等功能; 第三层：存储引擎，负责数据的存储与提取如图所示： 由这个架构可以看到， 存储引擎相当于是数据与文件系统的接口（桥梁），中间层将SQL语句解析后判断需要执行什么操作，调用存储引擎的接口， 通过存储引擎将数据存储到文件系统中或将数据从文件系统中取出。 并发控制 当面临多个读写操作是， MySQL是如何做读写控制？ 读操作共享数据单元，加读锁（共享锁）， 读锁不会阻塞其他的读操作， 但是会阻塞写操作；写操作时加排他锁， 会阻塞其他的读锁和写锁。 锁的粒度如何？ 表锁、行锁又有什么区别？ 表锁是开销最小的策略， 当写数据时， 会先获得写锁，同时会阻塞其他用户对改表的所有读写操作；当没有人获得写锁时， 多个读锁间不会相互阻塞，此时可以有多个事务进行读操作。行锁最大程度支持并发， 但也带来了最大的开销。只在引擎层做了实现， 没有在服务层实现 事务特性（ACID)以转账为例: 开启事务: 查询账户a余额 = 500; 从a账户-200， a账户余额= 300; 给b账户+200； 提交事务;转账过程中的任何一步出错， 之前的所有步骤都应该回退， 否则可能a的账户中少了300， 但b账户未到账 其中ACID 的含义如下： Atomicity（原子性）：一个事务必须视为不可分割的最小单元， 要么全部成功， 要么全部失败， 以上面转账为例， 不能缺省中间的任何一个步骤， 否则全部失败。 Consistency（一致性）： 数据库从一个一致性的状态转换到另一个一致性的状态， 事务未提交之前， a、b账户的金额都是不会变的。 Isolation（隔离性）：一个事务的修改在提交之前， 对其他事务是不可见的。例如在转账的事务未提交之前， 另一个转账事务开始时，看到a账户的金额的金额应该是500才对。 Durability（隔离性）：一旦事务提交，其所作的修改会永久保存到数据库中。 事务的隔离级别MySQL定义了四种隔离级别，但是这四种隔离级别到底是怎么来的？ 先看下官方的定义 READ UNCOMMITED （未提交读）: MySQL中最低的隔离级别， 即使事务中的修改没有提交， 也可以被其他事务看见。 事务可以读取未提交的数据， 也被称之为脏读（Dirty Read）, 在实际应用中很少使用。 READ COMMITED (提交读)： 大多数数据库的默认隔离级别， 但MySQL不是。一个事务只能看到已提交的事务所做的修改， 反过来说， 一个事务在提交前， 所做的任何修改对其他事务都是不可见的。因为这种隔离级别可能导致同样的查询会读到两个不一样的结果， 称之为不可重复读（nonrepeatable read）； REPEATABLE READ（可重复读）：MySQL中InnoDB引擎的默认隔离级别，该级别解决了不可重复读的问题（这里有个疑问是如何做到的？）， 但是解决不了幻读（Phantom Read），所谓幻读， 事务在进行范围查询时， 另一个事务在该范围内插入了新纪录， 实际应用中InnoDB 通过间隙锁（范围锁定）来解决幻读问题； SERIALIZABLE（可串行化）：强制事务串行执行， 可以避免幻读问题，为读取的每一行数据都加锁， 但是会导致大量的超时和锁竞争， 很少使用。 其实隔离级别的实现跟锁是密不可分的， 举个例子先看下没锁会导致什么情况 a.旺财和小强同时对一个账号进行操作，都读取到A=100， 旺财对账号+20， 余额为120； 小强也对余额100处理， 对将账号减去50，余额等于50， 覆盖了旺财的结果， 可以看出无锁的情况会造成数据丢失。 b.此后旺财和小强约定对写操作加锁（排它锁, X锁）， 只能有一方对数据进行写， 解决了两个人同时修改数据导致的问题， 但是这样带来了一个新的问题（脏数据），如下图所示： 当旺财进行写操作时， 账号余额变成了120， 此时小强对余额进行读取拿到结果120， 但是旺财的系统出现问题进行了回滚， 余额又回滚到了100， 此时小强就读到了脏数据。 脏数据出现的原因是事务中没有提交的数据对其他事务可见导致的。 c.针对脏数据的问题， 旺财和小强约定在读数据的时候加读锁（共享锁, S锁）， 共享锁不会阻塞其他读操作，写操作时会阻塞其他的读、写操作；加了X锁，就不能获取S锁，加了S锁就不能获取X锁， 但加了S锁还可以获取S锁。 旺财分别对A、B加上S锁，读取完毕后释放S锁 ， 计算C=A+B，；小强获取B的X锁， 执行B=B-30；释放B的X锁； 此时旺财再执行（在一个事务中）刚才的查询发现前后两次C计算的结果不一样， 导致了不可重复读的问题。 d.旺财和小强约定， S锁不能读完数据就立马释放， 需要持续到事务提交； 再面对上面这种情况时，B获取X锁就会失败。 当旺财再计算C=A+B时， 先对A、B加S锁， 读取完毕S锁也不会释放；此时小强再获取X锁就会失败，这样就能够避免重复读取数据时出现数据不一致的情况了， 这里就对应了可重复读。 e. 有一次旺财对一批学生进行了批量处理， 选取了age=18的数据， 处理完后发现有一行竟然是没处理的数据, 查了半天才发现， 在旺财查询修改数据期间，小强也新增了一条数据，正是新增的这条数据让旺财产生了幻觉。 为了解决这种问题， 旺财和小强决定串行执行， 这里就对应了串行化。 死锁问题两个或多个事务对同一资源的抢占，并请求锁定对方的资源； 事务1： START TRANSACTION; UPDATE StockPrice SET close = 45.50 WHERE stock_id = 4 and date = &apos;2020-02-08&apos;; UPDATE StockPrice SET close = 45.50 WHERE stock_id = 3 and date = &apos;2020-02-09&apos;; COMMIT; 事务2： START TRANSACTION; UPDATE StockPrice SET close = 45.50 WHERE stock_id = 3 and date = &apos;2020-02-09&apos;; UPDATE StockPrice SET close = 45.50 WHERE stock_id = 4 and date = &apos;2020-02-08&apos;; COMMIT;如果两个事务通知执行第一条UPDATE语句，更新了该行数据，同时对改行数据进行锁定； 当执行到第二条UPDATE语句时，事务1需要获得stock_id = 3的写锁， 事务2需要stock_id = 4的写锁， 然而这两个写锁都被对方占有，两个事务都等对方释放锁， 此时就造成了死锁。 解决死锁的方法： * 超时解除; * 最少行级别的排他锁（写锁）进行回滚。 事务日志通过事务日志， 存储引擎先将数据在内存中进行修改， 然后再持久化到硬盘中的事务日志， 不用每次都写进硬盘； 就算系统奔溃， 在重启时也会恢复修改的数据。两次写操作， 修改数据需要写两次硬盘； 混合事务与显示锁定MySQL采用的是自动提交模式，默认每个查询都会开启事务； 如果关闭自动提交， 需要显式commit或者rollback结束一个事务， 此间的所有查询都在一个事务中。 不推荐在事务中混合事务引擎和非事务引擎， 当数据需要回滚时， 非事务引擎数据无法回滚， 会造成数据的非一致性 InnoDB采用的是两阶段锁（疑问： 什么是两阶段锁， 在哪两阶段）：事务在执行过程中随时都可以锁定， 只有在commit或者rollback后锁才会释放，其中 select … for update 就是显式锁定 此外不要使用AUTOCOMMIT 以及LOCK TABLES ， 性能太差 MVCC 多版本控制（MVCC算法）MVCC是行级锁的一个变种， 相比于行级锁性能更高一些， 避免了很多加锁操作， 开销更低；实现原理：为每行数据赋予一个版本号， 每次修改数据都会版本号+1， 读取数据时开启事务，给当前事务一个版本号a， 查询数据库中版本号&lt;=当前版本号a的数据， 就算此时新增了数据，版本号为b， 此时b&gt;a， 在之前的查询事务中继续查询， 得到的数据是没有发生变化的）。 以REPEATABLE READ为例： SELECT : a. InnoDB 会查找当前事务版本号之前（小于等于当前版本号的）的数据行； b. 行的删除版本号要么未定义， 要么大于当前版本号。这样可以确保事务读取到的行在事务开始前未被删除 INSERT: 为新插入的每一行保存当前版本号作为行版本号 DELETE： 为删除的每一行保存当前版本号作为行版本号 UPDATE: 先新增一行数据，保存当前事务版本号作为行版本号， 再将当前版本行作为之前数据的行删除标识（先增后删）MVCC只在REPEATABLE READ 和 READ COMMITED下工作， READ UNCOMMITED总是读取最新的数据行， SERIALIZABLE对每行数据都加锁 存储引擎InnoDB, MyisAM为官方引擎， 第三方还有XtraDB等 InnoDB 特性： 采用MVCC支持高并发， 实现了四个标准的隔离级别， 默认REPEATABLE READ, 通过间隙锁防止幻读出现 InnoDB基于聚簇索引， 使得主键查询的性能很高 InnoDB 内部做了优化， 从磁盘读取数据是采用可预测性读， 读操作的自适应哈希索引， 写操作的插入缓存区 MyISAM特性：全文索引， 压缩， 空间函数(GIS), 不足： 不支持事务和行级锁， 崩溃后无法恢复 加锁与并发， 对整张表加锁，对需要读取的所有表加共享锁， 写入时加排他锁， 这里引入了一个概念叫做并发插入（读操作的同时， 往表中写数据） 修复： 这里的修复和崩溃后恢复不是一个概念，执行CHECK TABLE table_name 后有错误时再REPAIR TABLE table_name 索引特性：支持全文索引， 对于BLOB, TEXT等长字段， 也可以基于前500个字符创建索引； 如果设置了延迟更新索引建DELAY_KEY_WRITE， 每次修改完成后不会立即将修改的索引写入磁盘，而是先写入内存的缓存区 可压缩：对于不再修改的内容可以进行压缩 如何选择合适的引擎(尽量不要使用混合引擎)事务支持：InnoDB, XtraDB, 不需要事务支持时MyISAM备份：在线备份InnoDB 首选， 定期关闭服务器备份无论哪种引擎都可以崩溃恢复： InnoDB 首选， MyISAM损坏概率更改， 切恢复速度更慢， 这都是相比于InnoDB来说的特性： MyISAM的GIS， 支持地理空间搜索 转换引擎： 常见的三种方法ALTER TABLE: ALTER TABLE table_name ENGINE = InnoDB; 该方法适用于任何引擎， 但是执行时间很长， 原理是将原表复制到一张新表中，复制期间会对原表加锁， 而且会丢失原引擎的特性， 例如InnoDB转换到MyISAM再转回InnoDB时会丢失外键索引。 导出与导入：利用MySQLdump 导出到文件， 修改MySQL文件中create table 的引擎选项， 同时修改表名。 创建与查询：结合第一种方法的高效（相比于导出）和第二种安全（相比于1）特性。 1.先创建一张空表 CREATE TEBLE innodb_table Like myisam_table; 2.再修改引擎 ALTER TABLE innodb_table ENGINE = InnoDB; 3.最后复制数据 INSERT INTO innodb_table SELECT * FROM myisam_table; 参考： 码农翻身","categories":[{"name":"数据库","slug":"数据库","permalink":"https://coderunning.fun/categories/数据库/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://coderunning.fun/tags/MySQL/"}]},{"title":"LeetCode 24. Swap Nodes in Pairs","slug":"leetcode/linkedlist/SwapPairs","date":"2020-01-15T12:29:41.000Z","updated":"2020-04-24T15:03:26.673Z","comments":true,"path":"2020/01/15/leetcode/linkedlist/SwapPairs/","link":"","permalink":"https://coderunning.fun/2020/01/15/leetcode/linkedlist/SwapPairs/","excerpt":"Given a linked list, swap every two adjacent nodes and return its head. You may not modify the values in the list’s nodes, only nodes itself may be changed.","text":"Given a linked list, swap every two adjacent nodes and return its head. You may not modify the values in the list’s nodes, only nodes itself may be changed. Example: Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3. 思路题意为两两交换链表中的元素，不能改变链表的值， 而是要交换链表结点； 具体思路： cur为待交换结点的前一个结点，用于链接交换后的结点;当两个结点交换完毕后， cur指向下一次待交换两个结点的前一个结点; 示意图如下： 代码12345678910111213141516171819class Solution &#123; public ListNode swapPairs(ListNode head) &#123; if (head == null || head.next == null) &#123; return head; &#125; ListNode dummyHead = new ListNode(-1); dummyHead.next = head; ListNode cur = dummyHead; while (cur.next != null &amp;&amp; cur.next.next != null) &#123; ListNode first = cur.next; ListNode second = first.next; first.next = second.next; second.next = first; cur.next = second; cur = first; &#125; return dummyHead.next; &#125;&#125;","categories":[{"name":"每周一题","slug":"每周一题","permalink":"https://coderunning.fun/categories/每周一题/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://coderunning.fun/tags/leetcode/"},{"name":"linkedlist","slug":"linkedlist","permalink":"https://coderunning.fun/tags/linkedlist/"}]},{"title":"代理模式","slug":"design-pattern/代理模式","date":"2019-12-21T03:16:26.000Z","updated":"2020-04-24T15:03:26.659Z","comments":true,"path":"2019/12/21/design-pattern/代理模式/","link":"","permalink":"https://coderunning.fun/2019/12/21/design-pattern/代理模式/","excerpt":"在国内时访问谷歌， 就是标准的代理模式。 通过VPN进行科学上网， VPN就是一个代理","text":"在国内时访问谷歌， 就是标准的代理模式。 通过VPN进行科学上网， VPN就是一个代理 什么是代理模式给某一个对象提供一个代理，并由代理对象来控制对真实对象的访问。 代理模式场景描述： 当我们想要隐藏某个类时，可以为其提供代理类； 当一个类需要对不同的调用者提供不同的调用权限时，可以使用代理类来实现（代理类不一定只有一个，我们可以建立多个代理类来实现，也可以在一个代理类中进行权限判断来进行不同权限的功能调用）； 当我们要扩展某个类的某个功能时，可以使用代理模式，在代理类中进行简单扩展（只针对简单扩展，可在引用委托类的语句之前与之后进行）。 代理模式组成抽象对象: Subject目标对象: RealSubject, 委托类代理对象: ProxySubject, 代理类 代理模式UML 举例举个例子， 常见的对用户信息的查询、更新操作首先定义UserService(Subject)接口， 接口中有两个方法 1234public interface UserService &#123; public void select(); public void update();&#125; 接着定义UserServiceImpl(RealSubject), 实现UserService接口 12345678910public class UserServiceImpl implements UserService &#123; @Override public void select() &#123; System.out.println(\"select by name!\"); &#125; @Override public void update() &#123; System.out.println(\"update by id!\"); &#125;&#125; 将通过代理对访问 UserServiceImpl 时进行控制，在调用 select 和 update 之前打印日志 1234567891011121314151617181920212223242526272829public class UserServiceProxy implements UserService &#123; private UserService realSubject; public UserServiceProxy(UserService realSubject) &#123; this.realSubject = realSubject; &#125; @Override public void select() &#123; befor(); realSubject.select(); after(); &#125; @Override public void update() &#123; befor(); realSubject.update(); after(); &#125; private void before() &#123; System.out.println(String.format(\"log start time [%s] \", new Date())); &#125; private void after() &#123; System.out.println(String.format(\"log end time [%s] \", new Date())); &#125;&#125; 客户端发起调用： 12345678910public class Client &#123; public static void main(String[] args) &#123; UserService proxyUserService = new UserServiceProxy(new UserServiceImpl()); proxyUserService.select(); proxyUserService.update(); &#125;&#125; 输出结果： log start time [Mon Dec 16 18:21:29 CST 2019] select by name! log end time [Mon Dec 16 18:21:29 CST 2019] log start time [Mon Dec 16 18:21:29 CST 2019] update by id! log end time [Mon Dec 16 18:21:29 CST 2019] 通过代理对象UserServiceProxy， 我们对UserServiceImpl进行间接访问， 并且对目标对象的方法执行前后进行了日志打印，而且对代码没有侵入性。 代理模式的特点 代理类与委托类实现同一接口 在委托类中实现功能，在代理类的方法中中引用委托类的同名方法 外部类调用委托类某个方法时，直接以接口指向代理类的实例，这正是代理的意义所在：控制。 存在什么问题刚才例子中我们使用的是静态代理，静态代理已经完美解决了打印日志的问题。但是，如果我们需要对代理类100个方法的都打印方法执行前和执行后，同样的代码至少需要重复100次。 如果再受不同的委托，实现100个代理类，同样的代码也至少需要重复多次。因此，静态代理至少有以下两个局限性问题： 如果同时代理多个类，依然会导致类无限制扩展 如果类中有多个方法，同样的逻辑需要反复实现 这个时候就需要动态代理了，后续的文章会讲到。 代理模式与装饰者模式、适配器模式的区别 装饰者模式相比于代理模式， 不同点在于装饰者为对象增加行为， 代理模式控制对象的访问，让用户通过代理来访问RealSubject， 而不是直接访问。 适配器模式会改变对象适配的接口， 而代理模式实现的是相同的接口 代理模式的应用 日志打印 （如文中举的例子） 事务提交或回退（Web开发中很常见） 权限管理","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://coderunning.fun/categories/设计模式/"}],"tags":[{"name":"结构型模式","slug":"结构型模式","permalink":"https://coderunning.fun/tags/结构型模式/"}]},{"title":"LeetCode 23. Merge k Sorted Lists","slug":"leetcode/linkedlist/MergeKLists","date":"2019-12-18T14:53:55.000Z","updated":"2020-04-24T15:03:26.669Z","comments":true,"path":"2019/12/18/leetcode/linkedlist/MergeKLists/","link":"","permalink":"https://coderunning.fun/2019/12/18/leetcode/linkedlist/MergeKLists/","excerpt":"Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.","text":"Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity. ExampleInput: [ 1-&gt;4-&gt;5, 1-&gt;3-&gt;4, 2-&gt;6 ] Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6思路LeetCode hard难度题， 看到这道题我的第一思路是链表两两比较生成新的链表， 再将新的链表与剩余的链表进行比较生成新的链表，这个思路也是可行的， 但是效率不高， 具体代码如下： 12345678910public ListNode mergeKLists(ListNode[] lists) &#123; if(lists.length == 0) return null; if(lists.length == 1) return lists[0]; ListNode newList = mergeTwoLists(lists[0], lists[1]); for(int i=2; i&lt;lists.length; i++) &#123; newList = mergeTwoLists(newList, lists[i]); &#125; return newList;&#125; mergeTwoLists(ListNode l1, ListNode l2); 参见合并两个有序联链表 算法复杂度 k * n， ac结果如下： 新的思路利用优先级队列的排序功能， 每次队列中的结点都是有序的 新建一个队列， 依次存入链表数组lists中所有链表的头结点； 创建虚拟头结点dummyHead； 队列弹出元素（始终是队列中最小的元素）, 链接到现有的链表上； 判断当前元素的下一个结点是否为空， 不为空插入到优先级队列中（此时会继续调整队列顺序）； 重复之前的步骤， 直到队列为空。 示意图如下： 代码12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123; public ListNode mergeKLists(ListNode[] lists) &#123; if (lists == null || lists.length == 0) &#123; return null; &#125; // 创建优先级队列 PriorityQueue&lt;ListNode&gt; queue = new PriorityQueue&lt;ListNode&gt;(lists.length, new Comparator&lt;ListNode&gt;() &#123; @Override public int compare(ListNode o1, ListNode o2) &#123; if(o1.val &lt; o2.val) &#123; return -1; &#125; else if(o1.val &gt; o2.val)&#123; return 1; &#125; else &#123; return 0; &#125; &#125; &#125;); // 所有链表的头结点插入优先级队列 for(ListNode node : lists) &#123; if(node != null) &#123; queue.add(node); &#125; &#125; // 构建新的链表 ListNode dummyHead = new ListNode(-1); ListNode tail = dummyHead; while(!queue.isEmpty()) &#123; tail.next = queue.poll(); tail = tail.next; if(tail.next != null) &#123; queue.add(tail.next); &#125; &#125; return dummyHead.next; &#125;&#125; 可以看下优化后的方法的ac结果， 相比之前快了很多：","categories":[{"name":"每周一题","slug":"每周一题","permalink":"https://coderunning.fun/categories/每周一题/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://coderunning.fun/tags/leetcode/"},{"name":"linkedlist","slug":"linkedlist","permalink":"https://coderunning.fun/tags/linkedlist/"}]},{"title":"LeetCode 21. Merge Two Sorted Lists","slug":"leetcode/linkedlist/MergeTwoLists","date":"2019-12-17T14:42:42.000Z","updated":"2020-04-24T15:03:26.672Z","comments":true,"path":"2019/12/17/leetcode/linkedlist/MergeTwoLists/","link":"","permalink":"https://coderunning.fun/2019/12/17/leetcode/linkedlist/MergeTwoLists/","excerpt":"Merge two sorted linked lists and return it as a new list.The new list should be made by splicing together the nodes of the first two lists.","text":"Merge two sorted linked lists and return it as a new list.The new list should be made by splicing together the nodes of the first two lists. Example Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 思路LeetCode简单难度题， 合并两个有序链表，因为两个链表都是有序的就好办了。 循环遍历两个链表，进行大小比较； 利用临时结点， 将每次较小的结点链接在临时结点之后； 当其中一个链表遍历结束后， 将另一个结点链接到临时结点之后。 代码1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; ListNode dummyHead = new ListNode(-1); ListNode curr = dummyHead; while(l1 != null &amp;&amp; l2 != null) &#123; if(l1.val &lt;= l2.val) &#123; curr.next = l1; l1 = l1.next; &#125; else &#123; curr.next = l2; l2 = l2.next; &#125; curr = curr.next; &#125; if(l1 != null) &#123; curr.next = l1; &#125; if(l2 != null) &#123; curr.next = l2; &#125; return dummyHead.next; &#125;&#125;","categories":[{"name":"每周一题","slug":"每周一题","permalink":"https://coderunning.fun/categories/每周一题/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://coderunning.fun/tags/leetcode/"},{"name":"linkedlist","slug":"linkedlist","permalink":"https://coderunning.fun/tags/linkedlist/"}]},{"title":"LeetCode 19. Remove Nth From End of List","slug":"leetcode/linkedlist/RemoveNthFromEnd","date":"2019-12-09T11:07:58.000Z","updated":"2020-04-24T15:03:26.672Z","comments":true,"path":"2019/12/09/leetcode/linkedlist/RemoveNthFromEnd/","link":"","permalink":"https://coderunning.fun/2019/12/09/leetcode/linkedlist/RemoveNthFromEnd/","excerpt":"Given a linked list, remove the n-th node from the end of list and return its head.","text":"Given a linked list, remove the n-th node from the end of list and return its head. Example Given linked list:1-&gt;2-&gt;3-&gt;4-&gt;5 , and n = 2.After removing the second node from the end, the linked list becomes1-&gt;2-&gt;3-&gt;5. Note: Given n will always be valid. Could you do this in one pass? 思路本题重点在于一次遍历解决问题， 原本的思路是： 先遍历算出链表的长度length 再从head结点移动到第length-n-1个结点 删除第length-n-1结点的下一个结点来解决 但是这样是不符合题意的， 因为遍历了两遍链表。 正确的解题思路，利用三指针（slow, fast, pre）来解决问题： fast指针先遍历n个节点 定义pre结点，位于slow结点之前， slow结点此时指向head结点 pre, slow, fast结点同时移动， 当fast结点为null时， slow结点位于待删除结点 pre结点指向slow结点的下一个结点，即删除倒数第n个节点 示意图 代码123456789101112131415161718192021222324252627282930313233/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public ListNode removeNthFromEnd(ListNode head, int n) &#123; if (head == null) return head; ListNode first = head; ListNode dummyHead = new ListNode(-1); dummyHead.next = head; while (n-- &gt; 0 &amp;&amp; first != null) &#123; first = first.next; &#125; ListNode slow = head; ListNode pre = dummyHead; while (first != null) &#123; pre = slow; slow = slow.next; first = first.next; &#125; pre.next = slow.next; return dummyHead.next;&#125;","categories":[{"name":"每周一题","slug":"每周一题","permalink":"https://coderunning.fun/categories/每周一题/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://coderunning.fun/tags/leetcode/"},{"name":"linkedlist","slug":"linkedlist","permalink":"https://coderunning.fun/tags/linkedlist/"}]},{"title":"装饰者模式","slug":"design-pattern/装饰者模式","date":"2019-12-07T09:50:05.000Z","updated":"2020-04-24T15:03:26.667Z","comments":true,"path":"2019/12/07/design-pattern/装饰者模式/","link":"","permalink":"https://coderunning.fun/2019/12/07/design-pattern/装饰者模式/","excerpt":"咖啡店中的不同咖啡， 加奶泡、加糖其实就是一种装饰者模式。","text":"咖啡店中的不同咖啡， 加奶泡、加糖其实就是一种装饰者模式。 什么是装饰者模式动态地给一个对象添加一些额外的职责。 使用装饰者模式的动机在于想要给一个对象动态地增加新的职责， 并且不修改原有的类。 举个例子就是咖啡加奶泡， 并不改变咖啡原有的特性。 装饰者模式组成Component: 组件类，装饰者和被装饰者共同的父类，用来定义基本行为。 是一个接口或者抽象类。 ConcreteComponent: 具体组件，即被装饰者。 Decorator: 继承自Component。 ConcreteDecorator: 具体装饰者， 用于扩展ConcreteComponent。 装饰者模式UML注：装饰者和被装饰者对象有相同的超类型，因为装饰者和被装饰者必须是一样的类型，这里利用继承是为了达到类型匹配，而不是利用继承获得行为。 具体例子以星巴克为例子， 提供的菜单中有咖啡（ConcreteComponentA）、星冰乐（ConcreteComponentB）等饮品， 每个人针对每种咖啡又有自己的口味喜好， 比如有的人喜欢加奶泡（ConcreteDecoratorA），有的人喜欢要全糖(ConcreteDecoratorB)， 这里面就对应上了装饰者模式。 首先定义装饰者与被装饰者的超类，Beverage代表饮料，是一个抽象类： 12345678public abstract class Beverage &#123; public abstract double getCost(); public String getDescription() &#123; return \"饮品\"; &#125;&#125; 接下来定义具体的被装饰者Coffee，继承自组件类： 123456789101112public class Coffee extends Beverage &#123; @Override public double getCost() &#123; return 24; &#125; @Override public String getDescription() &#123; return \"一份咖啡\"; &#125;&#125; 接下来定义装饰者，Sugar与被装饰者同样继承自组件类，定义为抽象类，当然也可以定义为普通类： 1234public abstract class Decorator extends Beverage &#123; public abstract double getCost(); public abstract String getDescription();&#125; 以下定义具体的装饰者Whip，Sugar，都继承自抽象装饰者： 123456789101112131415161718192021222324252627282930313233343536373839public class Whip extends Decorator &#123; Beverage beverage; public Whip(Beverage beverage) &#123; this.beverage = beverage; &#125; @Override public double getCost() &#123; return beverage.getCost() + 10; &#125; @Override public String getDescription() &#123; return beverage.getDescription() + \", 奶泡\"; &#125;&#125;public class Sugar extends Decorator &#123; Beverage beverage; public Sugar(Beverage beverage) &#123; this.beverage = beverage; &#125; @Override public double getCost() &#123; return beverage.getCost() + 5.5; &#125; @Override public String getDescription() &#123; return beverage.getDescription() + \", 一份糖\"; &#125;&#125; 然后根据不同的组合计算价格： 1234567891011121314151617public class StarBucks &#123; public static void main(String[] args) &#123; Coffee coffee = new Coffee(); System.out.println(coffee.getDescription() + \", cost: \" + coffee.getCost()); Whip whip = new Whip(coffee); System.out.println(whip.getDescription() + \", cost: \" + whip.getCost()); Sugar sugar = new Sugar(whip); System.out.println(sugar.getDescription() + \", cost: \" + sugar.getCost()); // 以上的代码也可以这样写， 看着像不像Builder模式？ Sugar sugar = new Sugar(new Whip(new Coffee())); System.out.println(sugar.getDescription() + \", cost: \" + sugar.getCost()); &#125;&#125; 输出： 一份咖啡, cost: 24.0 一份咖啡, 奶泡, cost: 34.0 一份咖啡, 奶泡, 一份糖, cost: 39.5 当然， 在咖啡店里不仅能生产咖啡还可以提供奶茶等饮品。所以说ConcreateComponent可以有多个，ConcreateDecorator也可以有多个。 由以上可以看到装饰者模式可以动态地给被装饰者添加新的行为， 在这个例子中我们可以对咖啡进行各种装饰， 加奶泡， 加糖等等操作。 但是来带一个问题，如果我们要添加多种行为时要维护很多类。 透明性要求与半透明装饰者透明性要求客户端在创建被装饰者时不能声明一个ConcreteComponent类型的变量， 而应当声明一个Component类型的变量。 12345Coffee coffee = new Coffee();Whip whip = new Whip(coffee);Sugar sugar = new Sugar(whip); 应该按下面这种写法才满足透明性要求, 饮料： 12345Beverage coffee = new Coffee();Beverage whip = new Whip(coffee);Beverage sugar = new Sugar(whip); 而半透明的装饰者模式是指在具体的装饰者具有自己特有的属性, 例如在Sugar中添加getDouble()方法： 123456789101112131415161718192021222324class Sugar extends Decorator &#123; Beverage beverage; public Sugar(Beverage beverage) &#123; this.beverage = beverage; &#125; @Override public double getCost() &#123; return beverage.getCost() + 5.5; &#125; @Override public String getDescription() &#123; return beverage.getDescription() + \", 一份糖\"; &#125; // 装饰者中加入超类不具有的特性 public String getDouble() &#123; return \"俩份糖\"; &#125;&#125; 调用时 12Sugar sugar = new Sugar(new Whip(new Coffee()));sugar.getDouble(); 半透明模式有点类似于适配器模式， 增强了功能， 但是相比于透明的装饰者模式改变了接口的定义，在具体的装饰者中加入了自己的特性。 装配者模式在JDK应用：InputSream 根据上图可以看出： ● 抽象构件(Component)角色：由InputStream扮演。这是一个抽象类，为各种子类型提供统一的接口。 ● 具体构件(ConcreteComponent)角色：由ByteArrayInputStream、FileInputStream、PipedInputStream、StringBufferInputStream等类扮演。它们实现了抽象构件角色所规定的接口。 ● 抽象装饰(Decorator)角色：由FilterInputStream扮演。它实现了InputStream所规定的接口。 ● 具体装饰(ConcreteDecorator)角色：由几个类扮演，分别是BufferedInputStream、DataInputStream以及不常用到的类、PushbackInputStream。 具体的调用如下： 1new ObjectInputputStream(new BufferedInputputStream(new FileInputputStream( \"io.txt\" ))); 最里层是一个FileInputStream对象，然后把它传递给一个BufferedInputStream对象，经过BufferedInputStream处理，再把处理后的对象传递给了ObjectInputputStream对象进行处理，这个过程其实就是装饰器的组装过程，FileInputStream对象相当于原始的被装饰的对象，而BufferedInputStream对象和DataInputStream对象则相当于装饰器。 总结 装饰者和被装饰者对象有相同的超类型，所以在任何需要原始对象（被装饰者）的场合，都可以用装饰过得对象代替原始对象； 可以用一个或多个装饰者包装一个对象（被装饰者）； 装饰者可以在所委托的装饰者行为之前或之后加上自己的行为，以达到特定的目的； 被装饰者可以在任何时候被装饰，所以可以在运行时动态地、不限量地用你喜欢的装饰者来装饰对象； 装饰者会导致出现很多小对象，如果过度使用，会让程序变得复杂。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://coderunning.fun/categories/设计模式/"}],"tags":[{"name":"结构型模式","slug":"结构型模式","permalink":"https://coderunning.fun/tags/结构型模式/"}]},{"title":"LeetCode 2. Add Two Numbers","slug":"leetcode/linkedlist/AddTwoNumbers","date":"2019-12-02T09:07:23.000Z","updated":"2020-04-24T15:03:26.669Z","comments":true,"path":"2019/12/02/leetcode/linkedlist/AddTwoNumbers/","link":"","permalink":"https://coderunning.fun/2019/12/02/leetcode/linkedlist/AddTwoNumbers/","excerpt":"两链表相加， 以链表形式顺序输出结果","text":"两链表相加， 以链表形式顺序输出结果 You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. Example Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4) Output: 7 -&gt; 0 -&gt; 8 Explanation: 342 + 465 = 807. Input: (1 -&gt; 2 -&gt; 4) + (1 -&gt; 5 -&gt; 6) Output: 2 -&gt; 7 -&gt; 0 -&gt; 1 Explanation: 421 + 651 = 1072. 思路Medium 难度题，两个链表相加， 同步遍历两个链表结点， 将两个节点值的和存储为新结点。 需要考虑三个点： 一是头结点如何处理(利用虚拟结点处理)； 二是结点为空如何处理（空值取0计算）； 三是进位如何处理（进位保存到参与下一节点计算）\u0010\u0010 代码123456789101112131415161718192021222324252627282930313233343536/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public ListNode addTwoNumbers(ListNode head1, ListNode head2) &#123; ListNode dummyHead = new ListNode(-1); ListNode l1 = head1; ListNode l2 = head2; ListNode s = dummyHead; int carry = 0, sum = 0; while (l1 != null || l2 != null) &#123; int x = (l1 == null ? 0 : l1.val); int y = (l2 == null ? 0 : l2.val); sum = carry + x + y; s.next = new ListNode(sum % 10); s = s.next; carry = sum / 10; if (l1 != null) l1 = l1.next; if (l2 != null) l2 = l2.next; &#125; if (carry != 0) &#123; s.next = new ListNode(carry); &#125; return dummyHead.next;&#125;","categories":[{"name":"每周一题","slug":"每周一题","permalink":"https://coderunning.fun/categories/每周一题/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://coderunning.fun/tags/leetcode/"},{"name":"linkedlist","slug":"linkedlist","permalink":"https://coderunning.fun/tags/linkedlist/"}]},{"title":"Adapter模式","slug":"design-pattern/Adapter模式","date":"2019-11-30T07:34:56.000Z","updated":"2020-04-24T15:03:26.657Z","comments":true,"path":"2019/11/30/design-pattern/Adapter模式/","link":"","permalink":"https://coderunning.fun/2019/11/30/design-pattern/Adapter模式/","excerpt":"联想到日常生活中的适配器， 来看下程序设计中的适配器模式是什么样的","text":"联想到日常生活中的适配器， 来看下程序设计中的适配器模式是什么样的 什么是适配器模式 将一个目前自己不能使用的类，通过适配器进行包装，得到我们想要的功能 适配器组成源角色（Adaptee）： 需要适配的类适配器（Adapter）：把源角色转换成目标接口目标（Target）： 客户所期待的接口Client：… 适配器uml 通过uml图可以看到，适配器可以将Target一个类的接口变换成客户端所期待的另一种接口，从而使原本接口不匹配而无法在一起工作的两个类能够在一起工作。也有人把这种模式叫做包装（Wrapper）模式。 具体例子类适配器模式12345678910111213141516171819202122232425262728293031323334353637383940public class Client &#123; public static void main(String[] args) &#123; ITiger flyTiger = new FlyTiger(\"飞天虎\"); flyTiger.eat(); &#125;&#125;interface ITiger &#123; void eat();&#125;class Falcon &#123; private String name; public Falcon(String name) &#123; this.name = name; &#125; public void fly() &#123; System.out.printf(\"%s 会飞！\\n\", this.name); &#125;&#125;class FlyTiger extends Falcon implements ITiger &#123; private String name; public FlyTiger(String name) &#123; super(name); this.name = name; &#125; @Override public void eat() &#123; this.fly(); System.out.printf(\"%s 要吃肉！\\n\", this.name); &#125;&#125; 输出: 12飞天虎 会飞！飞天虎 要吃肉！ 看一下类适配器的结构 对象适配器模式1234567891011121314151617181920212223242526272829303132public class Client &#123; public static void main(String[] args) &#123; ITiger flyTiger = new FlyTiger(); flyTiger.eat(); &#125;&#125;interface ITiger &#123; void show();&#125;class Falcon &#123; public Falcon() &#123; &#125; public void fly() &#123; System.out.printf(\"我会飞！\\n\"); &#125;&#125;class FlyTiger implements ITiger &#123; private Falcon falcon = new Falcon(); public FlyTiger() &#123; &#125; @Override public void show() &#123; falcon.fly(); &#125;&#125; 看一下对象适配器的结构 类装配器与对象适配器的区别类适配器模式优点： 使用方便， 代码简单 只需引用一个字段，不需要额外的字段引用Adaptee实例 缺点： 高耦合，灵活性差 使用继承 对象适配器模式优点： 灵活性高、低耦合 采用组合， 而非继承 缺点:： 复杂 需要引入对象 总结 需要重新定义Adaptee时， 采用类适配器; 需要同时使用源类和其子类时采用对象适配器; 建议多使用组合（对象适配器），少使用继承（类适配器） 使用场景 系统复用现有的类， 当该类的接口不满足当前需求时， 利用适配器可以使得原本不兼容的接口一起工作 多个组件类似， 但接口不同意需要经常来回切换， 使用适配器模式可以让客户端统一调通， 节约成本 JDK中的应用1234567java.util.Arrays#asList()//InputStreamReader 继承了Readr类，但要创建它的对象必须在构造函数中传入一个InputStream）(InputStream→Reader 字节到字符)java.io.InputStreamReader// 同理 OutputStreamWriterjava.io.OutputStreamWriter(OutputStream)","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://coderunning.fun/categories/设计模式/"}],"tags":[{"name":"结构型模式","slug":"结构型模式","permalink":"https://coderunning.fun/tags/结构型模式/"}]},{"title":"外观模式","slug":"design-pattern/外观模式","date":"2019-11-22T07:52:53.000Z","updated":"2020-04-24T15:03:26.660Z","comments":true,"path":"2019/11/22/design-pattern/外观模式/","link":"","permalink":"https://coderunning.fun/2019/11/22/design-pattern/外观模式/","excerpt":"当你打开了hao123.com访问你喜好的网站时， 这个时候就用到了外观模式！","text":"当你打开了hao123.com访问你喜好的网站时， 这个时候就用到了外观模式！ 什么是Facade模式对外提供一个统一的接口， 外部通过这一个统一的接口对内部子系统接口进行访问 举个网站的导航例子你就懂了：每个用户上网时需要在记住每个需要浏览的网站的地址；有了hao123网站导航（用了外观模式）后，就方便了很多。 Facade模式组成外观角色: Facade子系统: SubSystem客户端: Client Facade模式UML Facade模式举例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class FacadeDemo &#123; public static void main(String[] args) &#123; Facade facade = new Facade(new Light(), new TV(), new AirCondition()); facade.turnOn(); facade.turnOff(); &#125;&#125;class Light &#123; public void lightOn() &#123; System.out.println(\"打开灯！\"); &#125; public void lightOff() &#123; System.out.println(\"把灯关了！\"); &#125;&#125;class TV &#123; public void tvOn() &#123; System.out.println(\"打开电视！\"); &#125; public void tvOff() &#123; System.out.println(\"把电视关了！\"); &#125;&#125;class AirCondition &#123; public void airConditionOn() &#123; System.out.println(\"打开空调！\"); &#125; public void airConditionOff() &#123; System.out.println(\"把空调关了！\"); &#125;&#125;class Facade &#123; Light light; TV tv; AirCondition airCondition; Facade(Light light, TV tv, AirCondition airCondition) &#123; this.light = light; this.tv = tv; this.airCondition = airCondition; &#125; public void turnOn() &#123; light.lightOn(); tv.tvOn(); airCondition.airConditionOn(); &#125; public void turnOff() &#123; light.lightOff(); tv.tvOff(); airCondition.airConditionOff(); &#125;&#125; 输出： 123456打开灯！打开电视！打开空调！把灯关了！把电视关了！把空调关了！ Facade模式优缺点优点 对客户屏蔽了子系统组件， 主需要调用facade即可 解耦， 子系统与客户端的解耦， 子系统的变化不会影响到客户端， 子系统变化时只需更新facade 提供访问子系统的入口，不影响客户端直接使用子系统类 缺点 违背开闭原则， 不引入抽象外观类的情况下，增加新的子系统需要修改外观类或客户端的源码 Facade模式应用场景 为一个复杂系统提供一个简单的接口 增加子系统的独立性 客户端与多个子系统有很强的依赖性","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://coderunning.fun/categories/设计模式/"}],"tags":[{"name":"结构型模式","slug":"结构型模式","permalink":"https://coderunning.fun/tags/结构型模式/"}]},{"title":"建造者模式","slug":"design-pattern/建造者模式","date":"2019-11-06T06:56:25.000Z","updated":"2020-04-24T15:03:26.662Z","comments":true,"path":"2019/11/06/design-pattern/建造者模式/","link":"","permalink":"https://coderunning.fun/2019/11/06/design-pattern/建造者模式/","excerpt":"建造者模式让创建的流程统一， 针对不同的请求， 建造出不同的产品","text":"建造者模式让创建的流程统一， 针对不同的请求， 建造出不同的产品 什么是建造者模式 不关心产品构建的过程， 只关心结果将一个复杂对象的创建与具体部位创建分离，使得同样的构建过程可以创建不同的具体部位，比如电脑的各个部件。 建造者模式可以将一个产品的部件的生成过程和其组装过程分开，一步一步创建一个复杂的对象 用户只需要指定复杂对象的类型就可以得到该对象，而无须知道其内部的具体构造细节 建造者模式组成 抽象建造者(Builder) 具体建造者(ConcreteBuilder) 具体产品(ConcreteProduct) 指挥类（Director,隔离了客户与生产过程；控制产品的生成过程） 建造者模式uml 建造者模式举例中关村电脑装机小明（Client）要一台可以流畅吃鸡的游戏主机(Product)， 店老板(Director)让小美(Builder)去配置店老板针对不同的人、不同的配置分别让小美或者其他装机员去装机， 但是装机流程是一样的， 这就是一个典型的建造者模式 具体代码 123456789101112public interface Builder &#123; void createMainBoard(String mainBoard); void createCPU(String cpu); void createHardDisk(String hardDisk); void createMemory(String memory); Computer createComputer();&#125; 123456789101112131415161718192021222324252627282930// AssembleComputerBuilder类， 每个具体的Builder在细节实现上可以不同public class AssembleComputerBuilder implements Builder &#123; Computer computer = new Computer(); @Override public void createMainBoard(String mainBoard) &#123; computer.setMainBoard(mainBoard); &#125; @Override public void createCPU(String cpu) &#123; computer.setCpu(cpu); &#125; @Override public void createHardDisk(String hardDisk) &#123; computer.setHardDisk(hardDisk); &#125; @Override public void createMemory(String memory) &#123; computer.setMemory(memory); &#125; @Override public Computer createComputer() &#123; return computer; &#125;&#125; 12345678910111213141516public class Director &#123; private Builder builder; public Director(Builder builder) &#123; this.builder = builder; &#125; public Computer createGameComputer(String mainBoard, String cpu, String memory, String hardDisk) &#123; builder.createCPU(cpu); builder.createHardDisk(hardDisk); builder.createMainBoard(mainBoard); builder.createMemory(memory); return builder.createComputer(); &#125;&#125; 1234567public class Computer &#123; private String cpu ; private String hardDisk ; private String mainBoard ; private String memory ;&#125; 12345678910public class Client &#123; public static void main(String[] args) &#123; Builder builder = new AssembleComputerBuilder(); Director director = new Director(builder); Computer computer = director.createComputer(\"技嘉B360\", \"Intel-9400F\", \"Hyper 8G\", \"希捷 2T\"); System.out.println(computer.toString()); &#125;&#125; 疑问1Computer computer = director.createComputer(\"技嘉B360\", \"Intel-9400F\", \"Hyper 8G\", \"希捷 2T\"); 如果Computer类不止mainBoard，cpu, memory, hardDisk这四个参数时，还有networkCard, soundCard等属性时，我们还要在一个构造函数中写入n多参数 1Computer computer = director.createComputer(\"技嘉B360\", \"Intel-9400F\", \"Hyper 8G\", \"希捷 2T\", \"networkCard\", \"soundCard\", \"xxx\"); 遇到这种参数很多的情况，也许有人会在Director重叠构造器 1public Computer createGameComputer(String mainBoard, String cpu, String memory, String hardDisk, String xxx, String xxx) &#123; 但是重叠构造器有以下缺点 层层嵌套，代码不灵活 不优雅 如果增加参数那就是噩梦 改进方案，简化版Builder，支持链式调用， 不再需要Director1234567891011121314151617181920212223242526272829303132333435363738public class Computer &#123; private String cpu ; private String hardDisk ; private String mainBoard ; private String memory ; private String networkCard ; private String soundCard ; // 引入Builder public static class Builder &#123; private String cpu ; private String hardDisk ; private String mainBoard ; private String memory ; private String networkCard ; private String soundCard ; public Builder cpu(String cpu) &#123; this.cpu = cpu; return this; &#125; public Builder hardDisk(String cpu) &#123; this.hardDisk = hardDisk; return this; &#125; public Builder mainBoard(String cpu) &#123; this.mainBoard = mainBoard; return this; &#125; //... 网卡、声卡等其他组件构造略 Computer build() &#123; return new Computer(this); &#125; &#125; &#125; 这样我们就可以这样创建 Computer 对象： 1Computer computer = new Computer.Builder().cpu(\"Intel-9400F\").mainBoard(\"技嘉360主板\").graphics(\"Nvida 显卡\").hardDisk(\"希捷2t硬盘\"). networkCard(\"千兆网卡\").soundCard(\"高保真声卡\").build(); 这样即便在属性很多时代码看起来也很简洁，当然这种链式调用也存在一定缺点，比如： 每次创建外部类对象，都需要再创建一个内部类，所以需要消耗更多的内存 每个属性要同时在内部类和外部类中定义 建造者模式优缺点 优点 易于解耦，产品本身与创建过程进行解耦， 相同的创建过程得到不同的产品 更精细地控制创建过程，将复杂产品的创建步骤分解到不同方法中， 创建过程更清晰 易于拓展， 增加新的具体建造者无需修改原有类库，符合开闭原则 缺点 要求所建造的产品有许多的相同点， 组成部分相似， 没办法让电脑装机店去盖房子 产品内部变化复杂， 可能会需要很多具体建造者实现这种变化 建造者模式使用场景 需要生成的产品对象有复杂的内部结构，这些产品对象具备多个相同的成员属性； 隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品。 需要生成的产品对象的属性相互依赖，需要指定其生成顺序。 建造者模式与工厂模式的区别 工厂模式是将对象的全部创建过程封装在工厂类中，由工厂类向客户端提供最终的产品； 建造者类一般只提供产品类中各个组件的建造，而将具体建造过程交付给导演类。由导演类负责将各个组件按照特定的规则组建为产品，然后将组建好的产品交付给客户端。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://coderunning.fun/categories/设计模式/"}],"tags":[{"name":"创建型模式","slug":"创建型模式","permalink":"https://coderunning.fun/tags/创建型模式/"}]},{"title":"单例模式","slug":"design-pattern/单例模式","date":"2019-10-23T08:42:45.000Z","updated":"2020-04-24T15:03:26.660Z","comments":true,"path":"2019/10/23/design-pattern/单例模式/","link":"","permalink":"https://coderunning.fun/2019/10/23/design-pattern/单例模式/","excerpt":"面试必问的单例模式， 在这做个小小的总结","text":"面试必问的单例模式， 在这做个小小的总结 为什么需要单例模式一个全局使用的类频繁地创建和销毁，减少系统开销 单例模式的特点是什么 只有一个实例 必须自己创建自己的实例（构造函数私有） 必须为所有其他对象提供这一实例 单例模式uml 几种不同的单例模式懒汉式, 线程不安全1234567891011121314151617public class SingletonObject &#123; private static SingletonObject instance; private SingletonObject() &#123; &#125; public static SingletonObject getInstance() &#123; if (instance == null) &#123; instance = new SingletonObject(); &#125; return instance; &#125;&#125;// 可以加锁带到线程安全的目的， 但会影响到效率public static synchronized SingletonObject getInstance() 饿汉式类装载时就初始化 123456789101112public class SingletonObject &#123; private static SingletonObject instance = new SingletonObject(); private SingletonObject() &#123; &#125; public static SingletonObject getInstance() &#123; return instance; &#125;&#125; DCL,双重锁监测1234567891011121314151617public class SingletonObject &#123; private volatile static SingletonObject singleton; private SingletonObject ()&#123;&#125; public static SingletonObject getSingleton() &#123; if (singleton == null) &#123; synchronized (SingletonObject.class) &#123; if (singleton == null) &#123; singleton = new SingletonObject(); &#125; &#125; &#125; return singleton; &#125; &#125; 私有内部类使用静态内部类，既可以实现延迟加载， 又可以保证多线程安全，不影响性能 123456789101112public class SingletonObject &#123; private static class SingletonHolder &#123; private static final SingletonObject INSTANCE = new SingletonObject(); &#125; private SingletonObject ()&#123;&#125; public static final SingletonObject getInstance() &#123; return SingletonHolder.INSTANCE; &#125; &#125; 枚举私有内部类不能避免反序列化重新创建新的对象， 无法保证对象的唯一性 123public enum Singleton &#123; INSTANCE;&#125; JVM 会阻止反射获取枚举类的私有构造方法。 单例模式的优点 单例模式提供了对唯一实例的受控访问。因为单例类封装了它的唯一实例，所以它可以严格控制客户怎样以及何时访问它。由于在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象单例模式无疑可以提高系统的性能。允许可变数目的实例。基于单例模式我们可以进行扩展，使用与单例控制相似的方法来获得指定个数的对象实例，既节省系统资源，又解决了单例单例对象共享过多有损性能的问题。 单例模式的不足 没有借口， 不能被继承。 自身既是工厂又是产品， 违反了单一职责原则。单例类的职责过重，在一定程度上违背了“单一职责原则”。因为单例类既充当了工厂角色，提供了工厂方法，同时又充当了产品角色，包含一些业务方法，将产品的创建和产品的本身的功能融合到一起。面向对象语言(如Java、C#)的运行环境都提供了自动垃圾回收的技术，因此，如果实例化的共享对象长时间不被利用，系统会认为它是垃圾，会自动销毁并回收资源，下次利用时又将重新实例化，这将导致共享的单例对象状态的丢失。 单例模式具体应用系统只需要一个实例对象，如系统要求提供一个唯一的序列号生成器或资源管理器，或者需要考虑资源消耗太大而只允许创建一个对象。客户调用类的单个实例只允许使用一个公共访问点，除了该公共访问点，不能通过其他途径访问该实例。 java.lang.Runtime，在每一个Java应用程序里面，都有唯一的一个Runtime对象，应用程序可以与其运行环境发生相互作用。 1public static Runtime getRuntime();","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://coderunning.fun/categories/设计模式/"}],"tags":[{"name":"创建型模式","slug":"创建型模式","permalink":"https://coderunning.fun/tags/创建型模式/"}]},{"title":"抽象工厂","slug":"design-pattern/抽象工厂","date":"2019-10-17T11:00:43.000Z","updated":"2020-04-24T15:03:26.663Z","comments":true,"path":"2019/10/17/design-pattern/抽象工厂/","link":"","permalink":"https://coderunning.fun/2019/10/17/design-pattern/抽象工厂/","excerpt":"抽象工厂相比于工厂方法模式的不同在于，一个抽象工厂可以创建多个不同的产品","text":"抽象工厂相比于工厂方法模式的不同在于，一个抽象工厂可以创建多个不同的产品 引申概念 产品等级结构: 产品的继承结构， 抽象类是键盘，子类就是hp键盘，罗技键盘，抽象的键盘与具体的键盘产品构成了一个产品等级，抽象键盘是父类，具体的键盘是子类产品族: 产品族指的是同一个工厂生产的， 位于不同产品等级的一组产品， 例如hp生产的键盘、鼠标是同一产品族，而键盘位于键盘产品等级，鼠标位于鼠标产品等级中 抽象工厂结构AbstractFactory: 抽象工厂ContreteFactory: 具体工厂AbstractProduct: 抽象产品ContreteProduct: 具体产品 抽象工厂uml 抽象工厂特点 抽象工厂模式与工厂方法模式最大的区别：而工厂方法每个工厂只能创建一类产品，抽象工厂中每个工厂可以创建多种产品； 抽象工厂解决的问题 解决了每个工厂只能创建一类产品的问题-即解决了工厂模式的缺点， 当一个工厂中能生产多种产品等级的产品时，此时抽象工厂比工厂模式效率高 123456789101112131415PcFactory dellFactory = new DellFactory();// create dell productKeyBoard dellKeyBoard = dellFactory.createKeyBoard();Mouse dellMouse = dellFactory.createMouse();// usedellKeyBoard.type();dellMouse.click();PcFactory hpFactory = new HpFactory();// create hp productKeyBoard hpKeyBoard = hpFactory.createKeyBoard();Mouse hpMouse = hpFactory.createMouse();// usehpKeyBoard.type();hpMouse.click(); 抽象工厂优点 降低耦合， 将具体产品的创建延迟到具体工厂的子类中去， 减少客户端与具体产品之间的依赖 更符合开闭原则，需要新增具体的产品族和相应的工厂即可，无需修改原有的系统 增加新的工厂和产品族很方便， 无需修改已有的系统，符合开闭原则 不足 违抽象工厂中已经确定了被创建的产品的组合，新增产品种类时， 需要修改抽象工厂的接口以及其所有子类， 带来不便 开闭原则的倾斜性， 增加工厂和产品族容易， 增加新的产品等级结构麻烦 应用场景 一个系统不依赖于产品实例如何被创建、组合等细节 系统中有多个产品族，每次只使用其中一个产品族 属于同一个产品族的产品在一起使用 具体应用 系统更换主题时， 界面的按钮、文本、背景等一起发生改变 深色模式下的按钮、文本、背景属于一个产品族， 抽象的按钮与具体的按钮构成一个产品等级 公司在采购时， 采购了DELL公司的电脑、鼠标、键盘， 等下个季度采购HP公司的产品","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://coderunning.fun/categories/设计模式/"}],"tags":[{"name":"创建型模式","slug":"创建型模式","permalink":"https://coderunning.fun/tags/创建型模式/"}]},{"title":"工厂方法","slug":"design-pattern/工厂方法","date":"2019-10-17T10:59:51.000Z","updated":"2020-04-24T15:03:26.661Z","comments":true,"path":"2019/10/17/design-pattern/工厂方法/","link":"","permalink":"https://coderunning.fun/2019/10/17/design-pattern/工厂方法/","excerpt":"工厂方法相比于简单工厂解决了哪些问题？","text":"工厂方法相比于简单工厂解决了哪些问题？ 工厂模式结构Product: 抽象产品ConcreteProduct: 具体产品Factory: 抽象工厂ConcreteFactory: 具体工厂 工厂模式uml图 工厂模式特点 将实例的创建延迟到具体的工厂中去完成， 由子类决定实例化哪个类 工厂模式解决的问题 解决了简单工厂带来的问题：新增产品时需要修改工厂类的逻辑。 工厂类不再负责创建产品， 而是由具体工厂去实现， 具体的工厂实现工厂类中创建产品的接口 12345678910// 工厂中创建产品class SquareFactory implements ShapeFactory &#123; Shape getShape() &#123; return new Square(); &#125;&#125;// 调用时ShapeFactory squareFactory = new SquareFactory();Shape square = squareFactory.getShape();square.draw(); 工厂方法模式优点 更符合开闭原则， 新增产品时只需要新增产品类以及相应的工厂子类,无需更改提供抽象产品的接口， 对应的简单工厂需要修改工厂类的逻辑 单一职责， 工厂只负责创建产品，客户端无需关心产品创建的细节， 只需要知道需要具体的工厂即可， 而简单工厂还需要判断创建何种产品 工厂方法模式缺点 新增产品除了新增产品类， 还需要新增具体的工厂类， 系统类成对增加， 复杂度上升 一个具体的工厂只能创建一种产品 应用场景 客户不需要关心具体的产品， 只需要知道对应的工厂就好了 一个类通过其子类指定创建哪个对象，抽象工厂类提供一个创建产品的接口由子类来确定具体要创建的产品 可以将要创建的工厂类进行配置（数据库或者配置文件）， 在需要具体工厂时再动态指定 应用1JDBC connection, 通过JDBC.properties获取数据库dirver信息， 使用oracle或者mysql 参考JDBC源码解析","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://coderunning.fun/categories/设计模式/"}],"tags":[{"name":"创建型模式","slug":"创建型模式","permalink":"https://coderunning.fun/tags/创建型模式/"}]},{"title":"简单工厂","slug":"design-pattern/简单工厂","date":"2019-10-17T10:58:30.000Z","updated":"2020-04-24T15:03:26.667Z","comments":true,"path":"2019/10/17/design-pattern/简单工厂/","link":"","permalink":"https://coderunning.fun/2019/10/17/design-pattern/简单工厂/","excerpt":"简单工厂是平时使用最多的工厂模式， 一种特殊的工厂方法模式","text":"简单工厂是平时使用最多的工厂模式， 一种特殊的工厂方法模式 应用场景 软件系统需要提供多个外观不同的按钮（圆形，菱形，三角形的按钮等）， 这些按钮都继承自同一个形状类，继承后通过修改部分属性就可呈现不同外观，当我们使用按钮时， 不需要关注具体的按钮类的名称， 只需要知道改按钮类的名称，提供一个调用的方法， 把该参数传入方法即可得到相应的按钮对象 简单工厂的结构Factory: 工厂角色。负责实现和创建实例的内部逻辑Product: 抽象产品角色。创建的所有对象的父类，描述所有实例的通用接口ConcreteProduct: 具体产品 简单工厂的uml图 没有工厂时12Shape rectangle = new Rectangle();Shape square = new Square(); 有工厂时：12Shape rectangle = ShapeFactory.getShape(\"rectangle\");Shape square = ShapeFactory.getShape(\"square\"); 1234567891011public static Shape getShape(String shapeName) &#123; if(shapeName == null) &#123; return null; &#125; if(shapeName.equals(\"rectangle\")) &#123; return new Rectangle(); &#125; else if(shapeName.equals(\"square\")) &#123; return new Square(); &#125; return null;&#125; 简单工厂的优点： 将创建实例与使用实例分开， 进行解耦， 使使用者不关心对象如何创建， 实现了解耦初始化实例的工作放在工厂中进行， 代码更容易维护，面向接口编程 简单工厂的缺点： 简单工厂集合了所有实例的创建逻辑，一旦新增新的产品就不得不修改工厂的逻辑，整个系统受到影响，违背了开闭原则 简单工厂使用了静态方法， 不能被继承和重写 应用场景 工厂类创建的对象比较少， 不会造成工厂方法中的业务逻辑过于复杂 客户端只知道传入工厂类的参数，对如何创建对象不关心，甚至连产品的类名都不需要记住， 只需要记住对应的参数即可 应用12public final static DateFormat getDateInstance(int style);KeyGenerator keyGen = KeyGenerator.getInstance(\"DESede\");","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://coderunning.fun/categories/设计模式/"}],"tags":[{"name":"创建型模式","slug":"创建型模式","permalink":"https://coderunning.fun/tags/创建型模式/"}]}],"categories":[{"name":"每周一题","slug":"每周一题","permalink":"https://coderunning.fun/categories/每周一题/"},{"name":"设计模式","slug":"设计模式","permalink":"https://coderunning.fun/categories/设计模式/"},{"name":"数据库","slug":"数据库","permalink":"https://coderunning.fun/categories/数据库/"},{"name":"建站","slug":"建站","permalink":"https://coderunning.fun/categories/建站/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://coderunning.fun/tags/leetcode/"},{"name":"linkedlist","slug":"linkedlist","permalink":"https://coderunning.fun/tags/linkedlist/"},{"name":"结构型模式","slug":"结构型模式","permalink":"https://coderunning.fun/tags/结构型模式/"},{"name":"行为型模式","slug":"行为型模式","permalink":"https://coderunning.fun/tags/行为型模式/"},{"name":"MySQL","slug":"MySQL","permalink":"https://coderunning.fun/tags/MySQL/"},{"name":"博客搭建","slug":"博客搭建","permalink":"https://coderunning.fun/tags/博客搭建/"},{"name":"创建型模式","slug":"创建型模式","permalink":"https://coderunning.fun/tags/创建型模式/"}]}