<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>模板方法模式</title>
      <link href="/2020/05/07/design-pattern/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/05/07/design-pattern/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>模板方法模式的核心其实还是面向对象设计的体现: 封装、继承、多态。</p><a id="more"></a><h1 id="什么是模板方法模式"><a href="#什么是模板方法模式" class="headerlink" title="什么是模板方法模式"></a>什么是模板方法模式</h1><p>模板方法模式（Template Method）， 公开定义一个算法结构，将一些步骤的具体实现延迟到子类。模板方法模式使得子类可以不改变算法结构即可重新定义该算法的某些步骤。模板方法模式属于对象行为模式。</p><h1 id="模板方法模式组成"><a href="#模板方法模式组成" class="headerlink" title="模板方法模式组成"></a>模板方法模式组成</h1><p><strong>AbstractTemplate</strong>: 抽象模板角色，定义一组基本方法供子类实现，定义并实现组合了基本方法的模板方法。</p><p><strong>ConcreteTemplate</strong>: 具体模板角色， 实现抽象模板角色定义的一系列基本方法。</p><p><strong>基本方法</strong></p><ul><li><p>抽象方法：由抽象模板角色声明， abstract 修饰， 具体模板角色实现</p></li><li><p>钩子方法：由抽象模板角色声明并实现， 具体模板角色进行扩展。</p></li><li><p>具体方法:  由抽象模板角色声明并实现，private修饰。</p></li></ul><p><strong>模板方法</strong>:  由抽象模板角色声明并实现， final 修饰， 不允许具体角色重写。</p><h1 id="模板方法模式-UML"><a href="#模板方法模式-UML" class="headerlink" title="模板方法模式 UML"></a>模板方法模式 UML</h1><p><img src="/2020/05/07/design-pattern/模板方法模式/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F.png" alt="模板方法模式 UML"></p><h1 id="模板方法模式代码实现"><a href="#模板方法模式代码实现" class="headerlink" title="模板方法模式代码实现"></a>模板方法模式代码实现</h1><p>定义抽象模板</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderProcessTemplate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isGift;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OrderProcessTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        isGift = isGift();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通用方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">giftWrap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"给礼品进行包装"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交给子类扩展的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doSelect</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交给子类扩展的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doPayment</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交给子类扩展的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doDelivery</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// hook method, 子类自行扩展</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isGift</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义的模板方法，设计具体的逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">processOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        doSelect();</span><br><span class="line">        doPayment();</span><br><span class="line">        <span class="keyword">if</span> (isGift) &#123;</span><br><span class="line">            giftWrap();</span><br><span class="line">        &#125;</span><br><span class="line">        doDelivery();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义模板子类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NetOrder</span> <span class="keyword">extends</span> <span class="title">OrderProcessTemplate</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSelect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"线上购物，加入购物车"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPayment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"进行线上支付"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doDelivery</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"根据收货地址进行邮寄"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StoreOrder</span> <span class="keyword">extends</span> <span class="title">OrderProcessTemplate</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSelect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"顾客线下进行选购"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPayment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"顾客线下进行支付，刷卡/现金结算"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doDelivery</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"物品已送至柜台"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isGift</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        OrderProcessTemplate netOrder = <span class="keyword">new</span> NetOrder();</span><br><span class="line">        netOrder.processOrder();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"=================="</span>);</span><br><span class="line">        </span><br><span class="line">        OrderProcessTemplate storeOrder = <span class="keyword">new</span> StoreOrder();</span><br><span class="line">        storeOrder.processOrder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><pre><code>线上购物，加入购物车进行线上支付给礼品进行包装根据收货地址进行邮寄=======================顾客线下进行选购顾客线下进行支付，刷卡/现金结算物品已送至柜台</code></pre><h1 id="模板方法适用场景"><a href="#模板方法适用场景" class="headerlink" title="模板方法适用场景"></a>模板方法适用场景</h1><ul><li>一次性实现算法不变的部分，将可变的行为交给子类实现。</li><li>多个子类具有同样的行为，可以将公共行为抽取，集中到父类中。</li><li>控制子类扩展， 每个子类根据自身特性进行扩展。</li></ul><h1 id="模板方法模式优缺点"><a href="#模板方法模式优缺点" class="headerlink" title="模板方法模式优缺点"></a>模板方法模式优缺点</h1><p>优点：</p><ul><li>提高代码复用性， 相同的代码放在父类。</li><li>提高代码可扩展性，不同的子类具有不同的行为。</li><li>实现反向控制， 父类调用子类进行操作。</li></ul><p>缺点：</p><p>引入抽象类， 每个不同的行为表现都需要一个子类来实现，导致类的个数增加系统也会更庞大。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行为型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中介者模式</title>
      <link href="/2020/05/05/design-pattern/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/05/05/design-pattern/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>当飞机起飞或者着陆时， 如果没有塔台将会发生什么？</p><a id="more"></a><h1 id="什么是中介者模式"><a href="#什么是中介者模式" class="headerlink" title="什么是中介者模式"></a>什么是中介者模式</h1><p>中介者模式（Mediator Pattern）, 将一系列的对象交互封装起来, 使两个模块不需要频繁地相互显式引用， 从而使其松耦合。 中介者模式又称之为调停模式, 是一种对象行为模式。</p><h1 id="为什么使用中介者模式"><a href="#为什么使用中介者模式" class="headerlink" title="为什么使用中介者模式"></a>为什么使用中介者模式</h1><p>通常情况下多个类交互如下图所示，类之间的关系呈网状结构， 当任一对象发生变化时都有可能影响到多个对象，对象间之间关联形成了紧耦合， 这种设计很难做到类的复用， 而且一旦一个类发生变更， 关联的类也需要做相应的修改。</p><p><img src="/2020/05/05/design-pattern/中介者模式/%E7%B4%A7%E8%80%A6%E5%90%88%E4%BA%A4%E4%BA%92.jpg" alt="紧耦合设计"></p><p>如果类之间的交互改成如下的<strong>星型模式</strong>，任何一个类的变动都只会影响到类本身和中介者，其他方是无感知的，这样就减少了类之间的耦合。 中介者模式就是将类之间的逻辑关系抽象出来，维护在中介者中。</p><p><img src="/2020/05/05/design-pattern/中介者模式/%E6%9D%BE%E8%80%A6%E5%90%88%E4%BA%A4%E4%BA%92.jpg" alt="松耦合设计"></p><h1 id="中介者模式组成"><a href="#中介者模式组成" class="headerlink" title="中介者模式组成"></a>中介者模式组成</h1><p><strong>Mediator</strong>: 抽象中介者。定义同事对象到中介的接口。 </p><p><strong>ConcreteMediator</strong>: 具体中介者。实现抽象中介者的方法，需要知道所有的具体同事类， 接收同事类发生的消息。</p><p><strong>Collegue</strong>: 抽象同事类。</p><p><strong>ConcreteCollegue</strong>: 具体同事类。实现抽象同事类的方法， 每个同事类可以有一套属于自己的方法， 但是所有的具体同事类都知晓中介类。</p><h1 id="中介者模式-UML"><a href="#中介者模式-UML" class="headerlink" title="中介者模式 UML"></a>中介者模式 UML</h1><p><img src="/2020/05/05/design-pattern/中介者模式/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F.png" alt="中介者模式 UML"></p><h1 id="中介者模式代码实现"><a href="#中介者模式代码实现" class="headerlink" title="中介者模式代码实现"></a>中介者模式代码实现</h1><p><strong>抽象中介者</strong>, 此处为塔台的抽象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IATCMediator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">registerRunway</span><span class="params">(Runway runway)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">registerFlight</span><span class="params">(Flight flight)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isLandingOk</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setLandingStatus</span><span class="params">(Boolean landingStatus)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>具体中介者</strong>， 塔台的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ATCMediator</span> <span class="keyword">implements</span> <span class="title">IATCMediator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Flight flight;</span><br><span class="line">    <span class="keyword">private</span> Runway runway;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> isLanded;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerRunway</span><span class="params">(Runway runway)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.runway = runway;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerFlight</span><span class="params">(Flight flight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.flight = flight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLandingOk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isLanded;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLandingStatus</span><span class="params">(<span class="keyword">boolean</span> landingStatus)</span> </span>&#123;</span><br><span class="line">        isLanded = landingStatus;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>抽象同事类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">land</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>具体同事类</strong>， 分别是航班（Flight）和跑道（Runway）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Flight</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IATCMediator atcMediator;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Flight</span><span class="params">(IATCMediator atcMediator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.atcMediator = atcMediator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">land</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (atcMediator.isLandingOk()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"successfully landed!"</span>);</span><br><span class="line">            atcMediator.setLandingStatus(<span class="keyword">true</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"Waiting for landing."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getReady</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Ready for landing."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Runway</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IATCMediator atcMediator;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Runway</span><span class="params">(IATCMediator atcMediator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.atcMediator = atcMediator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">land</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Landing permission granted."</span>);</span><br><span class="line">        atcMediator.setLandingStatus(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IATCMediator atcMediator = <span class="keyword">new</span> ATCMediator();</span><br><span class="line"></span><br><span class="line">        Flight flight = <span class="keyword">new</span> Flight(atcMediator);</span><br><span class="line">        Runway runway = <span class="keyword">new</span> Runway(atcMediator);</span><br><span class="line"></span><br><span class="line">        atcMediator.registerFlight(flight);</span><br><span class="line">        atcMediator.registerRunway(runway);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//航班 ready</span></span><br><span class="line">        flight.getReady();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 航班准备着陆</span></span><br><span class="line">        flight.land();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 跑道就位</span></span><br><span class="line">        runway.land();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 着陆</span></span><br><span class="line">        flight.land();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><pre><code>Ready for landing.Waiting for landing.Landing permission granted.successfully landed!</code></pre><h1 id="中介者模式应用场景"><a href="#中介者模式应用场景" class="headerlink" title="中介者模式应用场景"></a>中介者模式应用场景</h1><p>中介者模式适用于：</p><ul><li>系统中对象之间存在复杂的引用关系，系统结构混乱且难以理解。</li><li>一个对象引用了多个对象并直接和这些对象通信， 导致该对象不能复用。</li><li>想通过一个中间类来封装多个类中的行为，而又不想生成过多的子类。在中介类中定义对象交互的公共行为， 如果需要改变行为可以增加新的具体中介类。</li></ul><h1 id="中介者模式优缺点"><a href="#中介者模式优缺点" class="headerlink" title="中介者模式优缺点"></a>中介者模式优缺点</h1><p>优点：</p><ul><li>简化了对象间的交互， 将对象间的交互逻辑进行封装， 将各个同事类进行解耦，使得各个对象相互独立。</li><li>使用中介者模式将对象一对多的关联转变成一对一的关联，增加新的中介者和新的同事类都比较方便，便于维护。</li><li>减少了同事类的设计，将原本分布在多个同事类的方法集中在一起，使得同事类可以被重用， 无需对原有的同事类进行扩展。</li></ul><p>缺点：</p><ul><li>中介者类封装了系统中各个对象之间的相互关系，使得中介者的逻辑非常复杂， 维护成本高。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行为型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>状态模式</title>
      <link href="/2020/04/29/design-pattern/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/04/29/design-pattern/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>当代码中存在大量的 if…else 进行状态判断时状态模式就能派上用场了。</p><a id="more"></a><h1 id="什么是状态模式"><a href="#什么是状态模式" class="headerlink" title="什么是状态模式"></a>什么是状态模式</h1><p>状态模式（State Pattern）属于行为型模式， 类的行为会随着状态的改变而改变。</p><h1 id="状态模式组成"><a href="#状态模式组成" class="headerlink" title="状态模式组成"></a>状态模式组成</h1><p><strong>State</strong>: 抽象类或者接口，是一个具有所有状态的接口。</p><p><strong>ConcreteState</strong>: 具体状态类，实现State接口，处理来自Context的请求。</p><p><strong>Context</strong>: 上下文角色或者环境角色， 串联各个状态。</p><h1 id="状态模式-UML"><a href="#状态模式-UML" class="headerlink" title="状态模式 UML"></a>状态模式 UML</h1><p><img src="/2020/04/29/design-pattern/状态模式/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F.png" alt="状态模式 uml"></p><h1 id="为什么要使用状态模式"><a href="#为什么要使用状态模式" class="headerlink" title="为什么要使用状态模式"></a>为什么要使用状态模式</h1><p>假设现在需要实现一个电风扇， 有四个状态，分别是关闭、低速、中速、高速， 每拉一次绳就变一次速， 接下来我们代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CellingFanChain</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> currentState;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CellingFanChain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        currentState = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 实现风扇的拉绳方法， 分别对四种状态进行处理， 状态之间两两变化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (currentState == <span class="number">0</span>) &#123;</span><br><span class="line">            currentState = <span class="number">1</span>;</span><br><span class="line">            System.out.println(<span class="string">"\t low speed"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (currentState == <span class="number">1</span>) &#123;</span><br><span class="line">            currentState = <span class="number">2</span>;</span><br><span class="line">            System.out.println(<span class="string">"\t medium speed"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (currentState == <span class="number">2</span>) &#123;</span><br><span class="line">            currentState = <span class="number">3</span>;</span><br><span class="line">            System.out.println(<span class="string">"\t high speed"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            currentState = <span class="number">0</span>;</span><br><span class="line">            System.out.println(<span class="string">"\t turning off"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端发起调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        CellingFanChain cellingFanChain = <span class="keyword">new</span> CellingFanChain();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.print(<span class="string">"Press ENTER"</span>);</span><br><span class="line">            nextPull();</span><br><span class="line">            cellingFanChain.pull();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> String <span class="title">nextPull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        String line = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            line = in.readLine();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> line;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><pre><code>Press ENTER     low speedPress ENTER     medium speedPress ENTER     high speedPress ENTER     turning offPress ENTER     low speedPress ENTER     medium speedPress ENTER     high speed</code></pre><p>可以看到上面代码的实现并不是面向对象的， 没有将具体的状态抽象出来， 也没有对变化进行封装， 状态之间的转换隐藏在条件语句中，如果要加入一个新的状态或者说加一个风扇摇头的动作改起来影响面是比较大的。</p><h1 id="状态模式代码实现"><a href="#状态模式代码实现" class="headerlink" title="状态模式代码实现"></a>状态模式代码实现</h1><p><strong>State</strong> 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pull</span><span class="params">(CellingFanChain cellingFanChain)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ConcreteState</strong> 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Off</span> <span class="keyword">implements</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pull</span><span class="params">(CellingFanChain cellingFanChain)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"\t low speed"</span>);</span><br><span class="line">        cellingFanChain.setContextState(<span class="keyword">new</span> Low());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Low</span> <span class="keyword">implements</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pull</span><span class="params">(CellingFanChain cellingFanChain)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"\t medium speed"</span>);</span><br><span class="line">        cellingFanChain.setContextState(<span class="keyword">new</span> Medium());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Medium</span> <span class="keyword">implements</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pull</span><span class="params">(CellingFanChain cellingFanChain)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"\t high speed"</span>);</span><br><span class="line">        cellingFanChain.setContextState(<span class="keyword">new</span> High());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">High</span> <span class="keyword">implements</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pull</span><span class="params">(CellingFanChain cellingFanChain)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"\t turning off"</span>);</span><br><span class="line">        cellingFanChain.setContextState(<span class="keyword">new</span> Off());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Context</strong> 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CellingFanChain</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> State contextState;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContextState</span><span class="params">(State state)</span> </span>&#123;</span><br><span class="line">        contextState = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CellingFanChain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        contextState = <span class="keyword">new</span> Off();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        contextState.pull(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端发起调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        CellingFanChain cellingFanChain = <span class="keyword">new</span> CellingFanChain();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.print(<span class="string">"Press ENTER"</span>);</span><br><span class="line">            nextPull();</span><br><span class="line">            cellingFanChain.pull();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> String <span class="title">nextPull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        String line = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            line = in.readLine();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> line;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><pre><code>Press ENTER     low speedPress ENTER     medium speedPress ENTER     high speedPress ENTER     turning offPress ENTER     low speedPress ENTER     medium speedPress ENTER     high speed</code></pre><h1 id="状态模式与策略模式的区别"><a href="#状态模式与策略模式的区别" class="headerlink" title="状态模式与策略模式的区别"></a>状态模式与策略模式的区别</h1><ul><li><strong>相似点</strong>：</li></ul><p>两者的 UML 是一样的。</p><ul><li><strong>区别</strong>：</li></ul><p>两个模式的意图不一样。</p><p>状态模式是将一组状态封装在状态对象中， context 对象可以随时委托到状态对象中的某一个， context 的行为会随着状态的改变而改变， 且用户对对象的状态并不是很关心。</p><p>策略模式是用户主动指定 context 所要组合的对象是具体哪一个（最优的那个）。</p><h1 id="状态模式优缺点"><a href="#状态模式优缺点" class="headerlink" title="状态模式优缺点"></a>状态模式优缺点</h1><p><strong>优点</strong>：</p><ul><li>封装了转换规则。</li><li>对象的行为是状态的结果， 行为随着状态的改变而改变。</li><li>不再有大量 if … else 或者 switch … case 代码。</li><li>内聚性更高， 将不同的状态抽离与具体行为绑定在一起。</li></ul><p><strong>缺点</strong>：</p><ul><li>增加了系统类和对象的个数。</li><li>对于“开闭原则”不友好， 对于可切换状态的状态模式， 增加新的状态类就需要修改负责状态转换的代码； 修改某个状态类的行为时也需要修改对应类的源码。</li></ul><h1 id="状态模式应用场景"><a href="#状态模式应用场景" class="headerlink" title="状态模式应用场景"></a>状态模式应用场景</h1><p>以下这些情况可以使用状态模式：</p><ul><li>对象的行为依赖于它的状态并可以根据它的状态改变而改变相关的行为。</li><li>代码中保护大量与对象状态相关的语句，大量的 if…else 语句会导致代码的可维护性变差， 不能方便的删除或者增加新的类。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行为型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>命令模式</title>
      <link href="/2020/04/26/design-pattern/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/04/26/design-pattern/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>将请求的发起方与请求的执行方进行解耦是命令模式最显著的特征。</p><a id="more"></a><h1 id="什么是命令模式"><a href="#什么是命令模式" class="headerlink" title="什么是命令模式"></a>什么是命令模式</h1><p>命令模式（Command Pattern）属于行为模式， 又称为行动（Action）模式或事务（Transaction）模式。软件系统中，“行为请求者”和“行为实现者”常常耦合在一起，但是行为出现特出处理（如记录、撤销、事务）等，紧耦合是无法满足要求的。 将一组行为抽象成对象，将行为请求与行为实现松耦合就是命令模式的特点。</p><h1 id="命令模式组成"><a href="#命令模式组成" class="headerlink" title="命令模式组成"></a>命令模式组成</h1><p><strong>Command</strong>: 定义所有命令的抽象类接口</p><p><strong>ConcreteCommand</strong>: 具体命令角色，实现 Command 接口，接受者与行为之间的弱耦合，负责调用接受者的相应操作。</p><p><strong>Invoker</strong>: 请求者角色， 负责调用 Client下达的对象执行请求。</p><p><strong>Receiver</strong>: 接受者角色， 负责具体实施和执行请求者的请求。在简单的业务场景下 Receiver可省略， 直接在 ConcreteCommand类中实现具体的处理逻辑。 </p><p><strong>Client</strong>: 客户端。</p><h1 id="命令模式-UML"><a href="#命令模式-UML" class="headerlink" title="命令模式 UML"></a>命令模式 UML</h1><p><img src="/2020/04/26/design-pattern/命令模式/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F.png" alt="命令模式"></p><h1 id="命令模式代码实现"><a href="#命令模式代码实现" class="headerlink" title="命令模式代码实现"></a>命令模式代码实现</h1><p><strong>Command 角色</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ConcreteCommand 角色</strong>, 以遥控器举例， 有开、关两种操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LightOnCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Light light;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LightOnCommand</span><span class="params">(Light light)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.light = light;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        light.on();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LightOffCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Light light;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LightOffCommand</span><span class="params">(Light light)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.light = light;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        light.off();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Receiver 角色</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Light</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">off</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"关灯！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">on</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"开灯！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Invoker角色</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoteControl</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Command lightOnCommand;</span><br><span class="line">    <span class="keyword">private</span> Command lightOffCommand;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLightOffCommand</span><span class="params">(Command lightOffCommand)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lightOffCommand = lightOffCommand;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLightOnCommand</span><span class="params">(Command lightOnCommand)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lightOnCommand = lightOnCommand;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turnOn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lightOnCommand.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turnOff</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lightOffCommand.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>客户端调用：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Light light = <span class="keyword">new</span> Light();</span><br><span class="line"></span><br><span class="line">        Command lightOnCommand = <span class="keyword">new</span> LightOnCommand(light);</span><br><span class="line">        Command lightOffCommand = <span class="keyword">new</span> LightOffCommand(light);</span><br><span class="line"></span><br><span class="line">        RemoteControl remoteControl = <span class="keyword">new</span> RemoteControl();</span><br><span class="line"></span><br><span class="line">        remoteControl.setLightOnCommand(lightOnCommand);</span><br><span class="line">        remoteControl.turnOn();</span><br><span class="line"></span><br><span class="line">        remoteControl.setLightOffCommand(lightOffCommand);</span><br><span class="line">        remoteControl.turnOff();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><pre><code>开灯！关灯！</code></pre><p>利用 Command角色， 可以让 Invoker 角色不必关心调用的是 Light 对象还是其他对象， 只需要下发命令， 让 Light 执行相应的操作即可。</p><h1 id="命令模式的-undo-操作"><a href="#命令模式的-undo-操作" class="headerlink" title="命令模式的 undo 操作"></a>命令模式的 undo 操作</h1><p>这里的Command 角色只有 execute()一个方法， 在很多情况下需要撤销指令的时候新增 undo()方法来撤销前一个操作， 比如开灯之后按一下遥控器的按钮就可以撤销。以 LightOnCommand 为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// command 角色新增 undo()操作</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LightOnCommand 重写 undo() 方法， 执行关灯操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LightOnCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Light light;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LightOnCommand</span><span class="params">(Light light)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.light = light;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        light.on();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        light.off();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相应的 Invoker 也要做出相应的调整，在记录 command 请求时一并记录 undoCommand</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoteControl</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Command lightOnCommand;</span><br><span class="line">    <span class="keyword">private</span> Command lightOffCommand;</span><br><span class="line">    <span class="keyword">private</span> Command undoCommand;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLightOnCommand</span><span class="params">(Command lightOnCommand)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lightOnCommand = lightOnCommand;</span><br><span class="line">        <span class="comment">// 记录 undo 指令</span></span><br><span class="line">        <span class="keyword">this</span>.undoCommand = lightOnCommand;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLightOffCommand</span><span class="params">(Command lightOffCommand)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lightOffCommand = lightOffCommand;</span><br><span class="line">        <span class="comment">// 记录 undo 指令</span></span><br><span class="line">        <span class="keyword">this</span>.undoCommand = lightOffCommand;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turnOn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lightOnCommand.execute();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turnOff</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lightOffCommand.execute();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// undo 操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        undoCommand.undo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Light light = <span class="keyword">new</span> Light();</span><br><span class="line"></span><br><span class="line">        Command lightOnCommand = <span class="keyword">new</span> LightOnCommand(light);</span><br><span class="line">        Command lightOffCommand = <span class="keyword">new</span> LightOffCommand(light);</span><br><span class="line"></span><br><span class="line">        RemoteControl remoteControl = <span class="keyword">new</span> RemoteControl();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开灯操作</span></span><br><span class="line">        remoteControl.setLightOnCommand(lightOnCommand);</span><br><span class="line">        remoteControl.turnOn();</span><br><span class="line">        remoteControl.undo();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关灯操作</span></span><br><span class="line">        remoteControl.setLightOffCommand(lightOffCommand);</span><br><span class="line">        remoteControl.turnOff();</span><br><span class="line">        remoteControl.undo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><pre><code>开灯！关灯！关灯！开灯！</code></pre><h1 id="命令模式要点"><a href="#命令模式要点" class="headerlink" title="命令模式要点"></a>命令模式要点</h1><ul><li>命令模式将发出请求的对象（<strong>Invoker</strong>）与执行请求的对象（<strong>Receiver</strong>）解耦。</li><li>被解耦的两者之间是通过命令对象（<strong>Command</strong>）进行沟通的， 命令对象封装了接受者的一个或者一组动作。</li><li>发出请求的对象通过 execute()发出请求，使得接受者的动作被调用。</li><li>命令可以支持撤销， 通过实现 undo() 方法来回到 execute()被执行前的状态。</li></ul><h1 id="命令模式优缺点"><a href="#命令模式优缺点" class="headerlink" title="命令模式优缺点"></a>命令模式优缺点</h1><p>优点：</p><ul><li>降低系统耦合度，将请求发起者与请求执行者解耦， 双方都不知道对方的存在。</li><li>新的命令很容易加入的系统中，符合开闭原则。</li><li>若有多个命令需要一起执行， 可以实现命令队列或者宏命令（组合命令）。</li><li>支持 undo()、redo()操作</li></ul><p>缺点：</p><ul><li>使用命令模式可能会导致系统有过多的具体命令类。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行为型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>观察者模式</title>
      <link href="/2020/04/25/design-pattern/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/04/25/design-pattern/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>当对象间存在一对多的关系且一个对象修改会影响到其他对象时，自动通知其他对象被依赖的对象作出改变即观察者模式。</p><a id="more"></a><h1 id="什么是观察者模式"><a href="#什么是观察者模式" class="headerlink" title="什么是观察者模式"></a>什么是观察者模式</h1><p>观察者模式（Observer Pattern）属于对象行为型模式。当一个对象与多个对象存在一对多的关系时， 当一个对象进行修改需要<strong>通知</strong>关注该对象的多个对象作出相应的修改。</p><h1 id="在什么情况下使用观察者模式"><a href="#在什么情况下使用观察者模式" class="headerlink" title="在什么情况下使用观察者模式"></a>在什么情况下使用观察者模式</h1><ol><li>对象间存在一对多的关系</li><li>被观察者发生变更时需要通知其他观察者</li><li>跨系统的消息交互</li></ol><h1 id="观察者模式组成"><a href="#观察者模式组成" class="headerlink" title="观察者模式组成"></a>观察者模式组成</h1><p><strong>Subject</strong>: 被观察者， 抽象类或者接口。</p><p><strong>ConcreteSubject</strong>：具体被观察者，被观察者的实现，含有队列维护观察对象列表，订阅以及取消订阅方法。</p><p><strong>Observer</strong>：观察者， 抽象类或者接口。</p><p><strong>ConcreteObserver</strong>： 具体观察者， 观察者的实现， 当被观察者更新时观察者立马响应发生变更。</p><h1 id="观察者模式-UML"><a href="#观察者模式-UML" class="headerlink" title="观察者模式 UML"></a>观察者模式 UML</h1><p><img src="/2020/04/25/design-pattern/观察者模式/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F.png" alt="观察者模式UML"></p><h1 id="观察者模式代码示例"><a href="#观察者模式代码示例" class="headerlink" title="观察者模式代码示例"></a>观察者模式代码示例</h1><p>以微信公众号订阅为例， 用户觉得某篇文章不错开始订阅（<strong>attach</strong>）， 定期接受公众号的推送(<strong>notifyAll</strong>)， 但是发现作者的文章质量越来越差，于是部分用户取消订阅(<strong>detach</strong>)。</p><p>被观察者（<strong>Subject</strong>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"><span class="comment">// 对应attach方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">register</span><span class="params">(Observer observer)</span></span>;</span><br><span class="line"><span class="comment">// 对应detach方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unRegister</span><span class="params">(Observer observer)</span></span>;</span><br><span class="line">   <span class="comment">// 对应notifyAll方法 </span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">notifyAllObservers</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体被观察者（<strong>ConcreteSubject</strong>），这里指的是被订阅的公众号</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubscribeSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 观察者队列</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; observerList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (observer != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(observer.toString() + <span class="string">", 新增订阅"</span>);</span><br><span class="line">            observerList.add(observer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unRegister</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (observerList.contains(observer)) &#123;</span><br><span class="line">            System.out.println(observer.toString() + <span class="string">", 取消订阅"</span>);</span><br><span class="line">            observerList.remove(observer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyAllObservers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer observer : observerList) &#123;</span><br><span class="line">            observer.update(observer.toString() +<span class="string">", 新的订阅内容更新了！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察者（<strong>Observer</strong>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(String content)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体被观察者（<strong>ConcreteObserver</strong>）， 代表订阅公众号的微信用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeChatUser</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WeChatUser</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">        System.out.println(content);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建订阅用户</span></span><br><span class="line">        Observer observer1 = <span class="keyword">new</span> WeChatUser(<span class="string">"Filo"</span>);</span><br><span class="line">        Observer observer2 = <span class="keyword">new</span> WeChatUser(<span class="string">"Krook"</span>);</span><br><span class="line">        Observer observer3 = <span class="keyword">new</span> WeChatUser(<span class="string">"HarryHook"</span>);</span><br><span class="line"></span><br><span class="line">        Subject subject = <span class="keyword">new</span> SubscribeSubject();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 用户关注公众号</span></span><br><span class="line">        subject.register(observer1);</span><br><span class="line">        subject.register(observer2);</span><br><span class="line">        subject.register(observer3);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 通知用户公众号内容更新</span></span><br><span class="line">        subject.notifyAllObservers();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 用户取消关注公众号</span></span><br><span class="line">        subject.unRegister(observer2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><pre><code>Filo, 新增订阅Krook, 新增订阅HarryHook, 新增订阅Filo, 新的订阅内容更新了！Krook, 新的订阅内容更新了！HarryHook, 新的订阅内容更新了！Krook, 取消订阅</code></pre><h1 id="观察者模式优缺点"><a href="#观察者模式优缺点" class="headerlink" title="观察者模式优缺点"></a>观察者模式优缺点</h1><p>优点：</p><ul><li>解除耦合， 让双方面向接口交互</li></ul><p>缺点：</p><ul><li>被观察者需要维护观察者对象，将所有观察者都通知一遍，若一个观察者卡顿将会影响到其他的观察者， 所有一般采用异步通知。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行为型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>策略模式</title>
      <link href="/2020/04/24/design-pattern/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/04/24/design-pattern/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>对不同算法进行封装， 让客户端决定去使用哪种算法就是策略模式。</p><a id="more"></a><h1 id="什么是策略模式"><a href="#什么是策略模式" class="headerlink" title="什么是策略模式"></a>什么是策略模式</h1><p>策略模式针对一组算法，将每个算法封装到具有共同接口的独立类中， 使它们可以相互替换。 策略模式使得算法可以在不影响到客户端的情况下发生变化。</p><h1 id="策略模式组成"><a href="#策略模式组成" class="headerlink" title="策略模式组成"></a>策略模式组成</h1><p><strong>Context</strong>: 上下文角色, 持有 Strategy 引用。</p><p><strong>Strategy</strong>: 抽象策略角色, 通常由一个接口或者抽象类实现。</p><p><strong>ConcreteStrategy</strong>: 具体策略角色, 实现具体的策略算法。</p><h1 id="策略模式-UML"><a href="#策略模式-UML" class="headerlink" title="策略模式 UML"></a>策略模式 UML</h1><p><img src="/2020/04/24/design-pattern/策略模式/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8Fuml.png" alt="策略模式 uml"></p><h1 id="策略模式代码实现"><a href="#策略模式代码实现" class="headerlink" title="策略模式代码实现"></a>策略模式代码实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Strategy接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OperatorStrategy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">operation</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ContreteStrategy接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddOperateStrategy</span> <span class="keyword">implements</span> <span class="title">OperatorStrategy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">operation</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num1 + num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ContreteStrategy接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubOperateStrategy</span> <span class="keyword">implements</span> <span class="title">OperatorStrategy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">operation</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num1 - num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ContreteStrategy接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiplyOperateStrategy</span> <span class="keyword">implements</span> <span class="title">OperatorStrategy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">operation</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num1 * num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Context 类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Operator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> OperatorStrategy strategy;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Operator</span><span class="params">(OperatorStrategy operatorStrategy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.strategy = operatorStrategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">execute</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>.strategy.operation(num1, num2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>// 客户端调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Operator addOperator = <span class="keyword">new</span> Operator(<span class="keyword">new</span> AddOperateStrategy());</span><br><span class="line"></span><br><span class="line">        System.out.println(addOperator.execute(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">        Operator subOperator = <span class="keyword">new</span> Operator(<span class="keyword">new</span> SubOperateStrategy());</span><br><span class="line"></span><br><span class="line">        System.out.println(subOperator.execute(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">        Operator multiplyOperator = <span class="keyword">new</span> Operator(<span class="keyword">new</span> MultiplyOperateStrategy());</span><br><span class="line"></span><br><span class="line">        System.out.println(multiplyOperator.execute(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><pre><code>1 + 2 = 31 - 2 = -11 * 2 = 2</code></pre><h1 id="策略模式优缺点"><a href="#策略模式优缺点" class="headerlink" title="策略模式优缺点"></a>策略模式优缺点</h1><p>优点： </p><ul><li>算法可以自由切换。</li><li>扩展性好，增加新的策略很方便， 新增一个策略类即可。</li></ul><p>缺点：</p><ul><li>策略类的数量增多。</li><li>所有的策略类都需要对外暴露，上层模块必须知道所有的策略才能决定使用哪个策略。</li></ul><h1 id="策略模式在-JDK-中的应用"><a href="#策略模式在-JDK-中的应用" class="headerlink" title="策略模式在 JDK 中的应用"></a>策略模式在 JDK 中的应用</h1><p>JDK 的线程池中可以看下 ThreadPoolExecutor 的构造方法中的 handler</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Handler called when saturated or shutdown in execute.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> RejectedExecutionHandler handler;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Invokes the rejected execution handler for the given command.</span></span><br><span class="line"><span class="comment"> * Package-protected for use by ScheduledThreadPoolExecutor.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">reject</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    handler.rejectedExecution(command, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 RejectedExecutionHandler 的执行就是策略模式的实现。 reject 执行拒绝策略有四种实现： 直接抛出异常、使用调用者的线程来处理、直接丢掉这个任务、丢掉最老的任务。</p><h1 id="策略模式与工厂模式对比"><a href="#策略模式与工厂模式对比" class="headerlink" title="策略模式与工厂模式对比"></a>策略模式与工厂模式对比</h1><p><strong>相似点</strong>：</p><pre><code>结构相似，都是对象的继承与多态。</code></pre><p><strong>差异</strong>：   </p><pre><code>工厂模式是创建型模式，运行时创建对象；策略模式是行为模式，让对象在不同情况下选择行为。工厂模式关注对象的创建，策略模式关注行为的封装。工厂模式是黑盒，策略模式是白盒。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行为型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 142. Linked List Cycle II</title>
      <link href="/2020/04/19/leetcode/linkedlist/linked-list-cycle-ii/"/>
      <url>/2020/04/19/leetcode/linkedlist/linked-list-cycle-ii/</url>
      
        <content type="html"><![CDATA[<p>Given a linked list, return the node where the cycle begins. If there is no cycle, return null.</p><a id="more"></a><p>To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list.</p><p>Note: Do not modify the linked list.</p><h1 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h1><blockquote><p>Input: head = [3,2,0,-4], pos = 1</p><p>Output: tail connects to node index 1</p><p>Explanation: There is a cycle in the linked list, where tail connects to the second node.</p></blockquote><p><img src="/2020/04/19/leetcode/linkedlist/linked-list-cycle-ii/circularlinkedlist.png" alt="ex1"></p><h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给出一个链表， 判断是否有环， 有环的话返回环开始的结点。 若环不存在，返回 null</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>返回环相交的结点需要分两步</p><ol><li>判断环是否存在， 不存在返回 null， 此处需要利用快慢指针</li><li>若环存在， 需要利用以下公式</li></ol><p>假设头结点到环开始的位置为 x1， 环开始的结点到相交的结点 x2, ， 相遇结点到环开始的结点 x3， 环的长度为 N 。</p><p>因为快指针是慢指针走过路程的两倍,  所以有以下结论</p><p>慢指针走过的距离： x1 + x2<br>快指针走过的距离： x1 + x2 + x3 + x2<br>环的长度：N = x2 + x3</p><p>2(x1 + x2) =  x1 + x2 + x3 + x2  =====&gt;&gt;&gt;&gt; x1 = x3， 所以当快慢指针相遇时从头结点遍历到与慢指针相遇即为环形结点开始处。</p><p><img src="/2020/04/19/leetcode/linkedlist/linked-list-cycle-ii/ex.png" alt="示意图"></p><p>详细推导：</p><pre><code>2*(x1 + x2) + 2n*(x3 + x2) = (x1 + x2 + x3 + x2) + m*(x3 + x2)x1 + 2n*(x3 + x2) = x3 + m*(x3 + x2)x1 = x3 + (x3 + x2)*(m - 2n)</code></pre><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ListNode fast = head;</span><br><span class="line">    ListNode slow = head;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        <span class="comment">// 快慢指针相遇</span></span><br><span class="line">        <span class="keyword">if</span>(slow == fast) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 环不存在</span></span><br><span class="line">    <span class="keyword">if</span>(fast != slow) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    fast = head;</span><br><span class="line">    <span class="comment">// fast 从头结点遍历， slow 指针从相遇处遍历， 再次相遇即为环开始处</span></span><br><span class="line">    <span class="keyword">while</span>(fast != slow) &#123;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fast;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每周一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> linkedlist </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 141. Linked List Cycle</title>
      <link href="/2020/04/19/leetcode/linkedlist/linked-list-cycle/"/>
      <url>/2020/04/19/leetcode/linkedlist/linked-list-cycle/</url>
      
        <content type="html"><![CDATA[<p>Given a linked list, determine if it has a cycle in it.</p><a id="more"></a><p>To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list.</p><h1 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h1><blockquote><p>Input: head = [3,2,0,-4], pos = 1</p><p>Output: true</p><p>Explanation: There is a cycle in the linked list, where tail connects to the second node.</p></blockquote><p><img src="/2020/04/19/leetcode/linkedlist/linked-list-cycle/circularlinkedlist.png" alt="example1"></p><h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给出一个链表， 判断链表是否存在环。</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>判断是否有环， 与无环的链表相比， 无环的链表如果进行遍历最终会走向 null 结点。<br>有环的结点因为环的存在会在环内循环， 所以利用快慢指针， 判断快慢指针是否会重合。</p><p><img src="/2020/04/19/leetcode/linkedlist/linked-list-cycle/%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="环形链表循环遍历"></p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="comment">// 快慢指针相遇</span></span><br><span class="line">            <span class="keyword">if</span>(fast == slow)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每周一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> linkedlist </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>享元模式</title>
      <link href="/2020/04/17/design-pattern/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/04/17/design-pattern/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>享元模式是一种支持细粒度对象复用的结构型设计模式，又称为 轻量级模式。</p><a id="more"></a><h1 id="什么是享元模式"><a href="#什么是享元模式" class="headerlink" title="什么是享元模式"></a>什么是享元模式</h1><p>享元模式 (FlyWeight Pattern) 是为了解决系统运行中产生的对象太多，导致运行代价过高、系统性能下降的问题。比如文本字符串中有很多相同的字符，若每一个字符都用单独的对象去表示将会占用很多的内存空间，而<strong>享元模式</strong>通过共享实现了对象的重用，使出现的每一个字符在内存中共享一个对象。</p><h1 id="什么情况下需要使用享元模式"><a href="#什么情况下需要使用享元模式" class="headerlink" title="什么情况下需要使用享元模式"></a>什么情况下需要使用享元模式</h1><ul><li>当我们需要大量细粒度对象且只有几个参数， 并且大多数特性是相同的。</li><li>当需要创建更少的对象并将它们共享来空盒子大量对象的内存消耗。</li></ul><h1 id="内部状态和外部状态"><a href="#内部状态和外部状态" class="headerlink" title="内部状态和外部状态"></a>内部状态和外部状态</h1><p>享元对象具有两种状态：<strong>内部状态</strong> (Intrinsic State) 和<strong>外部状态</strong> (Extrinsic State).</p><ul><li><p>享元对象中共享的状态为内部状态。内部状态是存储在享元对象内部并且不会随着环境改变而改变的状态，例如字符 a 在任何环境下始终是 a。</p></li><li><p>由外部环境设置不能共享的内容称为外部状态。外部状态会随环境改变而改变，外部状态之间是相互独立的，例如字符的颜色或者字号大小，外部状态独立变化相互之间没有影响。 外部状态可以通过对象创建的时候传递给享元对象。</p></li></ul><h1 id="享元模式组成"><a href="#享元模式组成" class="headerlink" title="享元模式组成"></a>享元模式组成</h1><p>享元模式可以分为<strong>单纯享元</strong>与<strong>复合享元</strong>两种模式。</p><h1 id="单纯享元模式"><a href="#单纯享元模式" class="headerlink" title="单纯享元模式"></a>单纯享元模式</h1><p><img src="/2020/04/17/design-pattern/享元模式/%E5%8D%95%E7%BA%AF%E4%BA%AB%E5%85%83.jpg" alt="单纯享元 UML"></p><p><strong>FlyWeight</strong>(抽象享元类)：抽象类或者接口，在接口中定义了具体享元类的公共方法，公共方法向外部提供享元对象的内部数据（内部状态），也可以通过公共方法设置外部数据（外部方法）。</p><p><strong>ConcreteFlyWeight</strong>(具体享元类)： 实现了抽象享元类， 其实例成为享元对象；在具体享元类为内部状态提供存储空间。</p><p><strong>FlyWeightFactory</strong>(享元工厂类)： 享元工厂创建并管理享元对象， 针对抽象享元类将各种具体享元对象存储在一个享元池中（通常是 Map ）。使用工厂模式创建享元实例， 如果不存在将其存储在享元池中， 如果存在直接从享元池中提供实例。</p><h1 id="单纯享元模式代码实现"><a href="#单纯享元模式代码实现" class="headerlink" title="单纯享元模式代码实现"></a>单纯享元模式代码实现</h1><p>以画圆举例，需要在不同的坐标上不同颜色</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象享元类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> radius)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体享元类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内部状态可共享</span></span><br><span class="line"><span class="keyword">private</span> String color;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 外部状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line"><span class="comment">// 外部状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> y;</span><br><span class="line"><span class="comment">// 外部状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> radius;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">(String color)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.color = color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> radius)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.x = x;</span><br><span class="line"><span class="keyword">this</span>.y = y;</span><br><span class="line"><span class="keyword">this</span>.radius = radius;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"draw a circle: "</span> + <span class="string">"color: "</span> + color + <span class="string">", x: "</span> + x + <span class="string">", y "</span> + y + <span class="string">", radius "</span> + radius);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 享元工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShapeFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 享元池</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> HashMap&lt;String, Shape&gt; circleMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span>  Shape <span class="title">getCircle</span><span class="params">(String color)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Shape circle = circleMap.get(color);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (circle == <span class="keyword">null</span>) &#123;</span><br><span class="line">circle = <span class="keyword">new</span> Circle(color);</span><br><span class="line">circleMap.put(color, circle);</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line"><span class="keyword">return</span> circle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">poolSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> circleMap.size();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端调用</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">ShapeFactory shapeFactory = <span class="keyword">new</span> ShapeFactory();</span><br><span class="line"></span><br><span class="line">Shape blackCircle1 =  shapeFactory.getCircle(<span class="string">"Black"</span>);</span><br><span class="line">blackCircle1.draw(getRandomX(), getRandomY(), getRandomRadius());</span><br><span class="line"></span><br><span class="line">Shape blackCircle2 =  shapeFactory.getCircle(<span class="string">"Black"</span>);</span><br><span class="line">blackCircle2.draw(getRandomX(), getRandomY(), getRandomRadius());</span><br><span class="line"></span><br><span class="line">System.out.println( blackCircle1 == blackCircle2);</span><br><span class="line">System.out.println(<span class="string">"pool size: "</span> + shapeFactory.poolSize());</span><br><span class="line">    </span><br><span class="line">System.out.println(<span class="string">"pool size: "</span> + shapeFactory.poolSize());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getRandomRadius</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">int</span>) (Math.random() * <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getRandomY</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">int</span>) (Math.random() * <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getRandomX</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">int</span>) (Math.random() * <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><pre><code>draw a circle: color: Black, x: 23, y 72, radius 4draw a circle: color: Black, x: 77, y 79, radius 44truepool size: 1</code></pre><h1 id="复合享元模式"><a href="#复合享元模式" class="headerlink" title="复合享元模式"></a>复合享元模式</h1><p><img src="/2020/04/17/design-pattern/享元模式/%E5%A4%8D%E5%90%88%E4%BA%AB%E5%85%83.jpg" alt="复合享元 UML"></p><p>复合享元模式组成:</p><ul><li>抽象享元角色(Flyweight)</li><li>具体享元角色(ConcreteFlyweight)</li><li><strong><em>复合享元角色</em></strong>(ConcreteCompositeFlyweight)</li><li>享元工厂角色(FlyweightFactory)</li></ul><p>复合享元模式相比于单纯享元模式多了 <strong>复合享元对象</strong> (ConcreteComositeFlyWeight)：复合享元角色所代表的对象是不可以共享的，一个复合享元对象可以有多个具体享元对象组成。 因此提供 add()方法来聚集管理单纯享元角色， 且多了一个 map 对象。</p><h1 id="复合享元模式代码实现"><a href="#复合享元模式代码实现" class="headerlink" title="复合享元模式代码实现"></a>复合享元模式代码实现</h1><p>复合享元类——CompositeConcreteFlyweight</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompositeCircle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"><span class="comment">// 单纯享元对象集合</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, Shape&gt; flyWeights = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">   </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * flyWeights 是单纯享元对象集合，具有相同的外部状态extrinsicState</span></span><br><span class="line"><span class="comment">     * 该示例中extrinsicState则是相同的 x, y, radius</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> radius)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, Shape&gt; entry : flyWeights.entrySet()) &#123;</span><br><span class="line">entry.getValue().draw(x, y, radius);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String color, Shape shape)</span> </span>&#123;</span><br><span class="line">flyWeights.put(color, shape);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShapeFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HashMap&lt;String, Shape&gt; flyWeights = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Shape <span class="title">getCircle</span><span class="params">(String color)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Shape circle = flyWeights.get(color);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (circle == <span class="keyword">null</span>) &#123;</span><br><span class="line">circle = <span class="keyword">new</span> Circle(color);</span><br><span class="line">flyWeights.put(color, circle);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> circle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Shape <span class="title">getCircle</span><span class="params">(List&lt;String&gt; colors)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">CompositeCircle compositeCircle = <span class="keyword">new</span> CompositeCircle();</span><br><span class="line"><span class="keyword">for</span> (String color : colors) &#123;</span><br><span class="line">      <span class="comment">// 调用单纯享元工厂模式方法， 使用 add() 方法加入的单纯享元对象是可以共享的</span></span><br><span class="line">compositeCircle.add(color, <span class="keyword">this</span>.getCircle(color));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> compositeCircle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">poolSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> flyWeights.size();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">客户端调用：</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String colors[] = &#123;<span class="string">"Red"</span>, <span class="string">"Green"</span>, <span class="string">"Blue"</span>, <span class="string">"White"</span>, <span class="string">"Black"</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">List&lt;String&gt; compositeState = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">compositeState.add(getRandomColor());</span><br><span class="line">compositeState.add(getRandomColor());</span><br><span class="line">compositeState.add(getRandomColor());</span><br><span class="line">compositeState.add(getRandomColor());</span><br><span class="line"></span><br><span class="line">ShapeFactory shapeFactory = <span class="keyword">new</span> ShapeFactory();</span><br><span class="line"></span><br><span class="line">Shape circle1 = shapeFactory.getCircle(compositeState);</span><br><span class="line">Shape circle2 = shapeFactory.getCircle(compositeState);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 复合享元对象不可共享</span></span><br><span class="line">System.out.println(circle1 == circle2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多个单处享元对象具有相同的外部状态</span></span><br><span class="line">circle1.draw(getRandomX(), getRandomY(), getRandomRadius());</span><br><span class="line">circle2.draw(getRandomX(), getRandomY(), getRandomRadius());</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"pool size: "</span> + shapeFactory.poolSize());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getRandomColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> colors[(<span class="keyword">int</span>) (colors.length * Math.random())];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getRandomRadius</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">int</span>) (Math.random() * <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getRandomY</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">int</span>) (Math.random() * <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getRandomX</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">int</span>) (Math.random() * <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><pre><code>falsedraw a circle: color: White, x: 89, y 50, radius 16draw a circle: color: Blue, x: 89, y 50, radius 16draw a circle: color: Black, x: 89, y 50, radius 16draw a circle: color: White, x: 41, y 60, radius 35draw a circle: color: Blue, x: 41, y 60, radius 35draw a circle: color: Black, x: 41, y 60, radius 35pool size: 3</code></pre><h1 id="享元模式的优缺点"><a href="#享元模式的优缺点" class="headerlink" title="享元模式的优缺点"></a>享元模式的优缺点</h1><p>优点： </p><ul><li>实现了对象共享</li><li>使用享元模式减少了对象的创建，减少了内存的使用</li></ul><p>缺点：</p><ul><li>需要分离出内部状态和外部状态，系统更复杂</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 结构型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 138. Copy List with Random Pointer</title>
      <link href="/2020/04/12/leetcode/linkedlist/copy-list-with-random-pointer/"/>
      <url>/2020/04/12/leetcode/linkedlist/copy-list-with-random-pointer/</url>
      
        <content type="html"><![CDATA[<p>A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.</p><a id="more"></a><p>Return a deep copy of the list.</p><p>The Linked List is represented in the input/output as a list of n nodes. Each node is represented as a pair of [val, random_index] where:</p><p>val: an integer representing Node.val<br>random_index: the index of the node (range from 0 to n-1) where random pointer points to, or null if it does not point to any node.</p><h1 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h1><p><img src="/2020/04/12/leetcode/linkedlist/copy-list-with-random-pointer/e1.png" alt="expample1"></p><blockquote><p>Input: head = [[7,null],[13,0],[11,4],[10,2],[1,0]]</p><p>Output: [[7,null],[13,0],[11,4],[10,2],[1,0]]</p></blockquote><h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给出有个链表， 结点含有 value域， next 指针、random 指针， 其中 next 指针指向下一个结点， random 指向任意结点， 现在需要复制一个给定链表。</p><p>思路：</p><ul><li>先复制 next 结点</li><li>再复制 random 结点</li><li>连接新的链表</li></ul><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node next;</span></span><br><span class="line"><span class="comment">    Node random;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">        this.next = null;</span></span><br><span class="line"><span class="comment">        this.random = null;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">copyRandomList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        generateNext(head);</span><br><span class="line">        connectRandom(head);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> reconnectList(head);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">generateNext</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        Node pNode = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(pNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node pCloned = <span class="keyword">new</span> Node(pNode.val);</span><br><span class="line">            pCloned.next = pNode.next;</span><br><span class="line">            pNode.next = pCloned;</span><br><span class="line">            pNode = pCloned.next;</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">connectRandom</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        Node pNode = head;</span><br><span class="line">        Node pCloned  = <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(pNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            pCloned = pNode.next;</span><br><span class="line">            <span class="keyword">if</span>(pNode.random != <span class="keyword">null</span>) &#123;</span><br><span class="line">                pCloned.random = pNode.random.next;</span><br><span class="line">            &#125;</span><br><span class="line">            pNode = pCloned.next;</span><br><span class="line">        &#125;    </span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">reconnectList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        Node pNode = head;</span><br><span class="line">        Node cloneHead = <span class="keyword">null</span>;</span><br><span class="line">        Node pCloned = <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(pNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            pCloned = cloneHead = head.next;</span><br><span class="line">            pNode.next = pCloned.next;</span><br><span class="line">            pNode = pCloned.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(pNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            pCloned.next = pNode.next;</span><br><span class="line">            pCloned = pCloned.next;</span><br><span class="line">            pNode.next = pCloned.next;</span><br><span class="line">            pNode = pCloned.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cloneHead;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每周一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> linkedlist </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 负载均衡</title>
      <link href="/2020/04/11/mysql/note11-load-banlancing/"/>
      <url>/2020/04/11/mysql/note11-load-banlancing/</url>
      
        <content type="html"><![CDATA[<p>负载均衡的目的在于将流量平均的分发到集群中的机器。</p><a id="more"></a><p>负载均衡的目的在于：</p><ul><li>提高可扩展性：读写分离是从备库读取数据</li><li>高效性：可以把更多的工作分配给性能更好的机器</li><li>可用性：时刻都有可用的机器</li><li>透明性：客户端无感知负载方案</li><li>一致性：负载防止状态丢失，而无需应用去跟踪</li></ul><p><img src="/2020/04/11/mysql/note11-load-banlancing/load_balancing_architecture.png" alt="负载均衡经典架构"></p><p>负载均衡通常与数据分片和复制相关， 需要关心的是读写策略， 一般来说有直接连接， 采用中间件以及一主多备间的负载均衡</p><h1 id="直接连接"><a href="#直接连接" class="headerlink" title="直接连接"></a>直接连接</h1><p>负载均衡并不只是配置在应用以及 MySQL 之间的东西，也可以直接连接到服务器。</p><h2 id="复制上的读写分离"><a href="#复制上的读写分离" class="headerlink" title="复制上的读写分离"></a>复制上的读写分离</h2><p>如何避免因为读写分离引起的脏数据的问题， 当一个用户进行了修改新增了一条评论， 但是刷新页面后却没有看到更新，这种通常都是因为从备库读取到了脏数据。</p><p>常见的读写分离的方法有：</p><p>基于查询分离</p><pre><code>将不能接受有脏数据的读写操作分配给主库， 始终保证数据是最新的。但是有很少的查询允许脏数据， 大多数的查询都分配给主库， 主从就没有意义了。</code></pre><p>基于脏数据分离：</p><pre><code>让应用检查复制延迟，确认备库数据是否太旧。 很多报表类的应用都是晚上加载数据复制到备库即可，并不关心是否100%跟上了主库， 每晚更新一次。</code></pre><p>基于会话分离：</p><pre><code>判断用户是否可以从备库读取数据的另一种方式： 先判断用户是否修改了数据。 用户只关心自己做的更新， 在会话层设置一个标记位，表明做了更新就将该用户的查询在一段时间内指向主库。</code></pre><p>基于版本分离：</p><pre><code>跟踪对象的版本号以及时间戳， 如果备库的数据太旧，就从主库读取最新的数据。</code></pre><p> 基于全局版本/会话分离：</p><pre><code>在应用执行写操作时，提交事务后执行一次 SHOW MASTER STATUS 操作，在缓存中存储主库日志坐标，作为被修改对象/会话的版本号， 连接从库时执行 SHOW SLAVE STATUS 并将备库的坐标与缓存中的版本号相对比， 如果备库的记录点和主库的不一致就读取主库数据。</code></pre><h2 id="修改应用的配置"><a href="#修改应用的配置" class="headerlink" title="修改应用的配置"></a>修改应用的配置</h2><p>应用的配置不要写死， 而是将配置存储在服务器或者缓存中， 这样更灵活。</p><h2 id="修改-DNS-名称"><a href="#修改-DNS-名称" class="headerlink" title="修改 DNS 名称"></a>修改 DNS 名称</h2><p> 为不同服务器指定一个合适的名字， 为只读服务器分配一个 DNS 名， 为专门写操作的服务器起另外一个 DNS 名称。 如果备库能够跟上主库， 就将只读 DNS 名称指定给备库， 当出现延迟时， 再将 DNS 名指定给主库。</p><p> 这种修改 DNS 名称的技术很容易实现， 但是有很多缺点，最大的问题是无法控制 DNS。</p><ul><li><p>修改 DNS 并不是立马生效， 也不是原子操作。</p></li><li><p>DNS 数据会缓存， 且失效时间并不是强制的。</p></li><li><p>可能需要应用或服务器重启才能使修改后的 DNS 完全生效。</p></li><li><p>多个 IP 地址共用一个 DNS 名 并依赖轮询来均衡请求。</p><p>所有通常不建议使用这种方式。</p><h2 id="转移-IP-地址"><a href="#转移-IP-地址" class="headerlink" title="转移 IP 地址"></a>转移 IP 地址</h2><p>为每一个物理服务器分配一个固定的 IP 地址， 再为每个逻辑上的服务使用一个虚拟的 IP 地址。</p></li></ul><h1 id="引入中间件"><a href="#引入中间件" class="headerlink" title="引入中间件"></a>引入中间件</h1><p> 之前讨论的方案是应用与 MySQL 直连， 实际上很多解决方案会引入中间件， 作为网络代理一边接受所有的通信请求， 另一边将这些请求派发到指定的机器上。 如图所示的解决方案</p><p> <img src="/2020/04/11/mysql/note11-load-banlancing/load_balance_middle.png" alt="负载均衡中间件"></p><h2 id="负载均衡器"><a href="#负载均衡器" class="headerlink" title="负载均衡器"></a>负载均衡器</h2><p> 负载均衡器更多用在 WEB 服务商， 因为大多数的负载均衡器都支持HTTP， MySQL 的链接都是 TCP/IP 链接， 所以在 MySQL上使用多用途负载均衡器， 但是由于缺少 MySQL 专有的特性， 会有许多限制。</p><ul><li>除非负载均衡器知道 MySQL 的负载， 否则无法做到恨到的负载均衡。</li><li>负载均衡器不知道如何把单个 HTTP 请求与 MySQL服务器绑定。</li><li>连接池和长连接会阻碍负载均衡器分发请求。</li><li>MySQL不接受到 3306 端口的 HTTP 请求， 所以不能通过 HTTP 请求进行负载检查， 所以需要在 MySQL服务器额外安装一个 HTTP 服务器软件， 这个软件检查MySQL服务器的状态并返回一个对应的状态值。</li></ul><h2 id="负载均衡算法"><a href="#负载均衡算法" class="headerlink" title="负载均衡算法"></a>负载均衡算法</h2><p>随机： 从可用的服务池中选择一个服务器处理请求</p><p>轮询： 按照循环顺序发送请求到服务器。</p><p>最少连接数： 下一个请求分配给拥有最少活跃连接的服务器。</p><p>最快响应： 按照处理请求的响应时间分配请求。</p><p>哈希： 根据连接的源 IP 进行哈希， 映射到池中的同一服务器。</p><p>权重： 对应集群中有单核 CPU 与双核 CPU 时， 负载均衡器会分配两倍的请求给双 CPU 机器。</p><p>具体哪种算法更合适需要根据实际场景测试得出。</p><h2 id="从服务器池中新增-移除服务器"><a href="#从服务器池中新增-移除服务器" class="headerlink" title="从服务器池中新增/移除服务器"></a>从服务器池中新增/移除服务器</h2><p>新增的服务器可能未缓存数据， 第一次查询需要很长时间。 在通知负载均衡器有新机器加入之前可以暂时把查询映射到一台活跃的服务器上， 然后在新开启的服务器上读取和重放活跃服务器的日志文件， 或者捕捉生产服务器上的网络通信。</p><h1 id="一主多备间的负载均衡"><a href="#一主多备间的负载均衡" class="headerlink" title="一主多备间的负载均衡"></a>一主多备间的负载均衡</h1><p>对于最常见的复制拓扑结构， 以下的方法可以更好的结合负载均衡。</p><p>功能分区：</p><pre><code>对于特定目的可以通过配置备库或一组备库来扩大容量。</code></pre><p>过滤和数据分区：</p><pre><code>使用复制过滤技术对相似的备库进行分区例如将 A-M 开头的用户名的读操作分配给一个给定的备库， N-Z 开头的分配给另一个。</code></pre><p> 将部分写操作转移到备库：</p><pre><code>分解写查询， 在备库执行一部分</code></pre><p> 保证备库跟上主库：</p><pre><code>使用函数 MASTER_POS_WAIT() 阻塞直到备库赶上主库设置的同步点。</code></pre><p> 同步写操作：</p><pre><code>每个备库轮流执行  MASTER_POS_WAIT()， 不到万不得已不要使用， 可能会阻塞很长时间。</code></pre><p>选择合适的分片策略并不是说在应用设计初期就需要考虑分区分表， 做出来才是最重要的。 </p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 扩展</title>
      <link href="/2020/04/06/mysql/note10-scaling-mysql/"/>
      <url>/2020/04/06/mysql/note10-scaling-mysql/</url>
      
        <content type="html"><![CDATA[<p>当 MySQL 规模变的越来越大时， 如何保证高效且经济？</p><a id="more"></a><h1 id="可扩展性"><a href="#可扩展性" class="headerlink" title="可扩展性"></a>可扩展性</h1><p>可扩展性表明当需要增加资源以执行更多工作时系统能获得收益的同等提升。 缺乏扩展能力的系统达到收益递减的转折点后， 将无法进一步增长。</p><p>系统是否需要扩展一般从哪个四个因素进行衡量：</p><ul><li>数据量</li><li>用户量</li><li>用户活跃度</li><li>相关数据集大小</li></ul><p>增加服务器并不能完全增加系统的吞吐率， 大多数情况下都属于 USL 扩展</p><h1 id="如何扩展-MySQL"><a href="#如何扩展-MySQL" class="headerlink" title="如何扩展 MySQL"></a>如何扩展 MySQL</h1><p>MySQL 扩展通常分为”垂直”扩展和”水平”扩展。 垂直扩展就是增加更多的机器， 水平扩展是将任务拆分分配到多台机器上。</p><h2 id="知晓系统的底线"><a href="#知晓系统的底线" class="headerlink" title="知晓系统的底线"></a>知晓系统的底线</h2><ul><li>应用的功能是否都开发完毕了？ 是否到了需要扩展的阶段了。</li><li>预期的最大负载是多少？</li><li>如果局部失效如何防范。</li></ul><h2 id="扩展前先优化"><a href="#扩展前先优化" class="headerlink" title="扩展前先优化"></a>扩展前先优化</h2><ul><li>优化性能</li><li>升级硬件</li></ul><h2 id="向上扩展-垂直扩展"><a href="#向上扩展-垂直扩展" class="headerlink" title="向上扩展-垂直扩展"></a>向上扩展-垂直扩展</h2><p>建议使用更新的 MySQL 版本， 最大的配置是 256G RAM， 32 核 CPU， 再之后收益就递减了。<br>但是向上扩展的开销太大了， 并不是很好的选择。</p><h2 id="向外扩展-水平扩展"><a href="#向外扩展-水平扩展" class="headerlink" title="向外扩展-水平扩展"></a>向外扩展-水平扩展</h2><p>向外扩展可以分为三步：复制、拆分和数据分片</p><p>最简单的做法是通过复制将数据分发到多个服务器上， 通过备库进行读查询， 对以读为主的应用很有效。 此外常见的做法是工作负载到多个节点， 其中节点可能是一个服务器， 也可能是一个集群， 通常有以下几种：</p><ul><li>一个主-主复制双机机构， 一个主动，一个被动；</li><li>一主多备</li><li>一个主动服务器，使用分布式复制设备作为备库</li><li>一个基于存储区域网络的集群</li></ul><p>下面是一些不同的分布负载方案</p><h3 id="按功能拆分"><a href="#按功能拆分" class="headerlink" title="按功能拆分"></a>按功能拆分</h3><p>不同的节点执行不同的任务，比如门户网站将论坛、新闻、知识库等不同的功能所需的数据存在不同的数据库中。</p><p>此外也可以对单台服务器的数据进行划分， 前提是表与表之间不会进行关联操作。</p><p>实际上不能通过功能划分进行无限扩展， 当一个功能与单个 MySQL 绑定后就只能垂直扩展了。</p><h3 id="数据分片"><a href="#数据分片" class="headerlink" title="数据分片"></a>数据分片</h3><p>在扩展大型 MySQL 应用的方案中，数据分片是最通用且最成功的方法。在数据分片前需要考虑当前的应用是否需要分片， 比如正在搭建的博客网站， 预计有 1000 万用户，这个时候就算把所以用户数据放在内存中也是可行的， 但是当用户达到 5 亿时就可能需要对数据进行分片了。</p><p>如果在设计之初就已经预计到分片， 之后分片就会容易很多。</p><p>单台服务器的功能划分：</p><p><img src="/2020/04/06/mysql/note10-scaling-mysql/%E5%8D%95%E5%8F%B0%E6%9C%BA%E5%99%A8.jpg" alt="单台机器"></p><p>继续演进， 通过用户 ID 对文章和内容进行分片：<br><img src="/2020/04/06/mysql/note10-scaling-mysql/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8.jpg" alt="分布式存储"></p><p>如果事先知道应用会扩展到很大规模且了解功能划分的局限性， 就可以跳过中间步骤， 直接从单个节点升级为分片数据存储。</p><h3 id="选择分区键"><a href="#选择分区键" class="headerlink" title="选择分区键"></a>选择分区键</h3><p>数据分片的挑战在于查找与获取数据， 对经常查询的数据减少分片， 最关键的点在于为数据选择一个或多个分区键， 因为分区键决定了每一行分配在哪一个分片中。 当知道一个对象的分区键， 就知道了</p><ul><li>应该从哪里存储数据</li><li>应该从哪里查询数据</li></ul><p>一个好的分区键通常是数据库中一个非常重要的实体的主键， 例如通过用户 ID 来分割数据， 分片的单元就是用户。</p><p>选择分区键的时候尽可能选择能够避免跨分片查询的键， 同时也让分片足够小以免过大的数据导致问题。</p><h3 id="多个分区键"><a href="#多个分区键" class="headerlink" title="多个分区键"></a>多个分区键</h3><p>复杂数据分区困难时， 会拥有多个分区键。 例如需要对博客的数据按照用户 ID 和 文章 ID 进行分片， 这样即可以根据用户 ID 获取该用户的所有文章， 还可以通过文章 ID 获取该文章的所有评论。 </p><h3 id="跨分片查询"><a href="#跨分片查询" class="headerlink" title="跨分片查询"></a>跨分片查询</h3><p>大多数分片应用都有一些查询需要对多个分片的数据进行聚合或关联操作。 例如获取当前网站最受欢迎的用户， 就需要把所有分片访问一遍， 实际上需要拆分成多条并行执行的查询， 每个分片执行一条。</p><p>在并行查询时， 某些语言比如PHP对并行支持的并不好， 会利用 C 或者 JAVA 写一个辅助应用来执行聚合查询</p><p>同样的， 使用汇总表也可以提升跨分片查询的效率， 可以遍历所有分片来生成汇总表并将结果在每个分片上冗余存储。 </p><h3 id="分片与节点"><a href="#分片与节点" class="headerlink" title="分片与节点"></a>分片与节点</h3><p>分片和节点并不是一对一的关系， 尽可能让分片的大小小于节点的容量。</p><p>首先分片足够小便于管理， 使得数据的备份和恢复更加容易， 假设100 G 的数据， 分为 100 个 1G 的分片， 存储在单个节点上， 对数据加索引时， 单个100 G 的表的执行时间会比 100 个 1G 的分片执行的时间更长。 </p><p>其次， 小的分片更方便转移。</p><h3 id="节点上部署分片"><a href="#节点上部署分片" class="headerlink" title="节点上部署分片"></a>节点上部署分片</h3><p>通常有一下几种方法部署数据分片：</p><ul><li><p>每个分片使用单一数据库，且数据库名相同。对应的应用场景是多实例应用， 每个应用对应一个分片。</p></li><li><p>将多个分片的表放在一个数据库中， 每个表名包含分片号。</p></li><li><p>每个分片使用一个数据库， 数据库中包含所有应用需要的表， 库名中包含分片号但表名不包含分片号。 当应用连接到数据库病不指定数据库名时， 则无须为每个分片编写专门的查询。</p></li><li><p>每个分片使用一个数据库， 并在数据库名和表名包含分片号。</p></li><li><p>每个节点运行多个MySQL示例， 每个实例有一个或多个分片。</p></li></ul><h3 id="固定分配与动态分配"><a href="#固定分配与动态分配" class="headerlink" title="固定分配与动态分配"></a>固定分配与动态分配</h3><p>将数据分配到分片中有两种主要的做法： 固定分配和动态分配。两个方法都需要分区函数，行的分区键值作为输入，存储改行的分片作为输出。</p><p>固定分配的好处在于分区函数仅仅依赖于分区键的值， 这样做简单，开销低， 比如使用 CRC32() 做哈希， CRC32(111) % 100  = 81。 </p><p>动态分配将每个数据单元映射到一个分片， 假设数据表有 用户ID 与 分片 ID， 根据分区键（用户ID）就可以查到 分片号， 如果没有查到对应分片号， 可以选择将目标分片号与当前用户ID绑定或者延迟更新。</p><h3 id="混合分配"><a href="#混合分配" class="headerlink" title="混合分配"></a>混合分配</h3><p>混合使用固定分配和动态分配， 映射目录不大时， 动态分配很好胜任， 分片单元太多效果会变差。</p><h3 id="显式分配"><a href="#显式分配" class="headerlink" title="显式分配"></a>显式分配</h3><p>很少使用， 不适合在已有数据上分片。</p><h3 id="重新均衡分片数据"><a href="#重新均衡分片数据" class="headerlink" title="重新均衡分片数据"></a>重新均衡分片数据</h3><p>在分片间移动数据达到负载均衡。例如需要升级硬件时， 将用户数据从旧分片转移到新分片上， 无需暂停整个分片的服务， 也无需将其设置为只读。 但是进行均衡分片时会影响到用户的使用。</p><h3 id="生成全局唯一-ID"><a href="#生成全局唯一-ID" class="headerlink" title="生成全局唯一 ID"></a>生成全局唯一 ID</h3><p>通常单一数据存储时使用 AUTO_INCREMENT 列来获取唯一 ID， 但是涉及到多台服务器时就不生效了， 此时需要生产全局的唯一 ID， 通常有以下几种做法：</p><p>使用 auto_increment_inncrement 和 auto_increment_offset</p><pre><code>假设两台服务器， 一个偏移量为 1，另一台偏移量为 2， 这样一台服务器始终包含偶数， 一台服务器始终包含奇数。需要仔细配置。</code></pre><p>全局节点创建表：</p><pre><code>在一个全局数据库节点中创建一个包含 AUTO_INCREMENT 列的表， 通过这个表生成唯一的数字。</code></pre><p>使用 memcached</p><pre><code>memcached的 api 有一个 incr()函数，自动增长一个数字并返回结果。memcached不具备持久性，重启后会初始化缓存的值会从磁盘中查询最大的值，过程慢切不能保证原子性。</code></pre><p>批量分配数字</p><pre><code>从全局节点中请求一批数字。</code></pre><p>使用复合值</p><pre><code>使用复合值作为唯一 ID。</code></pre><p>使用 GUID 值</p><pre><code>使用 UUID() 函数生成全局唯一值</code></pre><p>使用全局分配器产生唯一 ID 需要注意避免单点争用成为性能瓶颈。</p><h3 id="分片工具"><a href="#分片工具" class="headerlink" title="分片工具"></a>分片工具</h3><p>使用抽象层可以避免直接让应用访问多个数据源， 而是将数据源隐藏在抽象层，抽象层主要完成以下工作：</p><ul><li>连接到正确的分片并进行查询</li><li>分布式一致性校验</li><li>跨分片结果集聚合</li><li>跨分片关联操作</li><li>锁和事务管理</li><li>创建新的数据分片</li></ul><p>常见的分片工具有 Hibernnate Shards 和 HiveDB。</p><h2 id="多实例扩展"><a href="#多实例扩展" class="headerlink" title="多实例扩展"></a>多实例扩展</h2><p>不要在一台服务器上只运行一个服务器实例，让数据分片足够小， 使每台机器都能放置多个分片， 这是一种向上扩展和向外扩展的组合方案。 </p><h2 id="通过集群扩展"><a href="#通过集群扩展" class="headerlink" title="通过集群扩展"></a>通过集群扩展</h2><p>对比 MySQL 与 NoSQL</p><h3 id="MySQL-Cluster"><a href="#MySQL-Cluster" class="headerlink" title="MySQL Cluster"></a>MySQL Cluster</h3><p>MySQL Cluster 由 NDB 数据库和 MySQL 存储引擎组成。 其中 NDB 是一个分布式、具备容错性、非共享的数据库， 提供同步复制以及节点间的数据自动分片。 NDB 是一个键-值数据存储， 无法执行类似聚合或者联结操作。</p><h3 id="Clustrix"><a href="#Clustrix" class="headerlink" title="Clustrix"></a>Clustrix</h3><p>Clustrix 是一个分布式数据库， 支持 MySQL 协议， 它可以直接替代 MySQL， 支持 ACID， 支持 MVCC 的事务型SQL 的数据库。与MySQL Cluster 的不同点在于 Clustrix 是完全分布式且能兼容 MySQL 协议。</p><h3 id="ScaleBase"><a href="#ScaleBase" class="headerlink" title="ScaleBase"></a>ScaleBase</h3><p>ScaleBase是一个代理器， 处于应用和多个后端 MySQL 服务器之间， 会把发起的查询进行分裂并将其分发到后端服务器并发执行， 然后汇总结果给应用。</p><h3 id="GenieDB"><a href="#GenieDB" class="headerlink" title="GenieDB"></a>GenieDB</h3><p>不支持 ACID， 最初用在地理上分布部署的 NoSQL 文档存储。</p><h3 id="Akiban"><a href="#Akiban" class="headerlink" title="Akiban"></a>Akiban</h3><p>查询加速器， 存储物理数据来匹配查询模式， 可以进行低开销的跨表关联操作。</p><h2 id="向内扩展"><a href="#向内扩展" class="headerlink" title="向内扩展"></a>向内扩展</h2><p>对不断增长的数据最简单的做法对不再需要的数据进行归档和清理， 设计和清理时需要考虑以下几点：</p><ul><li>对应用的影响</li><li>要归档的行</li><li>维护数据的一致性</li><li>避免数据丢失</li><li>解除归档</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 109. Convert Sorted List to Binary Search Tree</title>
      <link href="/2020/03/29/leetcode/linkedlist/convert-sorted-list-to-binary-search-tree/"/>
      <url>/2020/03/29/leetcode/linkedlist/convert-sorted-list-to-binary-search-tree/</url>
      
        <content type="html"><![CDATA[<p>Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.</p><a id="more"></a><p>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.</p><h1 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h1><pre><code>Given the sorted linked list: [-10,-3,0,5,9],One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:      0     / \   -3   9   /   / -10  5</code></pre><h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给定一个升序链表， 转换成高度平衡二叉树。<br>其实就是中序遍历变前序遍历， 关键点是找到树的根结点， 也就是升序链表的中间结点， 然后递归遍历。</p><h1 id="示意图"><a href="#示意图" class="headerlink" title="示意图"></a>示意图</h1><p><img src="/2020/03/29/leetcode/linkedlist/convert-sorted-list-to-binary-search-tree/%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="示意图"></p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedListToBST</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode temp = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            temp = slow;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 断开链表</span></span><br><span class="line">        <span class="keyword">if</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            temp.next = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            head = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(slow.val);</span><br><span class="line">        root.left = sortedListToBST(head);</span><br><span class="line">        root.right = sortedListToBST(slow.next);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每周一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> linkedlist </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 复制存在的问题</title>
      <link href="/2020/03/28/mysql/note9-replica-problems/"/>
      <url>/2020/03/28/mysql/note9-replica-problems/</url>
      
        <content type="html"><![CDATA[<p>MySQL 复制存在哪些问题?</p><a id="more"></a><h1 id="复制的问题及解决方案"><a href="#复制的问题及解决方案" class="headerlink" title="复制的问题及解决方案"></a>复制的问题及解决方案</h1><h2 id="数据损坏或丢失"><a href="#数据损坏或丢失" class="headerlink" title="数据损坏或丢失"></a>数据损坏或丢失</h2><p>当服务器崩溃、掉电、磁盘损坏等情况下， MySQL 复制并不能很好的恢复。需要从某个节点开始重启复制。<br>一下是意外关闭服务器，没有把数据及时刷新到磁盘带来的复制问题：</p><ul><li><p>master 意外关闭<br>  如果没有设置master 的 sync_binlog 选项， master 崩溃前没有将最后的二进制日志文件刷新到磁盘中，slave 也会因为读不到尚未写入磁盘的事件。</p></li><li><p>slave 意外关闭<br>  slave 意外关闭， 会去读 master.info 文件找到上次停止复制的位置， 但是该文件并没有同步写到磁盘，存储的信息就是错的。</p></li><li><p>master 的二进制文件损坏</p></li><li><p>slave 的中继日志损坏</p></li><li><p>二进制日志与 InnoDB 事务日志不同步</p></li><li><p>数据改变，事件仍是有效的 SQL</p></li><li><p>数据改变且事件是无效的SQL</p></li><li><p>数据遗漏且事件的长度是错误的</p></li><li><p>某些事件已经损坏，或者偏移量也是错的</p></li></ul><h2 id="使用非事务型表"><a href="#使用非事务型表" class="headerlink" title="使用非事务型表"></a>使用非事务型表</h2><p>非事务型表更新发送错误时，可能会导致 master 和 slave 的数据不一致， 例如在查询过程中被 kill。如果是使用 MyISAM 表， 关闭 MySQL 之前需要确保已经运行了 STOP SLAVE。</p><h2 id="混合事务型和非事务型表"><a href="#混合事务型和非事务型表" class="headerlink" title="混合事务型和非事务型表"></a>混合事务型和非事务型表</h2><p>如果混合使用了事务型和非事务型表， 发生回滚时， MySQL 会回滚事务型表的更新， 但非事务型表则被永久地更新了。此时日志会记录一条 ROLLBACK 语句到日志中， 同样的语句也会在 slave 执行。<br>一般不要事务型表与非事务型表进行混用。除非是基于行的复制</p><h2 id="不确定的语句"><a href="#不确定的语句" class="headerlink" title="不确定的语句"></a>不确定的语句</h2><p>基于语句的复制， 当通过不确定的方式更改数据也会导致主备不一致。 比如 LIMIT..UPDTAE 进行更新数据， 取决于查找行的顺序， 除非能保证主备库上的顺序是相同的。</p><h2 id="主备间使用了不同的存储引擎"><a href="#主备间使用了不同的存储引擎" class="headerlink" title="主备间使用了不同的存储引擎"></a>主备间使用了不同的存储引擎</h2><p>主备使用不同的存储引擎时， 基于语句的复制可能会造成主备上执行相同的语句得到的结果不同</p><h2 id="备库数据发送改变"><a href="#备库数据发送改变" class="headerlink" title="备库数据发送改变"></a>备库数据发送改变</h2><p>备库数据发送改表时， 执行：<br>INSERT INTO tb1 SELECT * FROM tb2;<br>会导致主备数据不一致。</p><h2 id="不唯一的服务器-ID"><a href="#不唯一的服务器-ID" class="headerlink" title="不唯一的服务器 ID"></a>不唯一的服务器 ID</h2><p>不小心将两台服务器设置了相同的服务器 ID， 在主库上回发现两台备库只有一台连接到了主库， 在备库的错误日志中会发现反复的重连和断开信息。</p><h2 id="未定义的服务器-ID"><a href="#未定义的服务器-ID" class="headerlink" title="未定义的服务器 ID"></a>未定义的服务器 ID</h2><p>如果没有在 my.cnf 中定义服务器 ID， 可以通过 CHANGE MASTER TO 设置备库，但是无法启动复制， 因为没有显式的为当前服务器设置服务器 ID。</p><h2 id="对未复制数据的依赖性"><a href="#对未复制数据的依赖性" class="headerlink" title="对未复制数据的依赖性"></a>对未复制数据的依赖性</h2><p>避免主库上创建备库不存在的表。</p><h2 id="丢失的临时表"><a href="#丢失的临时表" class="headerlink" title="丢失的临时表"></a>丢失的临时表</h2><p>临时表与基于语句复制的方式是不相容的， 当备库崩溃或者正常关闭时， 复制线程用于的临时表会丢失， 而依赖于临时表的语句都会失败。</p><h2 id="不复制索引的更新"><a href="#不复制索引的更新" class="headerlink" title="不复制索引的更新"></a>不复制索引的更新</h2><p>错误地使用 SET SQL_LOG_BIN = 0 或者没有理解过滤规则， 备库可能会丢失主库上已经发生的更新。</p><h2 id="InnoDB-加锁读引起的锁竞争"><a href="#InnoDB-加锁读引起的锁竞争" class="headerlink" title="InnoDB 加锁读引起的锁竞争"></a>InnoDB 加锁读引起的锁竞争</h2><p>正常情况下， InnoDBd 读操作是非阻塞的， 但是在基于语句复制的方式下，执行 INSERT…SELECT会锁定表上的所有行。加锁会导致主库上的语句串行化， 以确保和备库上的执行方式相符。<br>第一种缓解方法， 在主库尽快地提交事务以释放锁。<br>另外一种替换 INSERT…SELECT语句， 在主库先执行 SELECT INTO OUTFILE, 再执行 LOAD DATA INFILE， 这种方法更快且不需要加锁</p><h2 id="主-主模式下写入数据到两台主库"><a href="#主-主模式下写入数据到两台主库" class="headerlink" title="主-主模式下写入数据到两台主库"></a>主-主模式下写入数据到两台主库</h2><p>之前有提到过使用 AUTO_INCREMENT 自增主键解决自增列冲突问题。但自增主键也会带来一些其他的问题:</p><ul><li>很难再复制拓扑间做故障转移</li><li>数字之间有间隙， 会引起键空间浪费</li><li>很多时候并不会使用 AUTO_INCREMENT 作为主键</li></ul><p>替代方法有使用 serverId 作为主键， 对 serverId 进行位运算, 可以采用 MD5()或者 UUID()等函数获取伪随机数</p><h2 id="过大的复制延迟"><a href="#过大的复制延迟" class="headerlink" title="过大的复制延迟"></a>过大的复制延迟</h2><p>复制产生延迟一般有两种方式： 突然产生延迟再跟上（通常是由于一条运行很长时间的查询导致的）， 或者稳定的延迟增大。</p><p>为了避免过大的延迟， 有以下措施：</p><ul><li>不要重复写操作中代价较高的部分</li><li>复制之外并行写入</li><li>为复制线程预取缓存</li></ul><h2 id="来自主库过大的包"><a href="#来自主库过大的包" class="headerlink" title="来自主库过大的包"></a>来自主库过大的包</h2><p>主库的 max_allowd_packet 的值与备库的值不匹配</p><h2 id="受限制的复制带宽"><a href="#受限制的复制带宽" class="headerlink" title="受限制的复制带宽"></a>受限制的复制带宽</h2><p>使用受限的带宽进行复制， 可以开启备库的 slave_compressed_protocol 选项。</p><h2 id="磁盘空间不足"><a href="#磁盘空间不足" class="headerlink" title="磁盘空间不足"></a>磁盘空间不足</h2><p>当二进制日志、中继日志或临时文件将磁盘撑满，尤其是主库执行了 LOAD DATA INFILE 查询并在备库开启了 log_slave_updates。 延迟越严重，接收到尚未执行的中继日志就越多，占用的磁盘空间也越大。 可以通过监控磁盘并设置 relay_log_space 避免这种问题。</p><h2 id="复制的局限性"><a href="#复制的局限性" class="headerlink" title="复制的局限性"></a>复制的局限性</h2><p>大量的SQL 函数和编程不能被可靠的复制（基于语句的复制), 很难确保代码中不会出现这样的问题。<br>另一个局限性是服务器的 bug， 大多数 MySQL 都存储历史遗留的复制 bug。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 92. Reverse Linked List II</title>
      <link href="/2020/03/22/leetcode/linkedlist/reverse-linked-list-ii/"/>
      <url>/2020/03/22/leetcode/linkedlist/reverse-linked-list-ii/</url>
      
        <content type="html"><![CDATA[<p>Reverse a linked list from position m to n. Do it in one-pass.</p><a id="more"></a><p>Note: 1 ≤ m ≤ n ≤ length of list.</p><h1 id="Example"><a href="#Example" class="headerlink" title="Example:"></a>Example:</h1><blockquote><p>Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4</p></blockquote><blockquote><p>Output: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>题意为给定 m、n， 翻转从第 m 到第 n 个结点。</p><p>具体分三步：</p><ol><li>先遍历 m-1 个节点， 找到待翻转的结点为尾节点</li><li>遍历 n-m-1 次， 依次翻转</li></ol><h1 id="示意图"><a href="#示意图" class="headerlink" title="示意图"></a>示意图</h1><p><img src="/2020/03/22/leetcode/linkedlist/reverse-linked-list-ii/demo.png" alt="示意图"></p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseBetween</span><span class="params">(ListNode head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ListNode dummyHead = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    dummyHead.next = head;</span><br><span class="line">    ListNode pre = dummyHead;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 先遍历 m 个结点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        pre = pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 翻转前的尾结点</span></span><br><span class="line">    ListNode tail = pre.next;</span><br><span class="line">    ListNode temp;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 依次翻转</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - m; i++) &#123;</span><br><span class="line">        temp = pre.next;</span><br><span class="line">        pre.next = tail.next;</span><br><span class="line">        tail.next = tail.next.next;</span><br><span class="line">        pre.next.next = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每周一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> linkedlist </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 复制概述</title>
      <link href="/2020/03/21/mysql/note8-replication-basic/"/>
      <url>/2020/03/21/mysql/note8-replication-basic/</url>
      
        <content type="html"><![CDATA[<p>复制是构建大规模、高性能应用的基础。</p><a id="more"></a><p>复制可以让一台 MySQL 服务器与其他服务器保持同步， 提升集群的可用性， 避免因为一台MySQL 服务器挂掉导致整个系统不可用。</p><h1 id="复制概述"><a href="#复制概述" class="headerlink" title="复制概述"></a>复制概述</h1><h2 id="复制的类型"><a href="#复制的类型" class="headerlink" title="复制的类型"></a>复制的类型</h2><p>MySQL 有两种复制方式： <strong>基于行的复制和基于语句的复制</strong>。二者都是通过记录主库的二进制日志来进行复制。</p><ul><li><p>基于语句的复制：在主服务器执行的 SQL 语句，在从服务器执行相同的语句， 基于语句的复制是mysql 默认的复制方式， 效率高。</p></li><li><p>基于行的复制：从 5.1 版本开始支持， 把改变的内容复制过去。</p></li><li><p>混合复制： 当发现基于语句的复制不能执行下去时， 转换为基于行的复制。</p></li></ul><p>MySQL 的复制是向后兼容的， 新版本的服务器可以做为旧版本的服务器的备库。</p><p>复制并不会增加主库的开销， 主要是启动二进制日志带来的开销。</p><h2 id="复制解决了什么问题"><a href="#复制解决了什么问题" class="headerlink" title="复制解决了什么问题"></a>复制解决了什么问题</h2><p>MySQL 复制具有以下一些用途：</p><ul><li>数据分布</li><li>负载均衡</li><li>备份</li><li>高可用性和故障切换</li><li>MySQL 升级测试</li></ul><h2 id="复制是如何工作的"><a href="#复制是如何工作的" class="headerlink" title="复制是如何工作的"></a>复制是如何工作的</h2><p>复制分三步：</p><ol><li>主库 (master) 将数据的更改记录到二进制日志 (binary log）中;</li><li>备库 (slave) 从主库的日志复制到自身的中继日志 (relay log);</li><li>备库读取中继日志中的事件， 修改和主库相对应的数据。</li></ol><p><img src="/2020/03/21/mysql/note8-replication-basic/replication-works.jpg" alt="复制原理"></p><h1 id="复制配置"><a href="#复制配置" class="headerlink" title="复制配置"></a>复制配置</h1><p>有两台 MySQL 服务器 master 和 slave, master 为主服务器， slave 为从服务器， 初始状态时两台服务器数据相同， 当 master 服务器发生变化时， slave 也跟着发生相应的变化， 使得 master 与 slave 的数据信息同步达到备份的目的。</p><h2 id="创建账号"><a href="#创建账号" class="headerlink" title="创建账号"></a>创建账号</h2><p>在 master 数据库创建一个备份账户，进行复制操作的用户被赋予 REPLICATION SLAVE 权限。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; GRANT REPLICATION SLAVE,RELOAD,SUPER ON *.*  TO backup@<span class="string">'10.26.15.167'</span> IDENTIFIED BY <span class="string">'1234'</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="function">rows <span class="title">affected</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br></pre></td></tr></table></figure><p>建立一个帐户backup，并且只能允许从 10.26.15.167 这个地址上来登陆，密码是1234。</p><h2 id="拷贝数据"><a href="#拷贝数据" class="headerlink" title="拷贝数据"></a>拷贝数据</h2><p>将主库的数据拷贝到从库中去， 拷贝的过程中， 禁止在主库和从库进行写操作， 这样做的目的是为了保持两数据库中的数据一致。</p><h2 id="设置主库、备库"><a href="#设置主库、备库" class="headerlink" title="设置主库、备库"></a>设置主库、备库</h2><p>假设主库是 server1， 需要在主库的 my.cnf 下增加或修改相应的内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">log_bin = mysql-bin </span><br><span class="line">server_id = <span class="number">10</span></span><br></pre></td></tr></table></figure><p>备库的配置也需要在 my.cnf 中增加类似的配置， 配置完成后重启服务器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">log_bin     = mysql-bin </span><br><span class="line">server_id   = <span class="number">2</span> </span><br><span class="line">relay_log   = /var/lib/mysql/mysql-relay-bin   # 中继日志</span><br><span class="line">log_slave_updates = <span class="number">1</span></span><br><span class="line">read_only  = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>实际情况中， 以上的这些参数只有 server_id 是必需的。</p><h2 id="启动slave"><a href="#启动slave" class="headerlink" title="启动slave"></a>启动slave</h2><p>接下来就是让 slave 连接 master，并开始重做 master 二进制日志中的事件。具体操作通过 CHANGE MASTER TO 来执行， 替代了 my.cnf 中相应的配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CHANGE MASTER TO MASTER_HOST=<span class="string">'server1'</span>,</span><br><span class="line">-&gt; MASTER_USER=<span class="string">'repl'</span>,</span><br><span class="line">-&gt; MASTER_PASSWORD=<span class="string">'p4ssword'</span>,</span><br><span class="line">-&gt; MASTER_LOG_FILE=<span class="string">'mysql-bin.000001'</span>,</span><br><span class="line">-&gt; MASTER_LOG_POS=<span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>MASTER_LOG_POS 被置为 0 ，因为它是日志开始的地方。设置完毕后通过 SHOW SLAVE STATUS 来查看备库是否成功启动。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW SLAVE STATUS\G</span><br><span class="line">*************************** <span class="number">1</span>. row ***************************</span><br><span class="line">             Slave_IO_State:</span><br><span class="line">                Master_Host: server1</span><br><span class="line">                Master_User: repl</span><br><span class="line">                Master_Port: <span class="number">3306</span></span><br><span class="line">              Connect_Retry: <span class="number">60</span></span><br><span class="line">            Master_Log_File: mysql-bin.000001</span><br><span class="line">        Read_Master_Log_Pos: <span class="number">4</span></span><br><span class="line">             Relay_Log_File: mysql-relay-bin.000001</span><br><span class="line">              Relay_Log_Pos: <span class="number">4</span></span><br><span class="line">      Relay_Master_Log_File: mysql-bin.000001</span><br><span class="line">           Slave_IO_Running: No</span><br><span class="line">          Slave_SQL_Running: No</span><br><span class="line">                             ...omitted...</span><br><span class="line">      Seconds_Behind_Master: NULL</span><br></pre></td></tr></table></figure><p>其中 Slave_IO_State，Slave_IO_Running， Slave_SQL_Running 置为 No， 表示还没有开始复制。Relay_Log_Pos 为 4 意味着日志的起始位置是 4 而不是 0， 因为 0 只是日志文件开始的位置，并不是日志位置，MySQL 知道第一个事件起始于 4。</p><p>开启复制：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; START SLAVE;</span><br></pre></td></tr></table></figure><p>现在再用 SHOW SLAVE STATUS 命令检查：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW SLAVE STATUS\G</span><br><span class="line"></span><br><span class="line">*************************** <span class="number">1</span>. row ***************************</span><br><span class="line">             Slave_IO_State: Waiting <span class="keyword">for</span> master to send event</span><br><span class="line">                Master_Host: server1</span><br><span class="line">                Master_User: repl</span><br><span class="line">                Master_Port: <span class="number">3306</span></span><br><span class="line">              Connect_Retry: <span class="number">60</span></span><br><span class="line">            Master_Log_File: mysql-bin.000001</span><br><span class="line">        Read_Master_Log_Pos: <span class="number">164</span></span><br><span class="line">             Relay_Log_File: mysql-relay-bin.000001</span><br><span class="line">              Relay_Log_Pos: <span class="number">164</span></span><br><span class="line">      Relay_Master_Log_File: mysql-bin.000001</span><br><span class="line">           Slave_IO_Running: Yes</span><br><span class="line">          Slave_SQL_Running: Yes</span><br><span class="line">                             ...omitted...</span><br><span class="line">      Seconds_Behind_Master: <span class="number">0</span></span><br></pre></td></tr></table></figure><p>可以看到 I/O 线程和 SQL 线程已经开始运行。Seconds_Behind_Master 也不再为 NULL, 日志的位置也发生了变化。 查看下线程列表中的复制线程， 在主库可以看到由备库 I/O 线程向主库发起的连接。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show processlist \G</span><br><span class="line"></span><br><span class="line">*************************** <span class="number">1</span>. row ***************************</span><br><span class="line">     Id: <span class="number">1</span></span><br><span class="line">   User: root</span><br><span class="line">   Host: localhost:<span class="number">2096</span></span><br><span class="line">     db: test</span><br><span class="line">Command: Query</span><br><span class="line">   Time: <span class="number">0</span></span><br><span class="line"> State: NULL</span><br><span class="line">   Info: show processlist</span><br><span class="line">*************************** <span class="number">2</span>. row ***************************</span><br><span class="line">     Id: <span class="number">2</span></span><br><span class="line">   User: repl</span><br><span class="line">   Host: localhost:<span class="number">2144</span></span><br><span class="line">     db: NULL</span><br><span class="line">Command: Binlog Dump</span><br><span class="line">   Time: <span class="number">1838</span></span><br><span class="line"> State: Has sent all binlog to slave; waiting <span class="keyword">for</span> binlog to be updated</span><br><span class="line">   Info: NULL</span><br><span class="line"><span class="number">2</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br></pre></td></tr></table></figure><p>在slave服务器上运行该语句， 其中行 1是 I/O 线程， 行 2 是 SQL 线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show processlist \G</span><br><span class="line"></span><br><span class="line">*************************** <span class="number">1</span>. row ***************************</span><br><span class="line">     Id: <span class="number">1</span></span><br><span class="line">   User: system user</span><br><span class="line">   Host:</span><br><span class="line">     db: NULL</span><br><span class="line">Command: Connect</span><br><span class="line">   Time: <span class="number">2291</span></span><br><span class="line"> State: Waiting <span class="keyword">for</span> master to send event</span><br><span class="line">   Info: NULL</span><br><span class="line">*************************** <span class="number">2</span>. row ***************************</span><br><span class="line">     Id: <span class="number">2</span></span><br><span class="line">   User: system user</span><br><span class="line">   Host:</span><br><span class="line">     db: NULL</span><br><span class="line">Command: Connect</span><br><span class="line">   Time: <span class="number">1852</span></span><br><span class="line"> State: Has read all relay log; waiting <span class="keyword">for</span> the slave I/O thread to update it</span><br><span class="line">   Info: NULL</span><br><span class="line"></span><br><span class="line">*************************** <span class="number">3</span>. row ***************************</span><br><span class="line">     Id: <span class="number">5</span></span><br><span class="line">   User: root</span><br><span class="line">   Host: localhost:<span class="number">2152</span></span><br><span class="line">     db: test</span><br><span class="line">Command: Query</span><br><span class="line">   Time: <span class="number">0</span></span><br><span class="line"> State: NULL</span><br><span class="line">   Info: show processlist</span><br><span class="line"><span class="number">3</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br></pre></td></tr></table></figure><h2 id="增加新的-SLAVE-服务器"><a href="#增加新的-SLAVE-服务器" class="headerlink" title="增加新的 SLAVE 服务器"></a>增加新的 SLAVE 服务器</h2><p>前面讲到的例子是主备两台服务器的数据相同， 并且知道当前主库的二进制日志。 但是大多数情况下是有一个已经运行了一段时间的主库， 然后用新安装的备库与之同步， 此时备库还没有数据。</p><p>有几种方法来初始化备库或者从其他服务器克隆数据到备库。 包括从主库复制数据、从另一台备库克隆数据， 以及使用最近的一次备份启动备库。 需要三个条件让主库、备库保持一致：</p><ul><li>master 某个时间点的数据快照。</li><li>master 当前的二进制日志文件， 和获得数据快照时在该二进制日志文件中的偏移量， 通过这两个值可以确定二进制日志的位置。</li><li>master从快照时间到现在的二进制日志。</li></ul><p>可以通过以下几种方法从 master 克隆到 slave：</p><ol><li><p>冷拷贝(cold copy)<br>关闭master， 将数据复制到 slave， 复制完毕后重启 master。 缺点： 复制时需要关闭 master。</p></li><li><p>热拷贝(warm copy)<br>仅限于 MyISAM表， 可以在 master 运行时使用 mysqlhotcopy 或 rsync 来复制数据。</p></li><li><p>使用mysqldump</p></li></ol><ul><li>锁表， 避免其他连接修改数据库。 否则会造成数据不一致的问题<br>  mysql&gt; FLUSH TABLES WITH READ LOCK;</li><li>在另一个连接使用 mysqldum 创建一个你想进行复制的数据库的存储：<br>shell&gt; mysqldump –all-databases –lock-all-tables &gt;dbdump.db</li><li>对表释放锁</li></ul><h1 id="复制的原理"><a href="#复制的原理" class="headerlink" title="复制的原理"></a>复制的原理</h1><p>之前介绍的是一些复制的基本概念， 接下来深入地了解复制， 看看复制是如何工作的， 有哪些优缺点。</p><h2 id="基于语句的复制"><a href="#基于语句的复制" class="headerlink" title="基于语句的复制"></a>基于语句的复制</h2><p>MySQL5.0 及之前更老的版本是只支持基于语句的复制（逻辑复制）。 在基于语句的复制模式下， 主库会记录那些造成数据更改的查询， 当备库读取并重放这些事件时， 实际上是把主库执行过的语句再执行一遍。</p><p>基于语句的复制十分简单，理论上将简单地记录和执行这些语句即可让主备保持同步， 另一个好处是二进制日志更加紧凑， 所以基于语句的复制不会占用太多的带宽。</p><p>但是在基于语句复制的过程中还依赖于其他的元素，比如当前的时间戳，除此之外还存在一些无法被正确复制的SQL， 例如使用 CURRENT_USER()函数的语句；</p><p>另一个问题是更新必须是串行的，需要更多的锁。</p><h2 id="基于行的复制"><a href="#基于行的复制" class="headerlink" title="基于行的复制"></a>基于行的复制</h2><p>MySQL5.1 开始支持基于行的复制， 这种方式会将实际数据记录在二进制日志中。 优点是任何语句都可以正确的工作， 一些语句的效率更高。 缺点是二进制文件可能很大而且不直观。</p><p>对于一些语句，基于行的复制能够更有效的工作，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="function">INSERT INTO <span class="title">summary_table</span><span class="params">(col1, col2, sum_col3)</span></span></span><br><span class="line"><span class="function">    -&gt; SELECT col1, col2, <span class="title">sum</span><span class="params">(col3)</span></span></span><br><span class="line"><span class="function">    -&gt; FROM enormous_table</span></span><br><span class="line"><span class="function">    -&gt; GROUP BY col1, col2</span>;</span><br></pre></td></tr></table></figure><p>假设，只有三种唯一的col1和col2的组合，但是，该查询会扫描原表的许多行，却仅返回三条记录。此时，基于行的复制效率更高。</p><p>另一方面，下面的语句，基于语句的复制更有效：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; UPDATE enormous_table SET col1 = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>此时使用基于行的复制代价会非常高。由于两种方式不能对所有情况都能很好的处理，所以，MySQL 5.1支持在基于语句的复制和基于记录的复制之前动态交换。你可以通过设置session变量binlog_format来进行控制。</p><h2 id="基于语句复制与基于行复制的优缺点"><a href="#基于语句复制与基于行复制的优缺点" class="headerlink" title="基于语句复制与基于行复制的优缺点"></a>基于语句复制与基于行复制的优缺点</h2><table><thead><tr><th></th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>基于语句的复制模式</td><td>基于语句的复制更灵活， 哪怕是主备表不同单类型能够兼容或者是列不同等， 而且基于语句出现问题容易排查</td><td>对触发器和存储过程不友好， 有很多 bug</td></tr><tr><td>基于行的复制模式</td><td>SQL 构造器、触发器、存储过程都能正确执行，应用广阔。不需要太多的锁。占用更少的 CPU</td><td>无法判断执行了哪些SQL， 出现问题难以排查</td></tr></tbody></table><h2 id="复制文件"><a href="#复制文件" class="headerlink" title="复制文件"></a>复制文件</h2><p>复制中除了二进制日志和中继日志文件呢， 还用到了以下的一些文件：</p><ul><li><p>mysql-bin.index：</p><p>  当在服务器开启二进制日志时， 同时会生成一个和二进制日志同名但以.index 为后缀的文件，它用来定位磁盘上的二进制日志文件。</p></li><li><p>mysql-relay-bin-index：</p><p>  中继日志的索引文件， 和mysql-bin.index 的作用类似。</p></li><li><p>master.info:</p><p>  保存 master 库的信息， 不能删除， 否则 slave 无法连接到 master。</p></li><li><p>relay-log.info：</p><p>  包含当前备库复制的二进制日志和中继日志坐标， 同样不能删除， 否则无法获知从哪个位置开始复制。</p></li></ul><h2 id="发送复制事件到其他-slave"><a href="#发送复制事件到其他-slave" class="headerlink" title="发送复制事件到其他 slave"></a>发送复制事件到其他 slave</h2><p>当开启 log_slave_updates 选项可以让 slave 变成其他服务器的master。 slave 把执行过的事件记录在自己的二进制日志中， 它的slave 就可以从日志中检索并执行事件</p><p><img src="/2020/03/21/mysql/note8-replication-basic/replicaiton-to-slave.jpg" alt="slave 作为 master 发送复制事件"></p><h2 id="复制过滤器"><a href="#复制过滤器" class="headerlink" title="复制过滤器"></a>复制过滤器</h2><p>复制过滤器可以让你只复制一部分数据， 有两种复制过滤：master 上过滤记录到二进制日志文件的事件， slave 上过滤记录到中继日志的事件。</p><p><img src="/2020/03/21/mysql/note8-replication-basic/replication-of-filter.jpg" alt="复制过滤器"></p><h1 id="复制的常见拓扑结构"><a href="#复制的常见拓扑结构" class="headerlink" title="复制的常见拓扑结构"></a>复制的常见拓扑结构</h1><p>复制体系结构有以下一些基本原则：</p><ul><li>一个 MySQL slave 实例只能有一个 master。</li><li>每个 slave 必须有一个唯一的 server id。</li><li>一个 master 可以有多个 slave</li><li>如果打开了 log_slave_updates 选项， 一个 slave 可以将主库的数据变化传播给其他的 slave。</li></ul><h2 id="一个-master-多个-slave"><a href="#一个-master-多个-slave" class="headerlink" title="一个 master 多个 slave"></a>一个 master 多个 slave</h2><p>一主多备是最简单的拓扑结构， slave 之间没有交互。<br>当少量写大量读时这种结构非常有用， 将读操作分摊到多个 slave， 从而减小 master 的压力。但是当 slave 增加到一定程度时， slave 对 master 的负载以及网络带宽都会成为性能瓶颈。</p><p><img src="/2020/03/21/mysql/note8-replication-basic/%E4%B8%80%E4%B8%BB%E5%A4%9A%E4%BB%8E.jpg" alt="一主多从"></p><p>这种结构虽然简单， 但是很灵活， 足以满足大多数需求， 一些建议：</p><ul><li>不同的 slave 起到不同的作用（使用不同的索引或者不同的存储引擎）。</li><li>用一个 slave 当做代用的 master， 只进行复制。</li><li>用一个远程 slave， 作为灾备</li></ul><h2 id="主动-主动模式下的-Master-Master-复制"><a href="#主动-主动模式下的-Master-Master-复制" class="headerlink" title="主动-主动模式下的 Master-Master 复制"></a>主动-主动模式下的 Master-Master 复制</h2><p>Master-Master 复制的两台服务器，既是  master，又是另一台服务器的 slave。任何一方的变更都会同步给另一方。</p><p><img src="/2020/03/21/mysql/note8-replication-basic/master-master-of-active.jpg" alt="主动模式下的多主复制"></p><p>master-master 模式带来的最大问题是如何解决冲突， 如果两台服务器同时修改一条记录。 在 MySQL5.0 之后通过 auto_increment_inrement 和auto_increment_offset， 可以让 MySQL 自动为 INSERT 语句选择不互相冲突的值， 但这仅仅解决了同时想一个包含 AUTO_INCREMENT 列的表插入数据造成的冲突。<br>在两台主库上同时写入数据还是很危险， 假设同时执行下面的两条语句：</p><ul><li><p>第一台 master 上：<br>  msyql&gt; UPDATE tbl SET col = col + 1;</p></li><li><p>第二台 master 上：<br>  msyql&gt; UPDATE tbl SET col = col * 2;</p></li></ul><p>结果可能是一台服务器上值为 4， 一台服务器上值为 3， 而且没有报任何错误。所以这种模式很少使用。</p><h2 id="主动-被动模式下的-Master-Master-复制"><a href="#主动-被动模式下的-Master-Master-复制" class="headerlink" title="主动-被动模式下的 Master-Master 复制"></a>主动-被动模式下的 Master-Master 复制</h2><p>这是master-master结构变化而来的，它避免了M-M的缺点，实际上，这是一种具有容错和高可用性的系统。它的不同点在于其中一个服务只能进行只读操作。如图：</p><p><img src="/2020/03/21/mysql/note8-replication-basic/master-master-of-passive.jpg" alt="被动模式下的多主复制"></p><p>这种拓扑结构使得反复切换主动和被动服务器很方便， 可以应用在故障转移和故障恢复中。</p><h2 id="用于备库的主-主结构-Master-Master-with-Slaves"><a href="#用于备库的主-主结构-Master-Master-with-Slaves" class="headerlink" title="用于备库的主-主结构(Master-Master with Slaves)"></a>用于备库的主-主结构(Master-Master with Slaves)</h2><p><img src="/2020/03/21/mysql/note8-replication-basic/master-master-with-slaves.jpg" alt="多主多备"></p><p>这种配置的有点事增加了冗余， 对于不同地理位置的复制拓扑， 能够献出单点失效的问题， 同样的， 查询还是分配在 slave 上。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>桥接模式</title>
      <link href="/2020/03/15/design-pattern/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/03/15/design-pattern/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>当前有一个需求，既需要画出三角形、正方形， 同时还需要对它们上不同的颜色， 你会采取什么样的设计?</p><a id="more"></a><h1 id="什么是桥接模式"><a href="#什么是桥接模式" class="headerlink" title="什么是桥接模式"></a>什么是桥接模式</h1><p>桥接模式(Bridge Pattern)是结构型模式的一种。提供抽象化与实现化之间的桥接，将抽象与实现解耦，使得二者可以独立变化的一种设计模式。</p><h1 id="桥接模式组成"><a href="#桥接模式组成" class="headerlink" title="桥接模式组成"></a>桥接模式组成</h1><ul><li>Abstraction: 抽象类，拥有一个 Implementor 类型的对象引用</li><li>RefinedAbstraction: 扩充抽象类，扩展 Abstraction 的接口定义</li><li>Implementor: 实现类接口</li><li>ConcreteImplementor: 具体实现类，实现 Implementor 接口，给出具体实现</li></ul><h1 id="桥接模式UML"><a href="#桥接模式UML" class="headerlink" title="桥接模式UML"></a>桥接模式UML</h1><p><img src="/2020/03/15/design-pattern/桥接模式/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F.png" alt="桥接模式UML"></p><h1 id="为什么使用桥接模式"><a href="#为什么使用桥接模式" class="headerlink" title="为什么使用桥接模式"></a>为什么使用桥接模式</h1><p>还是拿画图来举例子， 现在不仅需要画出圆形、正方形、三角形， 还需要对不同的形状上色，如红、绿、蓝色等。 此时有两种方案：</p><ul><li>第一种设计方案为每种图形都提供一套各种颜色的版本</li><li>第二种根据实际对需要的形状和颜色组合</li></ul><p>方案一很容易让大家想到工厂模式， 但是工厂模式的抽象产品中加入颜色的定义不仅带来了耦合， 还会带来类爆炸的问题， 如果新增一种颜色， 对继承的类不是很友好。方案二则是桥接模式应用，将继承关系转化为组合关联关系，降低了类与类间的耦合，同时也减少了代码量。</p><p>用代码示例， 现在的需求是画出圆、正方形</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         System.out.println(<span class="string">"draw a  circle"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">Recntangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         System.out.println(<span class="string">"draw a  recntangle"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Shape circle = <span class="keyword">new</span> Circle();</span><br><span class="line">        circle.draw();</span><br><span class="line"></span><br><span class="line">        Shape rectangle = <span class="keyword">new</span> Rectangle();</span><br><span class="line">        rectangle.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在需求变更， 想要对图形上色， 分别有红、绿、蓝三种颜色</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">RedCircle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         System.out.println(<span class="string">"draw a  red circle"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">GreenCircle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         System.out.println(<span class="string">"draw a  red circle"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">BlueCircle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         System.out.println(<span class="string">"draw a  red circle"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//......省略</span></span><br></pre></td></tr></table></figure><p>按上面的做法，Recntangle 也需要实现三个类， 2*3 = 6 现在需要维护六个类， 保不齐哪天再发生变化，维护的类实在是太多了。接下来看下采用桥接模式如何来做</p><h1 id="桥接模式的示例"><a href="#桥接模式的示例" class="headerlink" title="桥接模式的示例"></a>桥接模式的示例</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先是实现类接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DrawApi</span> </span>&#123;    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">drawWithColor</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> DrawApi drawApi;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Shape</span><span class="params">(DrawApi drawApi)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.drawApi = drawApi;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体实现类， 分别为Circle 与 Recntangle 类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">(DrawApi drawApi)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(drawApi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        drawApi.drawWithColor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Rectangle</span><span class="params">(DrawApi drawApi)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(drawApi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        drawApi.drawWithColor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 接口实现类， 为具体形状上色</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreenCircle</span> <span class="keyword">implements</span> <span class="title">DrawApi</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawWithColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"draw a green circle"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedRectangle</span> <span class="keyword">implements</span> <span class="title">DrawApi</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawWithColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"draw a red rectangle"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BridgePatternClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Shape readCircle = <span class="keyword">new</span> Circle(<span class="keyword">new</span> GreenCircle());</span><br><span class="line">        readCircle.draw();</span><br><span class="line"></span><br><span class="line">        Shape redRectangle = <span class="keyword">new</span> Rectangle(<span class="keyword">new</span> RedRectangle());</span><br><span class="line">        redRctangle.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><blockquote><p>draw a green circle</p><p>draw a red rectangle</p></blockquote><p>可以看到采用桥接模式后， 维护的类大大减少， 而且还可以将画图与上色两个功能分离开。</p><h1 id="桥接模式的特点"><a href="#桥接模式的特点" class="headerlink" title="桥接模式的特点"></a>桥接模式的特点</h1><p>优点： </p><ul><li>分离抽象接口及其实现部分, Client 和 Abstraction 交互, 不暴露 Implementation 的细节.；</li><li>桥接模式有时类似于多继承方案，但是多继承方案违背了类的单一职责原则（即一个类只有一个变化的原因），桥接模式是比多继承方案更好的解决方法；</li><li>桥接模式提升了系统的可扩展性，扩展一个新的特性不需要修改原有系统，符合“开闭原则；</li></ul><p>缺点：</p><ul><li>桥接模式的引入增加了系统的设计难度，不易理解， 由于聚合关系建立在抽象层， 要求对抽象进行设计；</li><li>桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围具有一定的局限性，如何正确识别两个独立维度也需要一定的经验积累。</li></ul><h1 id="桥接模式的应用"><a href="#桥接模式的应用" class="headerlink" title="桥接模式的应用"></a>桥接模式的应用</h1><p>JDK中的桥接模式JDBC：JDBC连接数据库的时候，在各个数据库之间进行切换，基本不需要动太多的代码，甚至丝毫不动，原因就是JDBC提供了统一接Connection，每个数据库提供各自的实现，用一个叫做数据库驱动的程序来桥接就行了。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 结构型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 优化器与特定类型优化</title>
      <link href="/2020/03/12/mysql/note7-query-optimize2/"/>
      <url>/2020/03/12/mysql/note7-query-optimize2/</url>
      
        <content type="html"><![CDATA[<p>优化器存在哪些问题？ 日常的查询需要注意哪些点？</p><a id="more"></a><h1 id="查询优化器存在的问题"><a href="#查询优化器存在的问题" class="headerlink" title="查询优化器存在的问题"></a>查询优化器存在的问题</h1><h2 id="关联子查询"><a href="#关联子查询" class="headerlink" title="关联子查询"></a>关联子查询</h2><p>常见的一种查询， 希望找到 Sakila 数据库中， 演员 PG(actor_id = 1) 所参演的影片信息, 一般来讲我们都会以下面的方式完成子查询：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM sakila.film</span><br><span class="line">-&gt; <span class="function">WHERE film_id <span class="title">IN</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">-&gt; SELECT film_id FROM sakila.film_actor WHERE actor_id = <span class="number">1</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>大多数情况下我们都会以为上面的语句执行时会按照下面的顺序执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- <span class="function">SELECT <span class="title">GROUP_CONCAT</span><span class="params">(film_id)</span> FROM sakila.film_actor WHERE actor_id </span>= <span class="number">1</span>;</span><br><span class="line">-- Result: <span class="number">1</span>,<span class="number">23</span>,<span class="number">25</span>,<span class="number">106</span>,<span class="number">140</span>,<span class="number">166</span>,<span class="number">277</span>,<span class="number">361</span>,<span class="number">438</span>,<span class="number">499</span>,<span class="number">506</span>,<span class="number">509</span>,<span class="number">605</span>,<span class="number">635</span>,<span class="number">749</span>,<span class="number">832</span>,<span class="number">939</span>,<span class="number">970</span>,<span class="number">980</span> </span><br><span class="line"></span><br><span class="line">SELECT * FROM sakila.film</span><br><span class="line"><span class="function">WHERE film_id <span class="title">IN</span><span class="params">(<span class="number">1</span>,<span class="number">23</span>,<span class="number">25</span>,<span class="number">106</span>,<span class="number">140</span>,<span class="number">166</span>,<span class="number">277</span>,<span class="number">361</span>,<span class="number">438</span>,<span class="number">499</span>,<span class="number">506</span>,<span class="number">509</span>,<span class="number">605</span>,<span class="number">635</span>,<span class="number">749</span>,<span class="number">832</span>,<span class="number">939</span>,<span class="number">970</span>,<span class="number">980</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>但是时间情况却是MySQL 会先全表扫描 film 表， 然后进行子查询，依次比对 film 表中的 film_id 与 file_actor 表中 actor_id = 1的 film_id， sql 在执行时将会改写成以下语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM sakila.film </span><br><span class="line"><span class="function">WHERE <span class="title">EXISTS</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    SELECT * FROM sakila.film_actor WHERE actor_id = <span class="number">1</span></span></span></span><br><span class="line"><span class="function"><span class="params">    AND film_actor.film_id = film.film_id)</span></span>;</span><br></pre></td></tr></table></figure><p>如果外层的表 film 数据量并不是很大的时候， 对性能的影响不会引起注意， 如果外层的表很大， 这个查询的性能就会很糟糕， 常见的一个优化的方式为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT film.* FROM sakila.film</span><br><span class="line">-&gt; INNER JOIN sakila.<span class="function">film_actor <span class="title">USING</span><span class="params">(film_id)</span> </span></span><br><span class="line"><span class="function">-&gt; WHERE actor_id </span>= <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>至于使用子查询还是内/外连接， 需要看具体的执行计划， 并不一定说内/外连接的性能一定比子查询好。</p><h2 id="UNION-限制"><a href="#UNION-限制" class="headerlink" title="UNION 限制"></a>UNION 限制</h2><p>UNION 的限制条件只对已联合的数据生效， 如果想得到更好的性能则需要在联合前就对数据做出限制：</p><p>比如, actor 有 200 条数据， customer 有 599 条数据，按 last_name 合并后， 会生成一张含有 799 条数据的临时表， 然后再从临时表去除 20 条数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(SELECT first_name, last_name FROM sakila.actor</span><br><span class="line">ORDER BY last_name)</span><br><span class="line">UNION ALL</span><br><span class="line">(SELECT first_name, last_name</span><br><span class="line">FROM sakila.customer</span><br><span class="line">ORDER BY last_name) LIMIT <span class="number">20</span>;</span><br></pre></td></tr></table></figure><p>数据量很大时， 临时表可能会很大， 可以在 UNION 的子查询中加上 LIMIT 来减少临时表的数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(SELECT first_name, last_name FROM sakila.actor</span><br><span class="line">ORDER BY last_name</span><br><span class="line">LIMIT <span class="number">20</span>)</span><br><span class="line">UNION ALL</span><br><span class="line">(SELECT first_name, last_name</span><br><span class="line">FROM sakila.customer ORDER BY last_name LIMIT <span class="number">20</span>)</span><br><span class="line">LIMIT <span class="number">20</span>;</span><br></pre></td></tr></table></figure><h2 id="索引合并优化"><a href="#索引合并优化" class="headerlink" title="索引合并优化"></a>索引合并优化</h2><p>当查询语句中有 OR 时, 会求并集。查询SELECT * FROM TB1 WHERE c1=”xxx” OR c2=””xxx”时，如果c1和c2列上分别有索引，可以按照c1和c2条件进行查询，再将查询结果合并（union）操作。</p><p>当查询语句中有 OR 时, 会求交集。如查询SELECT * FROM TB1 WHERE c1=”xxx” AND c2=””xxx”时，如果c1和c2列上分别有索引，可以按照c1和c2条件进行查询，再将查询结果取交集（intersect）操作。</p><p>索引索引合并的性能并不及复合索引。</p><h2 id="等值传递"><a href="#等值传递" class="headerlink" title="等值传递"></a>等值传递</h2><p>非常大的 IN()列表 MySQL 优化器会将这个列表的值与另一个表做关联，类似于子查询是对 IN 语句的改写。</p><h2 id="哈希关联"><a href="#哈希关联" class="headerlink" title="哈希关联"></a>哈希关联</h2><p>MySQL 的查询都是嵌套循环查询， 不支持哈希关联。 </p><h2 id="松散索引扫描"><a href="#松散索引扫描" class="headerlink" title="松散索引扫描"></a>松散索引扫描</h2><p>MySQL 的索引扫描需要指定起点和终点。假设有索引 key(a,b), 如何查询的语句中只要字段 b， MySQL 是无法使用这个索引的， 只能通过全表扫描查找数据。<br> 而松散索引是先扫描 a 列对应的 b 列的范围，再跳到 a 列第二个不同值扫描对应 b 列的范围。更好的做法是为 b 增加一个索引，但是也会遇到第一列为范围查询， 第二列为等值查询的情况。</p><h2 id="最大最小值优化"><a href="#最大最小值优化" class="headerlink" title="最大最小值优化"></a>最大最小值优化</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SELECT <span class="title">MIN</span><span class="params">(actor_id)</span> FROM sakila.actor WHERE first_name </span>= <span class="string">'PENELOPE'</span>;</span><br></pre></td></tr></table></figure><p>first_name 没有索引时， 会进行全表扫描。 当进行主键扫描时（actor_id）为主键， 读到的第一行记录就是最小值。此时采用 LIMIT 将查询重写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT actor_id FROM sakila.<span class="function">actor USE <span class="title">INDEX</span><span class="params">(PRIMARY)</span></span></span><br><span class="line"><span class="function">    -&gt; WHERE first_name </span>= <span class="string">'PENELOPE'</span> LIMIT <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>虽然进行了优化， 但是会让人产生迷惑，不知到这个 sql 语句想表达什么。</p><h2 id="同一个表的查询与更新"><a href="#同一个表的查询与更新" class="headerlink" title="同一个表的查询与更新"></a>同一个表的查询与更新</h2><p>MySQL 不允许对同一张表同时进行查询和更新。</p><h1 id="优化特定的类型"><a href="#优化特定的类型" class="headerlink" title="优化特定的类型"></a>优化特定的类型</h1><h2 id="优化-COUNT"><a href="#优化-COUNT" class="headerlink" title="优化 COUNT()"></a>优化 COUNT()</h2><p>COUNT()函数有两个作用：</p><ul><li>统计某个列值的数量。 统计列值时要求列值是非空的（NOT NULL）或者表达式的值补不为NULL。</li><li>统计结果集的行数。COUNT(*）时， * 并不会扩展成所有列，而是直接统计行数。</li></ul><p>MyISAM count()的速度很快是因为前提条件是没有任何WERE条件的COUNT(<em>)。<br>技巧1： 查询一个很多行时， 反向查询<br>SELECT (SELECT COUNT(</em>) FROM CITY ) - COUNT(*) FROM CITY WHERE id &lt;= 5; 可以迅速查的id大于5的城市<br>技巧2：COUNT 替代SUM<br>SELECT COUNT(color = ‘blue’ OR NULL) as blue, COUNT(color = ‘red’ OR NULL) as red FR0M ITEMS;</p><h2 id="优化关联查询"><a href="#优化关联查询" class="headerlink" title="优化关联查询"></a>优化关联查询</h2><ul><li>当表 A 与表 B 关联是， 只需要在关联顺序的第二张表相应列创建索引即可</li><li>GROUP BY 和 ORDER BY 只涉及到一个表的列才能使 MySQL 索引生效</li></ul><h2 id="优化子查询"><a href="#优化子查询" class="headerlink" title="优化子查询"></a>优化子查询</h2><p>子查询尽量使用关联来代替， “尽可能地使用关联”，但不一定正确。</p><h2 id="优化-GROUP-BY"><a href="#优化-GROUP-BY" class="headerlink" title="优化 GROUP BY"></a>优化 GROUP BY</h2><p>无法使用索引时， GROUP BY 使用临时表或者文件排序来实现分组</p><h2 id="优化-LIMIT分页"><a href="#优化-LIMIT分页" class="headerlink" title="优化 LIMIT分页"></a>优化 LIMIT分页</h2><p>LIMIT 分页时需要留意偏移量， 特别是偏移量非常大的时候， 例如 LIMIT 1000, 20, 只返回了最后20条数据， 前面的 1000 条被丢弃。<br>采用延迟关联, 获取需要访问的数据后再根据关联列会原表查询所需要的列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT film_id, description FROM film ORDER BY title LIMIT <span class="number">50</span>, <span class="number">5</span>;</span><br><span class="line">改写成：</span><br><span class="line">SELECT film_id, description </span><br><span class="line">FROM film</span><br><span class="line">    <span class="function">INNER <span class="title">JOIN</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        SELECT film_id FROM film ORDER BY title LIMIT <span class="number">50</span>, <span class="number">5</span></span></span></span><br><span class="line"><span class="function"><span class="params">    )</span> AS lim <span class="title">UNSING</span><span class="params">(film_id)</span></span>;</span><br></pre></td></tr></table></figure><p>或者将 LIMIT 查询转换成已知位置查询<br>SELECT film_id, description FROM film WHERE position； BETWEEN 50 AND 54  ORDER BY position；</p><p>OFFSET 在使用时可以记录上一次查询的位置配合 LIMIT 使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM rental WHERE  ORDER BY rental_id DESC LIMIT <span class="number">16049</span>, <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">SELECT * FROM rental WHERE rental_id &lt; <span class="number">16030</span> ORDER BY rental_id DESC LIMIT <span class="number">20</span>;</span><br></pre></td></tr></table></figure><h2 id="优化-UNION"><a href="#优化-UNION" class="headerlink" title="优化 UNION"></a>优化 UNION</h2><p>UNION在使用时要注意是否是UNION ALL， 否则在查询时还需要对临时表去重</p><h2 id="使用自定义变量"><a href="#使用自定义变量" class="headerlink" title="使用自定义变量"></a>使用自定义变量</h2><p>使用自定义变量需要注意：</p><ul><li>使用自定义变量时， 无法查询缓存；</li><li>不能在使用常量、标识符的地方使用自定义变量，例如表名、列名、LIMIT 子句中；</li><li>用户的自定义变量只在一个session中有效， 不能做为连接间的通信；</li><li>不能显示声明自定义变量的类型；赋值为0默认为整形， 0.0为浮点型， ‘’为字符串；</li><li>赋值符号  := 的优先级非常低；</li><li>自定义变量不会产生语法错误。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 查询过程及优化</title>
      <link href="/2020/03/08/mysql/note6-query-optimize/"/>
      <url>/2020/03/08/mysql/note6-query-optimize/</url>
      
        <content type="html"><![CDATA[<p>MySQL 查询过程一共分几步？</p><a id="more"></a><h1 id="MySQL-查询基础"><a href="#MySQL-查询基础" class="headerlink" title="MySQL 查询基础"></a>MySQL 查询基础</h1><p>查询过程分为以下五步：</p><ol><li>客户端发送查询指令给服务器</li><li>服务器先查询缓存， 如果命中缓存立刻返回缓存中的结果。否则下一阶段</li><li>服务器对查询语句进行 SQL 解析、预处理， 再由优化器生成响应的执行计划</li><li>MySQL 根据优化器生成执行计划， 调用存储引擎层的 api 来执行查询</li><li>将查询结果返回给客户端 </li></ol><p><img src="/2020/03/08/mysql/note6-query-optimize/query_path.jpeg" alt="查询执行路径"></p><h2 id="客户端-服务端间的通信协议"><a href="#客户端-服务端间的通信协议" class="headerlink" title="客户端/服务端间的通信协议"></a>客户端/服务端间的通信协议</h2><p>客户端与服务端之间是“半双工”， 一端发送数据时，另一端只能接收。 一般来说服务端返回的数据很大， 客户端完整的接收数据需要花费很长的时间， 所以必要的时候需要对查询增加 LIMIT 限制。</p><h2 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h2><p>在解析 sql 语句之前， 如果缓存是打开的， MySQL 会优先检查是否命中缓存中的数据， 如果命中了数据， 返回结果前还要验证一次用户权限， 权限没有问题会直接返回缓存中查得的数据。</p><h2 id="查询优化处理"><a href="#查询优化处理" class="headerlink" title="查询优化处理"></a>查询优化处理</h2><p>查询优化包含多个子阶段： 解析 sql， 预处理， 优化 sql 执行计划。</p><h3 id="语法解析器与预处理"><a href="#语法解析器与预处理" class="headerlink" title="语法解析器与预处理"></a>语法解析器与预处理</h3><p>MySQL 通过关键字对 SQL 语句进行解析， 生成一颗解析树。在这一步解析器将验证关键字是否正确， 关键字的顺序是否正确， 还会验证引号是否前后正确匹配。</p><h3 id="查询优化器"><a href="#查询优化器" class="headerlink" title="查询优化器"></a>查询优化器</h3><p>此时语法树是合法的，优化器会将其转化成执行计划， 一条语句可能由多种执行方式，优化器的作用就是找到其中最好的的执行计划。 查询优化可以简单分为两种：静态优化和动态优化。 静态优化对解析树进行分析，例如通过简单的代数变换将 WHERE 条件转换成另一种形式，第一次完成后一直有效， 不受参数变化的影响； 动态优化与查询的上下文有关， 比如 WHERE 条件的取值、索引中条目对应的数据行等， 每次查询都需重新评估。</p><p>以下是 MySQL 可以优化的类型：</p><ul><li>重新定义关联表的顺序</li><li>将外连接转化成内链接</li><li>使用等价变换原则</li><li>优化 COUNT(), MAX(), MIN()</li><li>预估并转化为常数表达式</li><li>覆盖索引扫描</li><li>子查询优化</li><li>提前终止查询</li><li>等值传播</li><li>列表 IN() 的比较</li></ul><h3 id="数据和索引的统计信息"><a href="#数据和索引的统计信息" class="headerlink" title="数据和索引的统计信息"></a>数据和索引的统计信息</h3><p>大多数情况下，数据和索引的统计信息都在存储引擎层维护。</p><h3 id="关联查询"><a href="#关联查询" class="headerlink" title="关联查询"></a>关联查询</h3><p>MySQL 关联 查询时先将子查询的结果放到一个临时表中， 将临时表也当做一个普通表对待。MySQL 先将一系列的查询结果放到一个临时表中，然后再嵌套循环到下一个表中寻找匹配的行， 直到找到所有的匹配行为止。</p><h3 id="执行计划"><a href="#执行计划" class="headerlink" title="执行计划"></a>执行计划</h3><p>MySQL 的执行计划从一个表开始嵌套循环、回溯完成所有表的关联。</p><p><img src="/2020/03/08/mysql/note6-query-optimize/join.jpg" alt="多表关联"></p><h3 id="关联查询优化器"><a href="#关联查询优化器" class="headerlink" title="关联查询优化器"></a>关联查询优化器</h3><p>关联优化查询器通过评估不同顺序的成本选择一个代价最小的关联顺序。</p><h3 id="排序优化"><a href="#排序优化" class="headerlink" title="排序优化"></a>排序优化</h3><p>当不能只有索引生成的排序结果时， MySQL 需要自己进行排序。如果数据量小可以在内存中排序， 数据量大时在磁盘中排序， 两种情况统称为文件排序(file sort)， 有以下2种排序规则：</p><ul><li>两次传输排序： 需要读取两次数据表， 成本高， 旧版本使用</li><li>单次传输排序： 先从数据表读取所有列， 再排序， 直接返回排序结果</li></ul><p>file sort 带来的问题是有可能排序产生的临时表比磁盘的原有文件还要大， 所以查看EXPLAIN 时如果出现 “Using temporary; Using filesort”时需要留意。</p><h2 id="查询执行引擎"><a href="#查询执行引擎" class="headerlink" title="查询执行引擎"></a>查询执行引擎</h2><p>在解析和优化阶段， MySQL 将生成查询对应的执行计划。 查询过程中每个表对应一个 handler， 存储引擎提供查询的接口供优化器使用， 这些接口包含获取表的相关信息， 表的列名、索引统计信息等。</p><h2 id="返回结果给客户端"><a href="#返回结果给客户端" class="headerlink" title="返回结果给客户端"></a>返回结果给客户端</h2><p>如果查询的结果可以被缓存， MySQL 会将查得的结果缓存起来。</p><p>MySQL 返回结果的过程并不是一次将所有结果返回， 而是一个逐步的过程， 以关联表为例， 处理器在处理完最后一个关联表生成第一条结果时就开始向客户端返回数据了。</p><p>这样服务单无需存储太多的结果，也不会因为返回太多结果而占销毁太多内存。</p><h1 id="要想查询速度快不要做哪些"><a href="#要想查询速度快不要做哪些" class="headerlink" title="要想查询速度快不要做哪些"></a>要想查询速度快不要做哪些</h1><h2 id="查询了不需要的数据"><a href="#查询了不需要的数据" class="headerlink" title="查询了不需要的数据"></a>查询了不需要的数据</h2><h3 id="查询了不需要的数据-1"><a href="#查询了不需要的数据-1" class="headerlink" title="查询了不需要的数据"></a>查询了不需要的数据</h3><p>可以在查询条件中新增 LIMIT ， 返回自己需要的条数。</p><h3 id="多表关联时返回全部的列"><a href="#多表关联时返回全部的列" class="headerlink" title="多表关联时返回全部的列"></a>多表关联时返回全部的列</h3><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> A</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> B </span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> C</span><br><span class="line"><span class="keyword">WHERE</span> XXX;</span><br></pre></td></tr></table></figure><p>这样的操作会返回 A、B、C 的全部列。 正确的做法是只取需要的列：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> A.* <span class="keyword">FROM</span> A</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> B </span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> C</span><br><span class="line"><span class="keyword">WHERE</span> XXX;</span><br></pre></td></tr></table></figure><h3 id="总是取出全部列"><a href="#总是取出全部列" class="headerlink" title="总是取出全部列"></a>总是取出全部列</h3><p>禁止使用 SELECT * 。 使用 SELECT * 查询会带来额外的 I/O、内存和 CPU 的消耗。</p><h3 id="重复查询相同的数据"><a href="#重复查询相同的数据" class="headerlink" title="重复查询相同的数据"></a>重复查询相同的数据</h3><p>如果重复执行相同的查询， 并总是返回完全相同的数据。 对这些很少发生变化的数据， 将它缓存起来。</p><h2 id="是否扫描了额外的记录"><a href="#是否扫描了额外的记录" class="headerlink" title="是否扫描了额外的记录"></a>是否扫描了额外的记录</h2><p>衡量指标：</p><ul><li><p>响应时间： 服务时间 + 阻塞时间</p><p>  服务时间指的是数据库处理查询花费的时间；<br>  阻塞时间指的是服务器在等待资源过程中花的时间， I/O 操作、行锁等</p></li><li><p>扫描的行数</p><p>  理想情况下扫描的行数应该和返回的行数相同。</p></li><li><p>扫描的类型</p><p>  访问的类型有： 全表扫描(ALL)、索引扫描(ref)、范围扫描(range)、唯一索引(unique)、常数引用(const)。 速度依次由慢到快</p></li></ul><p>MySQL 会在以下三种情况使用 WHERE 条件：</p><ul><li>在索引中使用 WHERE 条件过滤不匹配的记录， 属于存储引擎层的操作；</li><li>索引覆盖扫描（无需回表)返回记录， 从索引中过滤不需要的记录并返回名字的结果， 属于服务器层操作；</li><li>从数据表中返回数据， 过滤不满足条件的记录。</li></ul><p>如果发现查询需要扫描大量的数据但只返回了少数的行， 可以尝试以下操作优化：</p><ul><li>使用索引覆盖扫描， 无需回表；</li><li>改变库表结果， 使用单独的汇总表；</li><li>重写复杂的查询， 让 MySQL 更优地处理。</li></ul><h1 id="重构查询方式以提升查询效率"><a href="#重构查询方式以提升查询效率" class="headerlink" title="重构查询方式以提升查询效率"></a>重构查询方式以提升查询效率</h1><p>将查询进行转换， 可以使得返回同样的结果，但是速度更快。</p><h2 id="使用一个复杂查询还是多个简单查询"><a href="#使用一个复杂查询还是多个简单查询" class="headerlink" title="使用一个复杂查询还是多个简单查询"></a>使用一个复杂查询还是多个简单查询</h2><p>MySQL 的连接和端口的开销很小， 所以对 MySQL 来说网络通信、查询解析和优化的成本比以前小了很多。 有必要时将浮躁查询分解成多个查询。</p><h2 id="切分查询"><a href="#切分查询" class="headerlink" title="切分查询"></a>切分查询</h2><p>将一个大查询切分成小查询， 每个小查询只完成一小部分， 返回一小部分结果。</p><p>批量删除旧数据， 每次限制 10000 条数据。</p><h2 id="拆分关联查询"><a href="#拆分关联查询" class="headerlink" title="拆分关联查询"></a>拆分关联查询</h2><p>对关联查询进行分解， 将分解得到的数据在应用层或者说在内存中进行处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM tag</span><br><span class="line">    JOIN tag_post on tag_post.tag_id = tag.id</span><br><span class="line">    JOIN post on tag_post.post_id = post.id</span><br><span class="line">where tag.tag = <span class="string">'mysql'</span>;</span><br><span class="line"></span><br><span class="line">-- 分解成如下：</span><br><span class="line">SELECT * FROM tag WHERE tag = <span class="string">'mysql'</span>;</span><br><span class="line">SELECT * FROM tag_post WHERE tag_id= <span class="number">1234</span>;</span><br><span class="line">SELECT * <span class="function">FROM post WHERE post_id <span class="title">in</span> <span class="params">(<span class="number">123</span>, <span class="number">456</span>, <span class="number">789</span>, <span class="number">0992</span>)</span>'</span>;</span><br></pre></td></tr></table></figure><p>这样做的好处是：</p><ul><li>让缓存效率更高。分解后的语句查询的结果更容易被缓存， 而联表查询的零时表缓存的命中率并不高？（因为关联的一张表发生变化就会导致缓存失效）；</li><li>查询分解， 减少锁竞争；</li><li>应用层关联， 利于数据库的拆分， 扩展性更高；</li><li>查询效率更高， 使用 in 操作可以让查询按 ID 顺序查询。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>聚簇索引、二级索引与覆盖索引</title>
      <link href="/2020/03/04/mysql/note5-cluster-index/"/>
      <url>/2020/03/04/mysql/note5-cluster-index/</url>
      
        <content type="html"><![CDATA[<p>聚簇索引到底是什么索引？ 覆盖索引又是怎么回事？</p><a id="more"></a><h1 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h1><p><strong>定义</strong>：</p><pre><code>聚簇索引并不是一种新数据结构， 而是 B-Tree 索引的一种存储方式，保存的是 B-Tree 索引和数据行。在 InnoDB 引擎下， 聚簇索引与主键索引是等价的。</code></pre><ul><li>当数据表定义主键时，InnoDB 使用主键做为聚簇索引；</li><li>如果表中未定义主键， MySQL 会自动选择第一个唯一索引 (UNIQUE INDEX)、且所在列 NOT NULL 时作为聚簇索引；</li><li>如果表中即未定义主键， 也没有合适的唯一索引， InnoDB会隐式地创建一个名为 <strong>GEN_CLUST_INDEX</strong> 的索引作为聚簇索引， 该索引包含了 6 个字节的 row id</li></ul><p><strong>聚簇索引</strong>结构如下， 同时也是 B+Tree 索引</p><p><img src="/2020/03/04/mysql/note5-cluster-index/cluster_index.jpg" alt="聚簇索引示例"></p><p><strong>特性</strong>：</p><ul><li><p>数据行的逻辑顺序与聚簇索引的顺序一致，B+树中叶子结点以链表的形式串联的，叶子节点中数据行的逻辑顺序只有一种，所以一张表只能有一个聚簇索引。</p></li><li><p>叶子结点包含了数据行的完整数据，非叶子节点只包含索引列数据。</p></li><li><p>通过聚簇索引，能够更快地找到数据所在的页，如果表中数据很多，能够有效节省磁盘 IO 次数。</p></li></ul><h1 id="二级索引（非聚簇索引）"><a href="#二级索引（非聚簇索引）" class="headerlink" title="二级索引（非聚簇索引）"></a>二级索引（非聚簇索引）</h1><p>InnoDB 中除过主键索引， 其余的统称为二级索引，二级索引会在叶子节点保存主键。<br>当通过二级索引进行查找时， 二级索引会通过叶子结点找到主键， 然后再根据主键找到数据所在的行， 这样做的好处是减少了数据行移动和页分裂时二级索引的维护工作, 但是通过二级索引查找数据时相当于利用了两个 B 树, 要解决这种问题需要引入<strong>覆盖索引</strong>， 覆盖索引接下来我们会讲到。</p><p><img src="/2020/03/04/mysql/note5-cluster-index/cluster_index.png" alt="InnoDB 聚簇索引"> <img src="/2020/03/04/mysql/note5-cluster-index/secondary_index.png" alt="InnoDB 二级索引"></p><p>在实际的查找过程如下：</p><p><img src="/2020/03/04/mysql/note5-cluster-index/b-tree-index.jpg" alt="实际查找过程"></p><p>以 Tom 为例， 在二级索引key(b, c)中， 先找到 b = 22 and c = tom 的行， 同时得到row id = 30， 根据 row id 回到主键索引， 就能找到 row id = 30 的所有数据。</p><h1 id="聚簇索引的优缺点"><a href="#聚簇索引的优缺点" class="headerlink" title="聚簇索引的优缺点"></a>聚簇索引的优缺点</h1><p>优点：</p><ul><li>聚簇索引将索引与数据行保存在同一个 B-Tree 中， 查询通过聚簇索引就能够直接得到数据，而非聚簇索引则需要多次 IO， 所以聚簇索引的查询速度比非聚簇索引的速度更快；</li><li>聚簇索引对主键的范围查询效率很高， 因为聚簇索引的数据是按主键排列的；</li><li>覆盖索引扫描的查询可以直接使用页节点中的主键值。</li></ul><p>缺点： </p><ul><li>聚簇索引的优势在于减少 IO， 如果查询的数据都在内存中那么对访问顺序就没那么重要了；</li><li>插入的速度严重依赖于插入的顺序，按主键的顺序插入是最快的，否则会出现页分裂这种情况。对于 InnoDB 引擎的表都会定义一个自增 id；</li><li>聚簇索引在更新和插入新的数据时，可能会导致页分裂的问题：当插入的已满的叶子节点时，B+树会分裂成两个页来容纳新增的数据。页分裂会导致表占用更多的磁盘空间；</li><li>聚簇索引会导致全表扫描变慢，尤其是行比较稀疏，或者由于页分裂导致数据存储不连续的时候（<strong>所以不要使用 uuid 作为主键</strong>）。</li><li>二级索引（非聚簇索引）可能比想象的要更大，因为在二级索引的叶子节点包含了引用行的主键列。</li></ul><h1 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h1><p>定义：</p><pre><code>覆盖索引（covering index）指一个查询语句的执行只用从索引中就能够取得，不必从数据表中读取。也称之为索引覆盖。</code></pre><p>举个例子, 此时 tb_user 中只有主键索引：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">-- 添加覆盖索引前</span><br><span class="line">mysql&gt; <span class="function">select <span class="title">count</span><span class="params">(name)</span> from tb_user where name like 'jSMfqpA%'</span>;</span><br><span class="line">+-------------+</span><br><span class="line">| count(name) |</span><br><span class="line">+-------------+</span><br><span class="line">|           <span class="number">2</span> |</span><br><span class="line">+-------------+</span><br><span class="line"><span class="number">1</span> <span class="function">row in <span class="title">set</span> <span class="params">(<span class="number">0.15</span> sec)</span>  # 耗时 0.15 秒</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">-- 新增索引</span></span><br><span class="line"><span class="function">mysql&gt; create index idx_tb_user_name on <span class="title">tb_user</span><span class="params">(name)</span></span>;</span><br><span class="line"></span><br><span class="line">+----------+------------+--------------------------------------------------------------+</span><br><span class="line">| Query_ID | Duration   | Query                                                        |</span><br><span class="line">+----------+------------+--------------------------------------------------------------+</span><br><span class="line">|       <span class="number">10</span> | <span class="number">0.00029900</span> | <span class="function">select <span class="title">count</span><span class="params">(name)</span> from tb_user where name like 'jSMfqpA%'   |</span></span><br><span class="line"><span class="function">+----------+------------+--------------------------------------------------------------+</span></span><br></pre></td></tr></table></figure><p>name 字段新增索引后耗时 0.29 毫秒， 与之前无索引时性能差了近千倍。</p><p>对比下同样是有索引的字段， 但不是覆盖索引的查询：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+----------+------------+--------------------------------------------------------------------+</span><br><span class="line">| Query_ID | Duration   | Query                                                              |</span><br><span class="line">+----------+------------+--------------------------------------------------------------------+</span><br><span class="line">|       <span class="number">16</span> | <span class="number">0.00863500</span> | <span class="function">select <span class="title">count</span><span class="params">(name)</span> from tb_user where birth &gt; '2020-01-01'         |</span></span><br><span class="line"><span class="function">+----------+------------+--------------------------------------------------------------------+</span></span><br></pre></td></tr></table></figure><p>可以看到同样是索引的字段， 覆盖索引查询与非覆盖索引的查询也相差一个量级， 索引与非索引的查询性能更是相差千倍。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="function">explain select <span class="title">count</span><span class="params">(name)</span> from tb_user where name like 'jSMfqpA%' \G</span>;</span><br><span class="line">*************************** <span class="number">1</span>. row ***************************</span><br><span class="line">           id: <span class="number">1</span></span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: tb_user</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: range</span><br><span class="line">possible_keys: idx_tb_user_name</span><br><span class="line">          key: idx_tb_user_name</span><br><span class="line">      key_len: <span class="number">13</span></span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: <span class="number">2</span></span><br><span class="line">     filtered: <span class="number">100.00</span></span><br><span class="line">        Extra: Using where; Using index  # 使用到索引查询且未覆盖索引</span><br><span class="line"><span class="number">1</span> row in set, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="function">explain  select <span class="title">count</span><span class="params">(name)</span> from tb_user where birth &gt; '2020-01-01' \G</span>;</span><br><span class="line">*************************** <span class="number">1</span>. row ***************************</span><br><span class="line">           id: <span class="number">1</span></span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: tb_user</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: range</span><br><span class="line">possible_keys: idx_tb_user_birth</span><br><span class="line">          key: idx_tb_user_birth</span><br><span class="line">      key_len: <span class="number">4</span></span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: <span class="number">2962</span></span><br><span class="line">     filtered: <span class="number">100.00</span></span><br><span class="line">        Extra: Using index condition  # 使用到索引查询，但非覆盖索引</span><br><span class="line"><span class="number">1</span> row in set, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>当一条查询语句符合覆盖索引条件时，MySQL 只需要通过索引就可以返回查询所需要的数据，这样避免了查到索引后再回表查询，减少I/O提高效率。</li><li>InnoDB使用聚集索引存储数据，如果二级索引中包含查询所需的数据，就不再需要在聚集索引中查找了。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>B-Tree 索引实践</title>
      <link href="/2020/02/29/mysql/note4-btree-practice/"/>
      <url>/2020/02/29/mysql/note4-btree-practice/</url>
      
        <content type="html"><![CDATA[<p>看下 B-Tree 索引在实际的数据查询中起到了什么作用。</p><a id="more"></a><h1 id="准备测试数据"><a href="#准备测试数据" class="headerlink" title="准备测试数据"></a>准备测试数据</h1><h2 id="新建表"><a href="#新建表" class="headerlink" title="新建表"></a>新建表</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">create table <span class="title">tb_user</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  id <span class="keyword">int</span> auto_increment primary key,</span></span></span><br><span class="line"><span class="function"><span class="params">  name varchar(<span class="number">10</span>)</span>,</span></span><br><span class="line"><span class="function">  birth date</span></span><br><span class="line"><span class="function">)</span>;</span><br></pre></td></tr></table></figure><h2 id="利用存储过程造数据"><a href="#利用存储过程造数据" class="headerlink" title="利用存储过程造数据"></a>利用存储过程造数据</h2><p>存储过程可以理解为 MySQL 的一个函数， 调用存储过程就可以执行函数中相应的操作；</p><p>在创建存储过程之前需要对 “,” 特殊处理下， 因为MySQL 将 “,” 作为一条语句的终结符号，为了是创建的存储过程中的 “,” 生效， 需要提前使用 delimiter 将终结符 “,” 替换成其他符号。</p><p>比如使用 <strong>delimiter $$</strong>， 就将 “,” 替换成了 $$。</p><p>创建生成随机字符串与随机数生成的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">delimiter $$</span><br><span class="line"># 生成随机字符串</span><br><span class="line"><span class="function">create function <span class="title">rand_str</span><span class="params">(n <span class="keyword">int</span>)</span> returns <span class="title">varchar</span><span class="params">(<span class="number">10</span>)</span></span></span><br><span class="line"><span class="function">begin</span></span><br><span class="line"><span class="function">  declare CHARS <span class="title">char</span><span class="params">(<span class="number">52</span>)</span> <span class="keyword">default</span> 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'</span>;</span><br><span class="line">  <span class="function">declare result <span class="title">varchar</span><span class="params">(<span class="number">255</span>)</span> <span class="keyword">default</span> ''</span>;</span><br><span class="line">  declare i <span class="keyword">int</span> <span class="keyword">default</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> i &lt; n <span class="keyword">do</span></span><br><span class="line">    set result = concat(result, substr(CHARS, floor(<span class="number">1</span> + RAND()*<span class="number">52</span>), <span class="number">1</span>));</span><br><span class="line">    set i = i + <span class="number">1</span>;</span><br><span class="line">  end <span class="keyword">while</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">end</span><br><span class="line">$$</span><br><span class="line"></span><br><span class="line"># 生成随机数(i &lt;= R &lt; j)</span><br><span class="line"><span class="function">create function <span class="title">rand_num</span><span class="params">(i <span class="keyword">int</span>, j <span class="keyword">int</span>)</span> returns <span class="keyword">int</span></span></span><br><span class="line"><span class="function">begin</span></span><br><span class="line"><span class="function">  return <span class="title">floor</span><span class="params">(i + rand()</span> * <span class="params">(j - i)</span>)</span>;</span><br><span class="line">end</span><br><span class="line">$$</span><br><span class="line"></span><br><span class="line">delimiter ;</span><br></pre></td></tr></table></figure><p>创建测试数据生成的存储过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">delimiter $$</span><br><span class="line"><span class="function">create procedure <span class="title">insert_tb_user</span><span class="params">(c <span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function">begin</span></span><br><span class="line"><span class="function">  declare start_date <span class="keyword">int</span> <span class="keyword">default</span> <span class="title">TO_DAYS</span><span class="params">(STR_TO_DATE(<span class="string">'1970-01-1'</span>,<span class="string">'%Y-%m-%e'</span>)</span>)</span>;</span><br><span class="line">  <span class="function">declare end_date <span class="keyword">int</span> <span class="keyword">default</span> <span class="title">TO_DAYS</span><span class="params">(CURDATE()</span>)</span>;</span><br><span class="line">  declare i <span class="keyword">int</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">  set autocommit = <span class="number">0</span>;</span><br><span class="line">  repeat</span><br><span class="line">    set i = i + <span class="number">1</span>;</span><br><span class="line">    <span class="function">insert into <span class="title">tb_user</span><span class="params">(name, birth)</span> <span class="title">values</span><span class="params">(rand_str(<span class="number">10</span>)</span>, <span class="title">FROM_DAYS</span><span class="params">(rand_num(start_date, end_date)</span>))</span>;</span><br><span class="line">  until i = c end repeat;</span><br><span class="line">  set autocommit = <span class="number">1</span>;</span><br><span class="line">end</span><br><span class="line">$$</span><br><span class="line">delimiter ;</span><br></pre></td></tr></table></figure><p>调用存储过程生成一百万条随机数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">call <span class="title">insert_tb_user</span><span class="params">(<span class="number">1000000</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>可能需要几分钟的时间，我的电脑上生成一百万条数据花费 286 秒。</p><h1 id="使用主键查询"><a href="#使用主键查询" class="headerlink" title="使用主键查询"></a>使用主键查询</h1><p>为了能更细致地看到每条语句的耗时， 我们需要把 profiles 打开</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set profiling=<span class="number">1</span>;</span><br><span class="line">Query OK, <span class="number">0</span> rows affected, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from tb_user where id = <span class="number">10000</span>;</span><br><span class="line">+-------+-----------+------------+</span><br><span class="line">| id    | name      | birth    |</span><br><span class="line">+-------+-----------+------------+</span><br><span class="line">| <span class="number">10000</span> | jSMfqpAKV | <span class="number">1994</span>-<span class="number">01</span>-<span class="number">25</span> |</span><br><span class="line">+-------+-----------+------------+</span><br><span class="line"><span class="number">1</span> <span class="function">row in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">mysql&gt; show profiles</span>;</span><br><span class="line">+----------+------------+-------------------------------------------+</span><br><span class="line">| Query_ID | Duration   | Query                                     |</span><br><span class="line">+----------+------------+-------------------------------------------+</span><br><span class="line">|        <span class="number">1</span> | <span class="number">0.0</span>.00027100 | select * from tb_user where id = <span class="number">10000</span>  |</span><br><span class="line">+----------+------------+-------------------------------------------+</span><br><span class="line"><span class="number">1</span> row in set, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>可以看到使用主键查询时耗时 <strong>0.271毫秒</strong></p><p>看下当前 tb_user 的索引情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show index from tb_user\G;</span><br><span class="line">*************************** <span class="number">1</span>. row ***************************</span><br><span class="line">        Table: tb_user</span><br><span class="line">   Non_unique: <span class="number">0</span></span><br><span class="line">     Key_name: PRIMARY</span><br><span class="line"> Seq_in_index: <span class="number">1</span></span><br><span class="line">  Column_name: id # 索引列为 id 列</span><br><span class="line">    Collation: A</span><br><span class="line">  Cardinality: <span class="number">978848</span></span><br><span class="line">     Sub_part: NULL</span><br><span class="line">       Packed: NULL</span><br><span class="line">         Null:</span><br><span class="line">   Index_type: BTREE # 主键索引也是 B-Tree 索引</span><br><span class="line">      Comment:</span><br><span class="line">Index_comment:</span><br><span class="line"><span class="number">1</span> <span class="function">row in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">mysql&gt; explain select * from tb_user where id </span>= <span class="number">10000</span>\G;</span><br><span class="line">*************************** <span class="number">1</span>. row ***************************</span><br><span class="line">           id: <span class="number">1</span></span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: tb_user</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: <span class="keyword">const</span></span><br><span class="line">possible_keys: PRIMARY </span><br><span class="line">          key: PRIMARY   # 用到了主键索引</span><br><span class="line">      key_len: <span class="number">4</span></span><br><span class="line">          ref: <span class="keyword">const</span></span><br><span class="line">         rows: <span class="number">1</span></span><br><span class="line">     filtered: <span class="number">100.00</span></span><br><span class="line">        Extra: NULL</span><br></pre></td></tr></table></figure><h1 id="不使用索引查询"><a href="#不使用索引查询" class="headerlink" title="不使用索引查询"></a>不使用索引查询</h1><p>接下来我们根据 <strong>name</strong> 去查询数据， name 所在的字段现在还没有索引</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from tb_user where name = <span class="string">'jSMfqpAKV'</span>;</span><br><span class="line">+--------+-----------+------------+</span><br><span class="line">| id     | name      | birth      |</span><br><span class="line">+--------+-----------+------------+</span><br><span class="line">|  <span class="number">10000</span> | jSMfqpAKV | <span class="number">1994</span>-<span class="number">01</span>-<span class="number">25</span> |</span><br><span class="line">+--------+-----------+------------+</span><br><span class="line"><span class="number">2</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.20</span> sec)</span></span></span><br></pre></td></tr></table></figure><p>在 osx 上 mysql 并不区分大小写， 索引查询到两条数据， 接下来我们看下具体的耗时</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+----------+------------+------------------------------------------------+</span><br><span class="line">| Query_ID | Duration   | Query                                          |</span><br><span class="line">+----------+------------+------------------------------------------------+</span><br><span class="line">|        <span class="number">2</span> | <span class="number">0.19593300</span> | select * from tb_user where name = <span class="string">'jSMfqpAKV'</span> |</span><br><span class="line">+----------+------------+------------------------------------------------+</span><br><span class="line"><span class="number">1</span> rows in set, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>相比于使用 id 的主键查询， name 查询的速度慢了近千倍</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show profile <span class="keyword">for</span> query <span class="number">2</span>;</span><br><span class="line">+----------------------+----------+</span><br><span class="line">| Status               | Duration |</span><br><span class="line">+----------------------+----------+</span><br><span class="line">| starting             | <span class="number">0.000050</span> |</span><br><span class="line">| checking permissions | <span class="number">0.000006</span> |</span><br><span class="line">| Opening tables       | <span class="number">0.000012</span> |</span><br><span class="line">| init                 | <span class="number">0.000023</span> |</span><br><span class="line">| System lock          | <span class="number">0.000007</span> |</span><br><span class="line">| optimizing           | <span class="number">0.000008</span> |</span><br><span class="line">| statistics           | <span class="number">0.000013</span> |</span><br><span class="line">| preparing            | <span class="number">0.000009</span> |</span><br><span class="line">| executing            | <span class="number">0.000002</span> |</span><br><span class="line">| Sending data         | 0.195761 |   # 速度变慢的主要原因</span><br><span class="line">| end                  | <span class="number">0.000008</span> |</span><br><span class="line">| query end            | <span class="number">0.000004</span> |</span><br><span class="line">| closing tables       | <span class="number">0.000006</span> |</span><br><span class="line">| freeing items        | <span class="number">0.000016</span> |</span><br><span class="line">| cleaning up          | <span class="number">0.000008</span> |</span><br><span class="line">+----------------------+----------+</span><br></pre></td></tr></table></figure><p>可以看到Sending data 是查询耗时的主要原因， 这个 Sending data 到底是什么东西？ 是传输数据吗？<br><a href="https://dev.mysql.com/doc/refman/8.0/en/general-thread-states.html" target="_blank" rel="noopener">MySQL官方手册</a>的说法是 线程正在读取并处理select语句选择的行数据，然后将数据发送给客户端。因为这个状态期间的操作偏重执行大量的<strong>磁盘访问(读取磁盘)</strong>，它通常是整个查询生命周期中运行时间最长的状态。 所以说导致查询耗时的主要原因还是磁盘 IO。</p><h1 id="使用索引查询"><a href="#使用索引查询" class="headerlink" title="使用索引查询"></a>使用索引查询</h1><p>接下来我们对 name 字段加上索引</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="function">create index idx_tb_user_name on <span class="title">tb_user</span><span class="params">(name)</span></span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="function">rows <span class="title">affected</span> <span class="params">(<span class="number">1.44</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">-- 目前表中的索引</span></span><br><span class="line"><span class="function">mysql&gt; show index from tb_user\G</span>;</span><br><span class="line">*************************** <span class="number">1</span>. row ***************************</span><br><span class="line">        Table: tb_user</span><br><span class="line">   Non_unique: <span class="number">0</span></span><br><span class="line">     Key_name: PRIMARY</span><br><span class="line"> Seq_in_index: <span class="number">1</span></span><br><span class="line">  Column_name: id</span><br><span class="line">    Collation: A</span><br><span class="line">  Cardinality: <span class="number">978848</span></span><br><span class="line">     Sub_part: NULL</span><br><span class="line">       Packed: NULL</span><br><span class="line">         Null:</span><br><span class="line">   Index_type: BTREE</span><br><span class="line">      Comment:</span><br><span class="line">Index_comment:</span><br><span class="line">*************************** <span class="number">2</span>. row ***************************</span><br><span class="line">        Table: tb_user</span><br><span class="line">   Non_unique: <span class="number">1</span></span><br><span class="line">     Key_name: idx_tb_user_name</span><br><span class="line"> Seq_in_index: <span class="number">1</span></span><br><span class="line">  Column_name: name</span><br><span class="line">    Collation: A</span><br><span class="line">  Cardinality: <span class="number">988297</span></span><br><span class="line">     Sub_part: NULL</span><br><span class="line">       Packed: NULL</span><br><span class="line">         Null: YES</span><br><span class="line">   Index_type: BTREE  # 可以在创建索引时默认的类型也是 BTREE 索引</span><br><span class="line">      Comment:</span><br><span class="line">Index_comment:</span><br><span class="line"><span class="number">2</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br></pre></td></tr></table></figure><p>继续刚才的查询语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from tb_user where name = <span class="string">'jSMfqpAKV'</span>;</span><br><span class="line"></span><br><span class="line">mysql&gt; show profiles;</span><br><span class="line">+----------+------------+------------------------------------------------+</span><br><span class="line">| Query_ID | Duration   | Query                                          |</span><br><span class="line">+----------+------------+------------------------------------------------+</span><br><span class="line">|        <span class="number">1</span> | <span class="number">0.00028700</span> | select * from tb_user where name = <span class="string">'jSMfqpAKV'</span> |</span><br><span class="line">|        <span class="number">2</span> | <span class="number">0.00027100</span> | select * from tb_user where id = <span class="number">10000</span>         |</span><br><span class="line">+----------+------------+------------------------------------------------+</span><br></pre></td></tr></table></figure><p>此时耗时只有 0.28 毫秒, 虽然和主键查询相差无几， 但仍然没有主键查询快， 这是因为用过 name 索引是二级索引， 在查询时二级索引不会保留具体的数据行，保留的是主键 id。 查询时会根据二级索引先查询到 id， 再根据主键 id 找到数据所在的行。</p><h1 id="使用索引时的注意事项"><a href="#使用索引时的注意事项" class="headerlink" title="使用索引时的注意事项"></a>使用索引时的注意事项</h1><h2 id="禁止在查询语句中使用表达式"><a href="#禁止在查询语句中使用表达式" class="headerlink" title="禁止在查询语句中使用表达式"></a>禁止在查询语句中使用表达式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from tb_user where id + <span class="number">1</span> = <span class="number">5</span>\G;</span><br><span class="line">*************************** <span class="number">1</span>. row ***************************</span><br><span class="line">           id: <span class="number">1</span></span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: tb_user</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: ALL  # 全部查询</span><br><span class="line">possible_keys: NULL</span><br><span class="line">          key: NULL</span><br><span class="line">      key_len: NULL</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: <span class="number">998195</span></span><br><span class="line">     filtered: <span class="number">100.00</span></span><br><span class="line">        Extra: Using where</span><br><span class="line"><span class="number">1</span> row in set, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>可以看到使用表达式时索引是没有生效的。</p><h2 id="避免将索引列作为参数"><a href="#避免将索引列作为参数" class="headerlink" title="避免将索引列作为参数"></a>避免将索引列作为参数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">--- 先对 birth 创建索引</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="function">create index idx_tb_user_birth on <span class="title">tb_user</span><span class="params">(birth)</span></span>;</span><br><span class="line">mysql&gt; <span class="function">select <span class="title">count</span><span class="params">(*)</span> from tb_user where <span class="title">YEAR</span><span class="params">(current_date)</span> - <span class="title">YEAR</span><span class="params">(birth)</span> &gt;</span>= <span class="number">18</span> \G;</span><br><span class="line"></span><br><span class="line">+----------+------------+-----------------------------------------------------------------------------------+</span><br><span class="line">| Query_ID | Duration   | Query                                                                             |</span><br><span class="line">+----------+------------+-----------------------------------------------------------------------------------+</span><br><span class="line">|       <span class="number">12</span> | <span class="number">0.14596000</span> | <span class="function">select <span class="title">count</span><span class="params">(*)</span> from tb_user where <span class="title">YEAR</span><span class="params">(current_date)</span> - <span class="title">YEAR</span><span class="params">(birth)</span> &gt;</span>= <span class="number">18</span>         |</span><br><span class="line">+----------+------------+-----------------------------------------------------------------------------------+</span><br></pre></td></tr></table></figure><p>可以看到索然 在 birth 字段上新增了索引， 但是查询耗时为 0.14 秒， 和之前没加索引查询的耗时是差不多的。</p><h2 id="模糊查询时使用前缀索引"><a href="#模糊查询时使用前缀索引" class="headerlink" title="模糊查询时使用前缀索引"></a>模糊查询时使用前缀索引</h2><p>有时需要索引很长的字段时， 会让索引变的很大， 通常有两种做法， 一直是采用哈希索引， 另一种就是使用模糊查询。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;  select * from tb_user where name like  <span class="string">'%jSMfq%'</span>;</span><br><span class="line">+--------+-----------+------------+</span><br><span class="line">| id     | name      | birth      |</span><br><span class="line">+--------+-----------+------------+</span><br><span class="line">| <span class="number">312246</span> | jsmfQLlVW | <span class="number">2017</span>-<span class="number">03</span>-<span class="number">03</span> |</span><br><span class="line">| <span class="number">654276</span> | jsmfQMmbv | <span class="number">2019</span>-<span class="number">12</span>-<span class="number">07</span> |</span><br><span class="line">| <span class="number">629126</span> | jSMfqmpLL | <span class="number">1991</span>-<span class="number">08</span>-<span class="number">12</span> |</span><br><span class="line">...</span><br><span class="line">|  <span class="number">10000</span> | jSMfqpAKV | <span class="number">1994</span>-<span class="number">01</span>-<span class="number">25</span> |</span><br><span class="line">| <span class="number">298551</span> | jsmfQPAkv | <span class="number">1995</span>-<span class="number">12</span>-<span class="number">22</span> |</span><br><span class="line">| <span class="number">230069</span> | JSmFqPcQW | <span class="number">1982</span>-<span class="number">06</span>-<span class="number">15</span> |</span><br><span class="line">+--------+-----------+------------+</span><br><span class="line"><span class="number">81</span> <span class="function">rows in <span class="title">set</span> <span class="params">(**<span class="number">0.16</span>** sec)</span> --耗时 0.16 秒</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">mysql&gt; explain select * from tb_user where name like  '%jSMfq%'\G</span>;</span><br><span class="line">*************************** <span class="number">1</span>. row ***************************</span><br><span class="line">           id: <span class="number">1</span></span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: tb_user</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: ALL # 全表扫描</span><br><span class="line">possible_keys: NULL</span><br><span class="line">          key: NULL</span><br><span class="line">      key_len: NULL</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: <span class="number">998195</span></span><br><span class="line">     filtered: <span class="number">11.11</span></span><br><span class="line">        Extra: Using where</span><br><span class="line"><span class="number">1</span> row in set, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; explain select * from tb_user where name like  <span class="string">'jSMfq%'</span>\G;</span><br><span class="line">*************************** <span class="number">1</span>. row ***************************</span><br><span class="line">           id: <span class="number">1</span></span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: tb_user</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: range  # 范围查询</span><br><span class="line">possible_keys: idx_tb_user_name</span><br><span class="line">          key: idx_tb_user_name  </span><br><span class="line">      key_len: <span class="number">13</span></span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: <span class="number">11</span></span><br><span class="line">     filtered: <span class="number">100.00</span></span><br><span class="line">        Extra: Using index condition # 使用索引进行条件查询</span><br><span class="line"><span class="number">1</span> row in set, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>这是由于 BTREE 索引的数据是有序的使用 like ‘%xxx%’时是无法使用索引的。</p><h2 id="不要对每一列都创建单独的索引"><a href="#不要对每一列都创建单独的索引" class="headerlink" title="不要对每一列都创建单独的索引"></a>不要对每一列都创建单独的索引</h2><p>为每个列创建单独的索引大部分情况下并不能提升 MySQL 的查询性能，在 MySQL5.0 及更新的版本中，引入了索引合并的策略， 将每列查询的结果进行合并， 举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain  select * from tb_user where id = <span class="number">10000</span> or name like <span class="string">'jSMfqp%'</span>\G;</span><br><span class="line">*************************** <span class="number">1</span>. row ***************************</span><br><span class="line">           id: <span class="number">1</span></span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: tb_user</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: index_merge</span><br><span class="line">possible_keys: PRIMARY,idx_tb_user_name</span><br><span class="line">          key: idx_tb_user_name,PRIMARY</span><br><span class="line">      key_len: <span class="number">13</span>,<span class="number">4</span></span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: <span class="number">4</span></span><br><span class="line">     filtered: <span class="number">100.00</span></span><br><span class="line">        Extra: Using sort_union(idx_tb_user_name,PRIMARY); Using where   # MySQL 内部索引合并</span><br><span class="line"><span class="number">1</span> row in set, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>通过 explain 可以看到， MySQL 在实际的查询过程内还进行类内部优化， 将 通过 id 查询的数据与 name 查询的数据做了合并操作，在实际的查询过程中建立一个相关列的多列索引效果会更好。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from tb_user where name = <span class="string">'jSMfqpAKV'</span> and  birth =<span class="string">'1970-01-01'</span>\G;</span><br><span class="line">*************************** <span class="number">1</span>. row ***************************</span><br><span class="line">           id: <span class="number">1</span></span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: tb_user</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: index_merge</span><br><span class="line">possible_keys: idx_tb_user_name,idx_tb_user_birth</span><br><span class="line">          key: idx_tb_user_name,idx_tb_user_birth</span><br><span class="line">      key_len: <span class="number">13</span>,<span class="number">4</span></span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: <span class="number">1</span></span><br><span class="line">     filtered: <span class="number">100.00</span></span><br><span class="line">        Extra: Using intersect(idx_tb_user_name,idx_tb_user_birth); Using where; Using index   # 取了两部分数据的交集</span><br><span class="line"><span class="number">1</span> row in set, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>此时 name 与 birth 都只有单独的索引， Extra中的信息表明使用了交集来进行数据合并。 我们为 name，birth 建立一个多列索引后再进行查询</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mysql&gt; <span class="function">create index idx_name_birth on <span class="title">tb_user</span><span class="params">(name, birth)</span></span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="function">rows <span class="title">affected</span> <span class="params">(<span class="number">1.14</span> sec)</span></span></span><br><span class="line"><span class="function">Records: 0  Duplicates: 0  Warnings: 0</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">mysql&gt; explain select * from tb_user where name </span>= <span class="string">'jSMfqpAKV'</span> and  birth =<span class="string">'1970-01-01'</span>\G;</span><br><span class="line">*************************** <span class="number">1</span>. row ***************************</span><br><span class="line">           id: <span class="number">1</span></span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: tb_user</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: ref</span><br><span class="line">possible_keys: idx_tb_user_name,idx_tb_user_birth,idx_name_birth</span><br><span class="line">          key: idx_name_birth</span><br><span class="line">      key_len: <span class="number">17</span></span><br><span class="line">          ref: <span class="keyword">const</span>,<span class="keyword">const</span></span><br><span class="line">         rows: <span class="number">1</span></span><br><span class="line">     filtered: <span class="number">100.00</span></span><br><span class="line">        Extra: Using index  # 通过索引查询</span><br><span class="line"><span class="number">1</span> row in set, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>可以看到在实际的查询中是走的索引进行查询， MySQL 无需再对查询的结果优化处理。</p><p>参考： <a href="https://blog.hufeifei.cn/2018/04/24/DB/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%5B%E5%AE%9E%E8%B7%B5%E7%AF%87%5D-%E4%BD%BF%E7%94%A8B%E6%A0%91%E7%B4%A2%E5%BC%95/" target="_blank" rel="noopener">MySQL性能优化[实践篇]-使用B树索引</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 86. Partition List</title>
      <link href="/2020/02/26/leetcode/linkedlist/partition-list/"/>
      <url>/2020/02/26/leetcode/linkedlist/partition-list/</url>
      
        <content type="html"><![CDATA[<p>Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.</p><a id="more"></a><p>You should preserve the original relative order of the nodes in each of the two partitions.</p><h1 id="Example"><a href="#Example" class="headerlink" title="Example:"></a>Example:</h1><blockquote><p>Input: head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3</p><p>Output: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5</p></blockquote><h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给出一个值 x ， 把两边分成两部分， 链表的结点的值比 x 小的位于大于等于 x 的节点之前， 并保持相对位置不变。<br>给出  1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3 。 比 3 小的有 1，2，2, 大于等于 3 的结点有 4，3，5<br>分区后得到结果： 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>既然分区， 分别使用两个链表存储小于 x 的结点以及大于等于 x 的结点， 遍历结束后， 将两个节点相连接；<br><img src="/2020/02/26/leetcode/linkedlist/partition-list/demo.jpg" alt="demo"></p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">partition</span><span class="params">(ListNode head, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ListNode smallHead = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        ListNode bigHead = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        ListNode smallNode = smallHead;</span><br><span class="line">        ListNode bigNode =  bigHead;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(head.val &lt; x) &#123;</span><br><span class="line">                smallNode.next = head;</span><br><span class="line">                smallNode = smallNode.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                bigNode.next = head;</span><br><span class="line">                bigNode = bigNode.next;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        smallNode.next = bigHead.next;</span><br><span class="line">        <span class="comment">// 断开与原始链表的链接</span></span><br><span class="line">        bigNode.next = <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> smallHead.next;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每周一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> linkedlist </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 82. Remove Duplicates from Sorted List II</title>
      <link href="/2020/02/23/leetcode/linkedlist/remove-duplicates-from-sorted-list-ii/"/>
      <url>/2020/02/23/leetcode/linkedlist/remove-duplicates-from-sorted-list-ii/</url>
      
        <content type="html"><![CDATA[<p>Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list.</p><a id="more"></a><h1 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h1><blockquote><p>Input: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5</p><p>Output: 1-&gt;2-&gt;5</p></blockquote><h1 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2:"></a>Example 2:</h1><blockquote><p>Input: 1-&gt;1-&gt;1-&gt;2-&gt;3</p><p>Output: 2-&gt;3</p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>题意是给出一个有序链表， 删除所有的重复的元素，对重复元素不做保留。</p><p>例子2 可以看到有头结点和之后元素重复的情况， 所有需要利用虚拟头结点；</p><ul><li><ol><li>pre指向虚拟头结点，pre.next 指向头结点，cur 指针从头结点进行遍历；</li></ol></li><li><ol start="2"><li>判断否存在多个相同值的结点，若有遍历到最后一个重复元素：</li></ol><ul><li>当pre.next  != cur时， 说明中间遍历的元素是重复的， 删除重复的元素</li><li>pre.next  == cur 时， 说明前后没有重复的元素， pre 与 cur 指针分别指向下一个元素</li></ul></li><li><ol start="3"><li>重复 <strong>步骤 2.</strong> 继续遍历元素进行判断</li></ol></li></ul><h1 id="示意图"><a href="#示意图" class="headerlink" title="示意图"></a>示意图</h1><p>示意图如下：<br><img src="/2020/02/23/leetcode/linkedlist/remove-duplicates-from-sorted-list-ii/demo.jpg" alt="demo"></p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ListNode dummyHead = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    dummyHead.next = head;</span><br><span class="line">    ListNode pre = dummyHead;</span><br><span class="line">    ListNode curr = head;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 遍历重复的元素， 直到最后一个</span></span><br><span class="line">        <span class="keyword">while</span>(curr.next != <span class="keyword">null</span> &amp;&amp; curr.val == curr.next.val) &#123;</span><br><span class="line">            curr = curr.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 两个结点不同， 继续遍历</span></span><br><span class="line">        <span class="keyword">if</span>(pre.next == curr) &#123;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//删除重复的元素</span></span><br><span class="line">            pre.next = curr.next;</span><br><span class="line">        &#125;</span><br><span class="line">        curr = curr.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每周一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> linkedlist </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 83.Remove Duplicates from Sorted List</title>
      <link href="/2020/02/23/leetcode/linkedlist/remove-duplicates-from-sorted-list/"/>
      <url>/2020/02/23/leetcode/linkedlist/remove-duplicates-from-sorted-list/</url>
      
        <content type="html"><![CDATA[<p>Given a sorted linked list, delete all duplicates such that each element appear only once.</p><a id="more"></a><h1 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h1><blockquote><p>Input: 1-&gt;1-&gt;2<br>Output: 1-&gt;2</p></blockquote><h1 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2:"></a>Example 2:</h1><blockquote><p>Input: 1-&gt;1-&gt;2-&gt;3-&gt;3<br>Output: 1-&gt;2-&gt;3</p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>题意是给出一个有序链表， 删除重复的元素只保留一个。</p><p>具体思路：</p><ul><li>从头结点遍历， 如果下一个结点与当前结点的 value 一致，删除下一个结点， node.next = node.next.next</li><li>如果下一个结点与当前结点的 value 不一致， node = node.next， 继续遍历</li></ul><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode ref = head;</span><br><span class="line">        <span class="keyword">while</span> (ref != <span class="keyword">null</span> &amp;&amp; ref.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ref.val == ref.next.val) &#123;</span><br><span class="line">                ref.next = ref.next.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ref = ref.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每周一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> linkedlist </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 61. Rotate List</title>
      <link href="/2020/02/23/leetcode/linkedlist/rotate-list/"/>
      <url>/2020/02/23/leetcode/linkedlist/rotate-list/</url>
      
        <content type="html"><![CDATA[<p>Given a linked list, rotate the list to the right by k places, where k is non-negative.</p><a id="more"></a><h1 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h1><blockquote><p>Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2<br>Output: <strong>4-&gt;5</strong>-&gt;1-&gt;2-&gt;3-&gt;NULL<br>Explanation:<br>rotate 1 steps to the right: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL<br>rotate 2 steps to the right: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</p></blockquote><h1 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2:"></a>Example 2:</h1><blockquote><p>Input: 0-&gt;1-&gt;2-&gt;NULL, k = 4<br>Output: <strong>2</strong>-&gt;0-&gt;1-&gt;NULL<br>Explanation:<br>rotate 1 steps to the right: 2-&gt;0-&gt;1-&gt;NULL<br>rotate 2 steps to the right: 1-&gt;2-&gt;0-&gt;NULL<br>rotate 3 steps to the right: 0-&gt;1-&gt;2-&gt;NULL<br>rotate 4 steps to the right: 2-&gt;0-&gt;1-&gt;NULL</p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>题意从链表右边的第 k 个结点， 然后进行翻转。<br>如果 k &lt; 链表的长度， 从链表的倒数第 k 个结点翻转；<br>如果 k &gt; 链表的长度， 从链表的第 len -  k%len 个结点翻转；</p><p>具体思路：</p><blockquote><ul><li>遍历链表得到当前链表的长度 length；</li><li>头尾相连；</li><li>若k &gt; length，从头遍历到第 k 个结点， 然后断开；若 k &gt; 链表的长度， 从链表的第 len -  k%len 个结点断开。</li></ul></blockquote><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">rotateRight</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">1</span>;</span><br><span class="line">    ListNode tail  = head;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算链表长度</span></span><br><span class="line">    <span class="keyword">while</span>(tail.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        len++;</span><br><span class="line">        tail = tail.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 头尾相连</span></span><br><span class="line">    tail.next = head;</span><br><span class="line">    ListNode temp = head;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//找到倒数第 k 个结点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;len - k%len; i++) &#123;</span><br><span class="line">        temp = temp.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 新的头结点</span></span><br><span class="line">    head  = temp.next;</span><br><span class="line">    <span class="comment">// 断开链表</span></span><br><span class="line">    temp.next = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每周一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> linkedlist </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 25. Reverse Nodes In k Group</title>
      <link href="/2020/02/23/leetcode/linkedlist/reverse-nodes-in-k-group/"/>
      <url>/2020/02/23/leetcode/linkedlist/reverse-nodes-in-k-group/</url>
      
        <content type="html"><![CDATA[<p>Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.</p><a id="more"></a><p>k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.</p><h1 id="Example"><a href="#Example" class="headerlink" title="Example:"></a>Example:</h1><blockquote><p>Given this linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5</p><p>For k = 2, you should return: 2-&gt;1-&gt;4-&gt;3-&gt;5</p><p>For k = 3, you should return: 3-&gt;2-&gt;1-&gt;4-&gt;5</p></blockquote><ul><li><p>Note</p><p>  Only constant extra memory is allowed.</p><p>  You may not alter the values in the list’s nodes, only nodes itself may be changed.</p></li></ul><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>题意为一次翻转链表中 k 个元素，如果 k = 2， 即每两个两个元素进行翻转，然后返回翻转后的链表。</p><p>具体思路：</p><blockquote><p>每次翻转 k 个结点， 循环进行<br>循环终止的条件是循环到最后一个节点</p></blockquote><p>示意图如下：</p><p><img src="/2020/02/23/leetcode/linkedlist/reverse-nodes-in-k-group/reverse-nodes-k.jpg" alt="demo"></p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseKGroup</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode dummyHead = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        dummyHead.next = head;</span><br><span class="line">        ListNode pre = dummyHead;</span><br><span class="line">        ListNode tail = dummyHead;</span><br><span class="line">        ListNode temp = <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (count &lt; k &amp;&amp; tail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                count++;</span><br><span class="line">                tail = tail.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (tail == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            head = pre.next;</span><br><span class="line">            <span class="keyword">while</span> (pre.next != tail) &#123;</span><br><span class="line">                temp = pre.next;</span><br><span class="line">                pre.next = temp.next;</span><br><span class="line">                temp.next = tail.next;</span><br><span class="line">                tail.next = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            tail = head;</span><br><span class="line">            pre = head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每周一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> linkedlist </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>B-Tree 索引和 Hash 索引</title>
      <link href="/2020/02/23/mysql/note-3-btree-and-hash/"/>
      <url>/2020/02/23/mysql/note-3-btree-and-hash/</url>
      
        <content type="html"><![CDATA[<p>什么是 B-Tree 索引与 Hash 索引？</p><a id="more"></a><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>索引的定义： 存储引擎用于快速找到记录的一种数据结构。</p><p>假设数据库是一本书， 索引就是书中的目录， 能让我们更快的找到我们需要查询的内容。 如果没有目录我们需要把整本书翻一遍， 运气不好可能需要翻到最后一页才能找到我们需要查找的内容。</p><h1 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h1><h2 id="按逻辑存储结构划分"><a href="#按逻辑存储结构划分" class="headerlink" title="按逻辑存储结构划分"></a>按逻辑存储结构划分</h2><ul><li><p>B树索引（按物理结构划分又可以分为聚簇索引和非聚簇索引）</p></li><li><p>Hash 索引</p></li><li><p>空间索引</p></li><li><p>全文索引</p></li></ul><h2 id="建立在单列还是多列划分"><a href="#建立在单列还是多列划分" class="headerlink" title="建立在单列还是多列划分"></a>建立在单列还是多列划分</h2><ul><li><p>单列索引</p></li><li><p>符合索引</p></li></ul><h2 id="约束条件划分"><a href="#约束条件划分" class="headerlink" title="约束条件划分"></a>约束条件划分</h2><ul><li><p>唯一索引</p></li><li><p>主键索引</p></li></ul><p>接下来介绍常见的 B-Tree 索引和 Hash 索引</p><h1 id="B-Tree-索引"><a href="#B-Tree-索引" class="headerlink" title="B-Tree 索引"></a>B-Tree 索引</h1><p>数据库采用 B-Tree 索引的原因很简单： <strong>减少随机磁盘 IO 次数</strong>。原因在于数据的量很大，大部分的数据都是存储在磁盘中， 不可能全部存储在内存中。</p><p>为什么说 B-Tree 索引更适合数据库存储数据， 咱们可以将 B-Tree 的结构和其他的数据结构做下对比， 以 B-Tree 与红黑树为例。</p><p>在这先看下红黑树与 B-树的特点：</p><ul><li>红黑树<ol><li>每个结点要么是红的，要么是黑的。</li><li>根结点是黑的。</li><li>每个叶结点（叶结点即指树尾端NIL指针或NULL结点）是黑的。</li><li>如果一个结点是红的，那么它的俩个儿子都是黑的。</li><li>对于任一结点而言，其到叶结点树尾端NIL指针的每一条路径都包含相同数目的黑结点。</li></ol></li></ul><p><img src="/2020/02/23/mysql/note-3-btree-and-hash/black-tree.gif" alt="红黑树"></p><p>红黑树的特点使得红黑树不仅是棵平衡树， 而且比平衡树更加平衡， 读取数据的次数更少。</p><ul><li>B-树：是一种多路搜索树（并不是二叉的）<ol><li>根结点至少有两个子节点。</li><li>每个中间节点(根节点和叶子节点除外)都包含k-1个元素和k个孩子节点，其中 m/2 &lt;= k &lt;= m 。m 代表树的高度， 也叫做阶。</li><li>每一个叶子节点都包含k-1个元素，其中 m/2 &lt;= k &lt;= m。</li><li>所以的值都是按顺序存储的。</li><li>每个叶子页到根的距离相同。</li></ol></li></ul><p><img src="/2020/02/23/mysql/note-3-btree-and-hash/b-tree.gif" alt="B-Tree"></p><p>在对比时可以发现， 想要找到 008 的这个数， 在红黑树需要遍历三次， 而在 B-Tree 中只需要两次即可。当数据量越来越大时， B-Tree 会变的矮胖起来， 同样的数据量在 B-Tree 中需要查找的次数更少。对于相同的数据量，B树的更矮，高度更低，查找数据时经过的节点更少，所以造成的随机磁盘IO次数也就更少。(文件索引数据库索引用的都是B树)</p><h1 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B+Tree"></a>B+Tree</h1><p>InnoDB引擎内部使用的是 B+Tree 作为索引的存储结构。</p><ul><li><p>在进行数据查找时，通过比较 key 来找到对应的 value (也就是我们要查找的数据)。B树每个数据的 Key-Value 都是存储在一起的(实际上value部分只是存储了数据行的引用)，每次比较key的时候都会把 value 也给读取出来，这就造成了不必要的磁盘IO。</p></li><li><p>另外数据库经常会出现范围查询的需求，单纯的B树进行范围查询需要回溯到父节点，这也造成了大量的I/O操作，而且这个操作相当复杂。</p></li></ul><p>为了解决这些问题B树的发明者对B树进行了一些改进。</p><p>B+树是B树的变体，它的完整数据全部存储在叶子结点，非叶子节点只存储key值，这样B+树避免了不必要的磁盘I/O，由于所有的查找最终都会到叶子结点，所以也就保证了查询性能的稳定。</p><p>同时由于B+树叶子结点使用指针串联起来，这就方便了范围查询(&gt;、&lt;、between等)。</p><p>而且由于B+树索引本身的有序性，所以在很多情况下可以避免对数据的排序(对磁盘排序要用到文件外排序，而且数据量很大很耗时)。</p><p><img src="/2020/02/23/mysql/note-3-btree-and-hash/b-tree-index.jpg" alt="B-Tree索引"></p><p>总结起来，使用B+树作为数据库索引的存储结构有以下原因：</p><ul><li>减少磁盘I/O，并尽量避免不必要的磁盘I/O</li><li>B+树保证了查询性能的稳定</li><li>B+树方便范围查询</li><li>避免对数据进行外排序(filesort)</li></ul><h1 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h1><p>hash在很多编程语言中都能见到，因为它查找速度非常快，理论上平均时间复杂度能达到O(1)。 是 Memory引擎的默认索引。</p><p>存储引擎对每一列计算出一个哈希码，将其保存在哈希表中， 同时哈希表保存每行的指针, 如果出现 hash 碰撞， 索引会以链表的形式存放多个记录到同一条哈希目录上， 结构类似于 HashTable。</p><p>举个例子：</p><table><thead><tr><th>name</th><th>age</th></tr></thead><tbody><tr><td>Jane</td><td>28</td></tr><tr><td>Peter</td><td>20</td></tr><tr><td>David</td><td>30</td></tr></tbody></table><p>假设使用哈希函数f()，对每条记录生成哈希值：<br>f(‘Jane’) = 2323<br>f(‘Peter’) = 2456<br>f(‘David’) = 2400</p><table><thead><tr><th>槽(slot)</th><th>值（value)</th></tr></thead><tbody><tr><td>2323</td><td>第一行指针</td></tr><tr><td>2456</td><td>第三行指针</td></tr><tr><td>2400</td><td>第二行指针</td></tr></tbody></table><p>看有hash 索引具体是如何工作的， 举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from user where `name` = <span class="string">'Jane'</span></span><br></pre></td></tr></table></figure><p>执行上面这条 sql 语句会先计算 Jane 的哈希值， 然后根据哈希值 2323 对应的指针去找到对应的第一行数据。</p><p><img src="/2020/02/23/mysql/note-3-btree-and-hash/hash-index.jpg" alt="哈希索引"></p><p>单行查询的速度要比 B-Tree索引快很多，但hash索引在使用上有很大的局限性：</p><ul><li>无序性，导致无法范围查找和索引排序。</li><li>between, &gt; 、&lt;、等范围查询无法使用索引。</li><li>对完整的key计算hash，所以不支持部分匹配。</li><li>比如对多个列创建hash索引，查找时条件必须这些列精确匹配，才能使用到hash索引。都精确匹配了，更别谈什么索引覆盖。</li><li>再比如，使用like ‘hash%’进行前缀匹配，也无法使用hash索引。</li><li>由于hash索引实际只保存了数据对应的行指针，所以不能避免读取数据行(说白了还是没有索引覆盖的功能)。</li><li>当产生hash碰撞(哈希值相同)的时候，数据库要遍历链表中所有的行指针，逐个取出数据行进行比较，数据量越大，冲突越多，查找代价越高。</li></ul><p>由于hash索引的上述缺点，所以实际使用hash索引的情况很少，MySQL除了Memory存储引擎和NDB分布式存储引擎，其他大部分存储引擎默认使用B树索引。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo + Github 搭建博客（Mac篇）</title>
      <link href="/2020/02/18/blog/git-pages-mac/"/>
      <url>/2020/02/18/blog/git-pages-mac/</url>
      
        <content type="html"><![CDATA[<p>本文教你如何利用 github pages 快速白嫖一个博客！</p><a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>当你看到这篇文章时， 已经默认你对github pages有了一定的了解。</p><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><ul><li><p>git</p><p>  <a href="https://git-scm.com/" target="_blank" rel="noopener">Git官网下载</a><br>  安装完成后查看git是否安装成功</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git --version</span><br><span class="line"></span><br><span class="line">git version <span class="number">2.18</span>.0</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>Node.js</p><p>  <a href="https://nodejs.org/zh-cn/" target="_blank" rel="noopener">Node.js下载</a><br>  安装完成后， node -v 检查下是否安装完成</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br><span class="line">v11.7.0</span><br><span class="line"></span><br><span class="line">npm -v</span><br><span class="line"><span class="number">6.5</span>.0</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>github: xxx.github.io (其中xxx是你github的用户名)</p><ol><li>使用邮箱注册github。</li><li>创建的用户名.github.io的仓库，比如说，如果你的github用户名是xxx，那么你就新建xxx.github.io的仓库（必须是你的用户名，其它名称无效）。</li></ol></li><li><p>生成ssh key</p><ol><li><p>为了能在本地操作github仓库， 还需要生成ssh key, <strong>ssh-keygen -t rsa -C “github 邮箱”</strong>。</p></li><li><p>vi id_rsa.pub, 拿到密钥添加到github账号设置中即可操作本地仓库同步数据到远程。</p></li><li><p>打开 <a href="https://github.com/settings/keys" target="_blank" rel="noopener">GitHub_Settings_Keys</a> 将ssh key添加进去。</p></li><li><p>不确定是否添加成功， 可以在命令行输入 ssh -T <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cd  ~/.ssh</span><br><span class="line">ssh-keygen -t rsa -C <span class="string">"你的邮箱地址"</span>   <span class="comment">// 然后一路回车</span></span><br><span class="line"></span><br><span class="line">vi id_rsa.pub  <span class="comment">// 将id_rsa.pub中的key添加到github中</span></span><br><span class="line"></span><br><span class="line">ssh -T git<span class="meta">@github</span>.com   <span class="comment">// 测试key是否添加成功</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 出现这串文字提示你添加成功了</span></span><br><span class="line">Hi username! You<span class="string">'ve successfully authenticated, but GitHub does not</span></span><br><span class="line"><span class="string">provide shell access.</span></span><br></pre></td></tr></table></figure></li></ol></li></ul><h1 id="Hexo-安装"><a href="#Hexo-安装" class="headerlink" title="Hexo 安装"></a>Hexo 安装</h1><p>使用npm命令安装Hexo，输入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli </span><br><span class="line"></span><br><span class="line">hexo init blog   <span class="comment">// 可以创建一个blog</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一篇博客文章</span></span><br><span class="line">hexo <span class="keyword">new</span> first_page</span><br><span class="line"></span><br><span class="line">hexo g</span><br><span class="line"></span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>然后在浏览器输入 <a href="localhost:4000" target="_blank" rel="noopener">localhost:4000</a> 即可看到这篇文章</p><p>常见的 hexo 命令有以下几个：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hexo <span class="keyword">new</span> <span class="type"></span>文章名称  <span class="comment">// 在</span></span><br><span class="line"></span><br><span class="line">hexo clean  <span class="comment">// 清空缓存， 一般不用也行</span></span><br><span class="line"></span><br><span class="line">hexo g  <span class="comment">//生成文章</span></span><br><span class="line"></span><br><span class="line">hexo s <span class="comment">// 本地预览</span></span><br></pre></td></tr></table></figure><p>更多的指令可以见： <a href="https://hexo.io/zh-cn/docs/commands.html" target="_blank" rel="noopener">Hexo 命令</a></p><h1 id="博客部署"><a href="#博客部署" class="headerlink" title="博客部署"></a>博客部署</h1><p>以上的操作只是在本地预览文章， 要想让我们的文章让更多的人看见， 需要把文章推送到远程仓库， 发布到xxx.github.io</p><ul><li>打开blog目录下的 _config.yml 文件， 填上github仓库的地址</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: </span><br><span class="line">    github: git<span class="meta">@github</span>.com:HarryHook/harryhook.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>上面的这个配置就是为了让hexo知道你要把blog部署在哪个位置，很显然，我们部署在我们GitHub的仓库里。</p><p>Git部署插件，输入命令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后部署三连走一波</span></span><br><span class="line"></span><br><span class="line">hexo clean </span><br><span class="line">hexo g </span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>然后在 xxx.github.io 就可以看到你的博客了</p><h1 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h1><p>hexo 默认的主题是 landscape， 在 blog 的 themes 下可以看到你使用的主题， 这个主题也是在 _config.yml 进行配置的， 如果你想尝试其他的主题， 可以到 <a href="https://hexo.io/themes/" target="_blank" rel="noopener">Themes</a> 进行下载， 下载到 blog 的 themes 目录下即可。</p><p>主题的配置在根目录下的 _config.yml 进行配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: yelee  <span class="comment">// 与你themes的博客主题名称一致即可</span></span><br></pre></td></tr></table></figure><h1 id="Markdown语法"><a href="#Markdown语法" class="headerlink" title="Markdown语法"></a>Markdown语法</h1><p>Mac 下推荐使用 MacDown软件 对 md 文件进行编辑， 因为创建的文章都是  .md的， 一些 markdown 的语法可以参考<a href="https://www.runoob.com/markdown/md-tutorial.html" target="_blank" rel="noopener">菜鸟教程</a>， 多摸索多实践。</p><h1 id="其他个性化配置"><a href="#其他个性化配置" class="headerlink" title="其他个性化配置"></a>其他个性化配置</h1><ul><li><p>添加 gitalk 插件</p></li><li><p>PV UV 访问次数</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 建站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Schema设计与数据类型优化</title>
      <link href="/2020/02/16/mysql/note-2-shcema-design/"/>
      <url>/2020/02/16/mysql/note-2-shcema-design/</url>
      
        <content type="html"><![CDATA[<p>MySQL常见的数据类型有哪些？ 数据库在设计的过程中应该注意哪些地方？</p><a id="more"></a><h1 id="如何选择数据类型"><a href="#如何选择数据类型" class="headerlink" title="如何选择数据类型"></a>如何选择数据类型</h1><ul><li><p>越小越好</p><p>  越小的数据类型占用更少的磁盘、内存、CPU缓存。 但需要注意当前类型存储值的范围。</p></li><li><p>简单就好</p><p>  简单的数据类型需要更少的CPU周期， 整形比字符串的代价要低。 两个例子， 使用MySQL内建的datetime或者timestamp存储日期和时间而不是用字符串存储。还有就是应该使用整形存储ip， 而不是字符串存储。</p></li><li><p>尽量避免null值</p><p>  通常情况下最好指定列为not null， 查询包含null的列成本更高， 而且会使用更多的存储空间， 当NULL列被索引时， 需要额外的一个字节去存储。</p></li></ul><h1 id="常见的数据类型"><a href="#常见的数据类型" class="headerlink" title="常见的数据类型"></a>常见的数据类型</h1><h2 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h2><p>整数类型分别有以下： TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT。分别占用8， 16， 24， 32， 64位存储空间，以TINYINT为例， 存储范围为-2^7 ~ 2^7-1, 即-128~127。</p><p>整数类型可选UNSIGNED属性， 表示不允许为负值， 例如 TINYINT UNSIGNED可存储的范围0~255。</p><p>限定整数类型的范围是没有意义的， INY(2)与INT(20)是相同的， 只是展示字符的个数会受到限制。</p><h2 id="实数类型"><a href="#实数类型" class="headerlink" title="实数类型"></a>实数类型</h2><p>实数指的是带有小数部分的数字，但不一定只用实数存储带小数的值， 还可以用DECIMAL存储比BIGINT还大的整数。 因为CPU是不支持DECIMAL的直接运算的，MySQL内部支持高精度运算。因为CPU支持浮点数的计算， 所以浮点预算的速度更快， MySQL内部是以DOUBLE作为内部浮点计算的类型。</p><p>因为需要额外的空间和计算开销， 所以只在精确计算时才使用DECIMAL， 但是当数据量比较大时， 可以考虑使用BIGINT代替DECIMAL， 将需要存储的小数乘以相应的倍数， 避免浮点数存储计算不精确和DECIMAL计算代价过高的问题。</p><h2 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h2><p>MySQL支持多种字符串类型， 每种类型还有很多变种。 其中VARCHAR和CHAR是最主要的两种字符串类型。</p><ul><li><p>VARCHAR</p><p>  VARCHAR类型用于存储可变长字符串， 是最常见的数据类型， 比定长类型更节省空间。越短的字符串使用越少的空间， 但在ROW_FORMAT=FIXED时是例外情况，每一行都会使用定长存储。</p><p>  VARCHAR需要使用1到2个额外的字节记录字符串的长度。 如果列的最大长度=255字节， 只需要1个字节表示，否则需要2个。 2^8 = 256， VARCHAR(10)需要11个字节的存储空间， VARCHAR(1000)需要1002个字节， 因为需要2个字节存储长度信息。</p><p>  VARCHAR节省了空间， 但是当执行UPDATE操作时， 行可能变的更长， 当页内没有多余的空间可以存储时，InnoDB需要分裂页来处理，MyISAM需要将行拆成不同的片段存储， 但InnoDB会将过长VARCHAR存储为BLOB</p></li><li><p>CHAR </p><p>  CHAR是定长的， MySQL会根据定义的字符串长度分配足够的空间。 CHAR适合存储很短的字符串， 或者所有值都接近同一长度， 例如密码的MD5值。 <strong>CHAR有一个特点， 就是会删除所有末尾的空格</strong>， 存储数据时需要注意。</p></li></ul><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CREATE TABLE <span class="title">char_test</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    char_col CHAR(<span class="number">10</span>)</span>,</span></span><br><span class="line"><span class="function">    varchar_col <span class="title">VARCHAR</span><span class="params">(<span class="number">10</span>)</span></span></span><br><span class="line"><span class="function">)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">INSERT INTO <span class="title">char_test</span><span class="params">(char_col)</span> <span class="title">VALUES</span> <span class="params">(<span class="string">'string1'</span>)</span>, <span class="params">(<span class="string">'  string2'</span>)</span>, <span class="params">(<span class="string">'string3  '</span>)</span></span>;</span><br><span class="line"><span class="function">INSERT INTO <span class="title">char_test</span><span class="params">(varchar_col)</span> <span class="title">VALUES</span> <span class="params">(<span class="string">'string1'</span>)</span>, <span class="params">(<span class="string">'  string2'</span>)</span>, <span class="params">(<span class="string">'string3  '</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">select <span class="title">CONCAT</span><span class="params">(<span class="string">"'"</span>,char_col, <span class="string">"'"</span>)</span>  from char_test</span>;</span><br><span class="line">+---------------------------+</span><br><span class="line">| CONCAT(<span class="string">"'"</span>,char_col, <span class="string">"'"</span>) |</span><br><span class="line">+---------------------------+</span><br><span class="line">| <span class="string">'string1'</span>               |</span><br><span class="line">| <span class="string">'  string2'</span>             |</span><br><span class="line">| <span class="string">'string3'</span>               |</span><br><span class="line">+---------------------------+</span><br><span class="line"></span><br><span class="line"><span class="function">select <span class="title">CONCAT</span><span class="params">(<span class="string">"'"</span>,varchar_col, <span class="string">"'"</span>)</span>  from char_test</span>;</span><br><span class="line">+------------------------------+</span><br><span class="line">| CONCAT(<span class="string">"'"</span>,varchar_col, <span class="string">"'"</span>) |</span><br><span class="line">+------------------------------+</span><br><span class="line">| <span class="string">'string1'</span>                  |</span><br><span class="line">| <span class="string">'  string2'</span>                |</span><br><span class="line">| <span class="string">'string3  '</span>                |</span><br><span class="line">+------------------------------+</span><br></pre></td></tr></table></figure><p>可以看到char存储字符串数，string3的末尾的空格被截断了， 而varchar存储数据时不会存在这种情况。</p><ul><li><p>BLOB与TEXT类型</p><p>  BLOB与TEXT都是为存储很大的数据而设计的字符串数据类型， 分别采用二进制和字符方式存储， MySQL将BLOB与TEXT值当一个独立的对象处理，当BLOB和TEXT的值太大时，MySQL会专门建立一个存储区域来进行存储， 在行内用1~4个字节存储一个指针， 指向外部存储实际值的区域。</p><p>  BLOG与TEXT的区别在于BLOB存储的是二进制数据， 没有排序规则或者字符集，TEXT类型有字符集和排序规则。</p><p>  此外MySQL对BLOB与TEXT列进行排序与其他类型是不同的： 只对每列最前max_sort_length字节而不是整个字符串进行排序，可以动态调整max_sort_length或者ORDER BY SUNSTRING(column, length)来进行排序。</p><p>  MySQL不能将BOLB与TEXT列的全部长度的字符串进行索引， Memory引擎也不支持BLOB和TEXT类型， 如果查询BLOB或者TEXT列将生成隐式临时表， 即使临时表存储在内存上系统间的调用开销也很大， 所以尽量不要使用BLOB或者TEXT类型。 万不得已使用了，在用到BLOB字段的地方使用SUBSTRING(column, length）将列值转换为字符串。</p></li></ul><ul><li><p>枚举</p><p>  枚举代替常见的字符串</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CREATE TABLE <span class="title">enum_test</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">e ENUM(<span class="string">'fish'</span>, <span class="string">'apple'</span>, <span class="string">'dog'</span>)</span> NOT NULL)</span>;</span><br><span class="line">    </span><br><span class="line">--插入不属于枚举的值时--</span><br><span class="line"></span><br><span class="line"><span class="function">INSERT INTO <span class="title">enum_test</span><span class="params">(e)</span> <span class="title">VALUES</span> <span class="params">(<span class="string">'A'</span>)</span>, <span class="params">(<span class="string">'B'</span>)</span>, <span class="params">(<span class="string">'C'</span>)</span></span>;</span><br><span class="line">ERROR <span class="number">1265</span> (<span class="number">01000</span>): Data truncated <span class="keyword">for</span> column <span class="string">'e'</span> at row <span class="number">1</span></span><br><span class="line"></span><br><span class="line">select * from enum_test;</span><br><span class="line">+-------+</span><br><span class="line">| e     |</span><br><span class="line">+-------+</span><br><span class="line">| dog   |</span><br><span class="line">| apple |</span><br><span class="line">| fish  |</span><br><span class="line">+-------+</span><br></pre></td></tr></table></figure><p>看一下实际枚举对应的整数是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">select e + <span class="number">0</span> from enum_test;</span><br><span class="line">+-------+</span><br><span class="line">| e + <span class="number">0</span> |</span><br><span class="line">+-------+</span><br><span class="line">|     <span class="number">3</span> |</span><br><span class="line">|     <span class="number">2</span> |</span><br><span class="line">|     <span class="number">1</span> |</span><br><span class="line">+-------+</span><br></pre></td></tr></table></figure><p><strong>可以看到枚举字段在内部存储是按照整数而不是定义的字符串进行排序的</strong></p><p>插入的是fish(3), apple(2), dog(1), 查询的是dog(1), apple(2), fish(3)<br>如果想要按照自定义的顺序展示， 可以使用FIELD()函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">select e from enum_test order by <span class="title">FIELD</span><span class="params">(e, <span class="string">'dog'</span>, <span class="string">'apple'</span>, <span class="string">'fish'</span>)</span></span>;</span><br><span class="line">+-------+</span><br><span class="line">| e     |</span><br><span class="line">+-------+</span><br><span class="line">| dog   |</span><br><span class="line">| apple |</span><br><span class="line">| fish  |</span><br><span class="line">+-------+</span><br></pre></td></tr></table></figure><p>使用ENUM的建议： 不会做修改的列， 例如性别。<br>ENUM值千万不要使用数值型，会带来混淆。</p><h2 id="日期与时间类型"><a href="#日期与时间类型" class="headerlink" title="日期与时间类型"></a>日期与时间类型</h2><p>MySQL提供两种相似的时间类型： DATETIME和TIMESTAMP</p><ul><li><p>DATETIME</p><p>  范围比TIMESTAMP大， 从1001年到9999年， 精度为秒， 把日期封装成YYYYMMDDHHMMSS的整数中， 与时区无关， 使用8个字节存储。</p></li><li><p>TIMESTAMP</p><p>  保存了1970-01-01 00:00:00 以来的秒数， 和UNIX时间戳相同。 TIMESTAMP只使用四个字节的存储空间， 范围比DATETIME小得多， 只能表示从1970年只2038年的数据， 且TIMESTAMP显示的值是区分时区的。</p><p>  TIMESTAMP也有DATETIME没有的属性， 如果数据在插入时没有指定第一个TIMESTAMP列的值， MySQL会赋予这个列为当前时间。</p></li></ul><p>通常使用TIMESTAMP保存时间。 MySQL现在没有提供合适的数据类型去处理比秒更小粒度的时间， 可以使用BIGINT类型存储微妙级别的时间戳</p><h2 id="位数据类型"><a href="#位数据类型" class="headerlink" title="位数据类型"></a>位数据类型</h2><ul><li><p>BIT(<strong>不推荐使用</strong>)</p><p>  MySQL将BIT当做字符串类型而不是整数类型， 检索BIT(1)时， 结果是一个包含二进制0或1的字符串， 而不是ASCII码的”0”或”1”， 很容易令人迷惑， 举个例子：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CREATE TABLE <span class="title">bit_test</span><span class="params">(a bit(<span class="number">8</span>)</span>)</span>;</span><br><span class="line"><span class="function">INSERT INTO bit_test <span class="title">VALUES</span><span class="params">(B<span class="string">'01000001'</span>)</span></span>;</span><br><span class="line">SELECT a, a+<span class="number">0</span> FROM BIT_TEST;</span><br><span class="line"></span><br><span class="line">+------+------+</span><br><span class="line">| a    | a+<span class="number">0</span>  |</span><br><span class="line">+------+------+</span><br><span class="line">| A    |   <span class="number">65</span> |</span><br><span class="line">+------+------+</span><br></pre></td></tr></table></figure><p>当存储’01000001’字符串时， 检索出的结果为ASCII码为65的字符”A”， 在数字上下文的检索中， 得到的是数字65。</p><ul><li>SET<br>  唯一的缺点是修改表的成本比较高， 当保存很多的true/false时可以考虑使用SET， 这里看一下SET的用法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">CREATE TABLE <span class="title">acl</span><span class="params">(perms SET(<span class="string">'CAN_READ'</span>, <span class="string">'CAN_WRITE'</span>, <span class="string">'CAN_DELETE'</span>)</span> NOT NULL)</span>;</span><br><span class="line"><span class="function">INSERT INTO <span class="title">acl</span><span class="params">(perms)</span> <span class="title">VALUES</span><span class="params">(<span class="string">'CAN_READ,CAN_DELETE'</span>)</span></span>;</span><br><span class="line"><span class="function">SELECT perms FROM acl WHERE <span class="title">FIND_IN_SET</span><span class="params">(<span class="string">'CAN_READ'</span>, perms)</span></span>;</span><br><span class="line"></span><br><span class="line">+---------------------+</span><br><span class="line">| perms               |</span><br><span class="line">+---------------------+</span><br><span class="line">| CAN_READ,CAN_DELETE |</span><br><span class="line">+---------------------+</span><br><span class="line"></span><br><span class="line"><span class="function">SELECT perms FROM acl WHERE <span class="title">FIND_IN_SET</span><span class="params">(<span class="string">'CAN_DELETE'</span>, perms)</span></span>;</span><br><span class="line"></span><br><span class="line">+---------------------+</span><br><span class="line">| perms               |</span><br><span class="line">+---------------------+</span><br><span class="line">| CAN_READ,CAN_DELETE |</span><br><span class="line">+---------------------+</span><br></pre></td></tr></table></figure><h2 id="如何选择合适的类型作为标识列"><a href="#如何选择合适的类型作为标识列" class="headerlink" title="如何选择合适的类型作为标识列"></a>如何选择合适的类型作为标识列</h2><ul><li><p>整数类型</p><p>  标识列的不二选择， 通常作为主键， 因为可以使用AUTO_INCREMENT。</p></li><li><p>ENUM与SET</p><p>  不要使用ENUM,SET作为标识列， ENUM与SET适合存储固定信息，例如有序的状态、人的性别。</p></li><li><p>字符串类型</p><p>  避免使用字符串作为标识列， 原因在于很消耗空间，并且比数字类型慢。</p></li></ul><h1 id="范式与反范式"><a href="#范式与反范式" class="headerlink" title="范式与反范式"></a>范式与反范式</h1><p>三范式的定义分别是：</p><ul><li><p>一范式</p><p>  指数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值</p></li><li><p>二范式</p><p>  表中的每个实例（每行）都可以被唯一区分，为了被区分，通常为表加上一列以存储每个实例的唯一标示（<strong>主键</strong>）</p></li><li><p>三范式</p><p>  数据库表不包含已在其他表的非主关键字信息，即包含已在其他数据库表中的主关键字信息（<strong>外键</strong>）</p></li></ul><p>举例子来说， 下面是一张 雇员-部门-上级表：</p><table><thead><tr><th>EMPLOYEE</th><th>DEPARTMENT</th><th>HEAD</th></tr></thead><tbody><tr><td>Jones</td><td>Accounting</td><td>Jones</td></tr><tr><td>Simth</td><td>Engineering</td><td>Simth</td></tr><tr><td>Brown</td><td>Accounting</td><td>Jones</td></tr><tr><td>Green</td><td>Engineering</td><td>Simth</td></tr></tbody></table><p>这种表满足第一范式， 每列数据都是单独的值， 但是不满足第二范式， 不能唯一的标识一列， 加入Brown接替Accounting部门， 将同时修改两行数据， 此外如果删除了Accounting部门的所有雇员， 就失去了关于这个部门的记录。为了满足第二范式， 我们将表拆分成 <strong>雇员-部门</strong>，<strong>部门-上级</strong> 这种关系。</p><p>雇员-部门</p><table><thead><tr><th>EMPLOYEE_NAME</th><th>DEPARTMENT</th></tr></thead><tbody><tr><td>Jones</td><td>Accounting</td></tr><tr><td>Simth</td><td>Engineering</td></tr><tr><td>Brown</td><td>Accounting</td></tr><tr><td>Green</td><td>Engineering</td></tr></tbody></table><p>部门-上级</p><table><thead><tr><th>DEPARTMENT</th><th>HEAD</th></tr></thead><tbody><tr><td>Accounting</td><td>Jones</td></tr><tr><td>Engineering</td><td>Simth</td></tr></tbody></table><p>这样就算修改任意部门的领导也主需要修改部门-上级即可， 对部门雇员的数据是没有影响的， 哪怕Accounting部门没有雇员， 对这个部门也是没有影响的。</p><h2 id="范式的优缺点"><a href="#范式的优缺点" class="headerlink" title="范式的优缺点"></a>范式的优缺点</h2><p>优点：</p><ul><li>范式的更新操作通常比反范式更快。</li><li>符合范式， 很少或者没有重复数据，因此修改数据也会少很多。</li><li>范式化的表通常更小。</li><li>很少有多余的数据意味着检索数据时更少执行DISTINCT和GROUP BY操作。比如DEPARTMENT是一张单独的表， 就不需要对雇员表进行GROUP BY department操作。</li></ul><p>缺点：</p><ul><li>查询数据时需要进行多张表的关联。</li></ul><h2 id="反范式的优缺点"><a href="#反范式的优缺点" class="headerlink" title="反范式的优缺点"></a>反范式的优缺点</h2><p>优点:</p><ul><li>所有数据都在一张表， 可以很好的避免关联。</li></ul><p>缺点：</p><ul><li>所有数据都在一张表， 带来的问题就是字段过多， 修改成本高。</li></ul><h1 id="缓存表与汇总表-提升查询效率"><a href="#缓存表与汇总表-提升查询效率" class="headerlink" title="缓存表与汇总表-提升查询效率"></a>缓存表与汇总表-提升查询效率</h1><ul><li><p>缓存表<br>  存储从从其他查询速度较慢的表的数据</p></li><li><p>汇总表<br>  保存的是分组后的数据</p></li></ul><p>其中有一个计数器的策略很有意思， 为了避免对某行数据并发写阻塞全局， 将计数放到多行进行， 最终统计多行的数据总和即可。</p><h1 id="提升ALTER-TABLE效率"><a href="#提升ALTER-TABLE效率" class="headerlink" title="提升ALTER TABLE效率"></a>提升ALTER TABLE效率</h1><p>对大表来说， ALTER TABLE可能需要几小时甚至数天才能完成操作， 因为ALTER操作涉及到锁表和重建表。<br>常见的ALTER TABLE有两种操作：</p><ol><li>先在不提供服务的机器上执行ALTER TABLE操作，然后进行主库切换；</li><li>创建一张与源表结构一致的表， 然后通过重命名与删表操作交换两张表。</li></ol><p>其中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE table_name MODIFY COLUMN column_name ....;</span><br></pre></td></tr></table></figure><p>执行过程是先读取表中所有数据， 再将列替换插入到新表， 所以<strong>MODIFY COLUMN</strong>操作是相当慢的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE table_name ALTER COLUMN column_name ....;</span><br></pre></td></tr></table></figure><p>这条语句会直接修改.frm文件， 而.frm文件中存的是表的默认值， 所以这种操作是非常快的。一句话，修改表的默认值应该使用ALTER COLUMN 操作<br>为高效地载入数据到MyISAM， 一个技巧是先禁用索引、载入数据、重启索引， 唯一的问题是这个方法对唯一索引是无效的。<br>在InnoDB也有类似的操作， 先删除所有的非唯一索引， 增加新的列， 然后再创建新的索引。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL架构与历史</title>
      <link href="/2020/02/08/mysql/note-1-mysql-history/"/>
      <url>/2020/02/08/mysql/note-1-mysql-history/</url>
      
        <content type="html"><![CDATA[<p>常说的ACID与MySQL的隔离级别到底是怎么回事？</p><a id="more"></a><h1 id="MySQL的主要特征"><a href="#MySQL的主要特征" class="headerlink" title="MySQL的主要特征"></a>MySQL的主要特征</h1><p>最主要的特征莫过于<strong>存储引擎</strong>， 存储引擎将查询处理、其他系统任务和数据的读写相分离；</p><h1 id="MySQL架构-三层结构"><a href="#MySQL架构-三层结构" class="headerlink" title="MySQL架构(三层结构)"></a>MySQL架构(三层结构)</h1><p>既然MySQL这么厉害， 那到底什么是存储引擎， 要搞明白存储引擎， 我们先看下MySQL的架构， 以及存储引擎在MySQL中所处什么位置，到底做了什么。</p><p> MySQL按结构划分分为三层：</p><pre><code>第一层：面向客户端的连接层;第二层：大多数MySQL核心功能所在的中间层，具有查询解析、优化、缓存、内置函数等功能;第三层：存储引擎，负责数据的存储与提取</code></pre><p>如图所示：</p><p><img src="/2020/02/08/mysql/note-1-mysql-history/mysql%E6%9E%B6%E6%9E%84.jpg" alt="MySQL架构"></p><p>由这个架构可以看到， 存储引擎相当于是数据与文件系统的接口（桥梁），中间层将SQL语句解析后判断需要执行什么操作，调用存储引擎的接口， 通过存储引擎将数据存储到文件系统中或将数据从文件系统中取出。</p><h1 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h1><p> 当面临多个读写操作是， MySQL是如何做读写控制？</p><blockquote><p>   读操作共享数据单元，加读锁（共享锁）， 读锁不会阻塞其他的读操作， 但是会阻塞写操作；写操作时加<strong>排他锁</strong>， 会阻塞其他的读锁和写锁。</p></blockquote><p> 锁的粒度如何？ 表锁、行锁又有什么区别？</p><blockquote><p> 表锁是开销最小的策略， 当写数据时， 会先获得写锁，同时会阻塞其他用户对改表的所有读写操作；当没有人获得写锁时， 多个读锁间不会相互阻塞，此时可以有多个事务进行读操作。<br>行锁最大程度支持并发， 但也带来了最大的开销。只在引擎层做了实现， 没有在服务层实现</p></blockquote><h1 id="事务特性（ACID"><a href="#事务特性（ACID" class="headerlink" title="事务特性（ACID)"></a>事务特性（ACID)</h1><p>以转账为例:</p><pre><code>开启事务:    查询账户a余额 = 500;    从a账户-200， a账户余额= 300;    给b账户+200；提交事务;</code></pre><p>转账过程中的任何一步出错， 之前的所有步骤都应该回退， 否则可能a的账户中少了300， 但b账户未到账</p><p>其中ACID 的含义如下：</p><ul><li><p><strong>Atomicity</strong>（原子性）：一个事务必须视为不可分割的最小单元， 要么全部成功， 要么全部失败， 以上面转账为例， 不能缺省中间的任何一个步骤， 否则全部失败。</p></li><li><p><strong>Consistency</strong>（一致性）： 数据库从一个一致性的状态转换到另一个一致性的状态， 事务未提交之前， a、b账户的金额都是不会变的。</p></li><li><p><strong>Isolation</strong>（隔离性）：一个事务的修改在提交之前， 对其他事务是不可见的。例如在转账的事务未提交之前， 另一个转账事务开始时，看到a账户的金额的金额应该是500才对。</p></li><li><p><strong>Durability</strong>（隔离性）：一旦事务提交，其所作的修改会永久保存到数据库中。</p></li></ul><h1 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h1><p>MySQL定义了四种隔离级别，但是这四种隔离级别到底是怎么来的？ 先看下官方的定义</p><ul><li><p><strong>READ UNCOMMITED</strong> （未提交读）: MySQL中最低的隔离级别， 即使事务中的修改没有提交， 也可以被其他事务看见。 事务可以读取未提交的数据， 也被称之为脏读（Dirty Read）, 在实际应用中很少使用。</p></li><li><p><strong>READ COMMITED</strong> (提交读)： 大多数数据库的默认隔离级别， 但MySQL不是。一个事务只能看到已提交的事务所做的修改， 反过来说， 一个事务在提交前， 所做的任何修改对其他事务都是不可见的。因为这种隔离级别可能导致<strong>同样的查询会读到两个不一样的结果</strong>， 称之为不可重复读（nonrepeatable read）；</p></li><li><p><strong>REPEATABLE READ</strong>（可重复读）：MySQL中InnoDB引擎的默认隔离级别，该级别解决了不可重复读的问题（这里有个疑问是如何做到的？）， 但是解决不了幻读（Phantom Read），所谓幻读， 事务在进行范围查询时， 另一个事务在该范围内插入了新纪录， 实际应用中InnoDB 通过间隙锁（范围锁定）来解决幻读问题；</p></li><li><p><strong>SERIALIZABLE</strong>（可串行化）：强制事务串行执行， 可以避免幻读问题，为读取的每一行数据都加锁， 但是会导致大量的超时和锁竞争， 很少使用。</p></li></ul><p>其实隔离级别的实现跟锁是密不可分的， 举个例子先看下没锁会导致什么情况</p><p><img src="/2020/02/08/mysql/note-1-mysql-history/%E6%97%A0%E9%94%81.jpeg" alt="无锁"></p><ul><li><p>a.旺财和小强同时对一个账号进行操作，都读取到A=100， 旺财对账号+20， 余额为120； 小强也对余额100处理， 对将账号减去50，余额等于50， 覆盖了旺财的结果， 可以看出无锁的情况会造成数据丢失。</p></li><li><p>b.此后旺财和小强约定对写操作加锁（排它锁, X锁）， 只能有一方对数据进行写， 解决了两个人同时修改数据导致的问题， 但是这样带来了一个新的问题（<strong>脏数据</strong>），如下图所示：</p></li></ul><p><img src="/2020/02/08/mysql/note-1-mysql-history/%E8%84%8F%E6%95%B0%E6%8D%AE.jpeg" alt="脏数据"></p><p>当旺财进行写操作时， 账号余额变成了120， 此时小强对余额进行读取拿到结果120， 但是旺财的系统出现问题进行了回滚， 余额又回滚到了100， 此时小强就读到了脏数据。 <em>脏数据出现的原因是事务中没有提交的数据对其他事务可见导致的</em>。</p><ul><li>c.针对脏数据的问题， 旺财和小强约定在读数据的时候加读锁（共享锁, S锁）， 共享锁不会阻塞其他读操作，写操作时会阻塞其他的读、写操作；加了X锁，就不能获取S锁，加了S锁就不能获取X锁， 但加了S锁还可以获取S锁。</li></ul><p><img src="/2020/02/08/mysql/note-1-mysql-history/%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB.jpeg" alt="不可重复读"></p><p>旺财分别对A、B加上S锁，读取完毕后释放S锁 ， 计算C=A+B，；小强获取B的X锁， 执行B=B-30；释放B的X锁； 此时旺财再执行（在一个事务中）刚才的查询发现前后两次C计算的结果不一样， 导致了<strong>不可重复读的问题</strong>。</p><ul><li>d.旺财和小强约定， S锁不能读完数据就立马释放， 需要持续到事务提交； 再面对上面这种情况时，B获取X锁就会失败。</li></ul><p><img src="/2020/02/08/mysql/note-1-mysql-history/%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB.jpeg" alt="可重复读"></p><p>当旺财再计算C=A+B时， 先对A、B加S锁， 读取完毕S锁也不会释放；此时小强再获取X锁就会失败，这样就能够避免重复读取数据时出现数据不一致的情况了， 这里就对应了<strong>可重复读</strong>。</p><ul><li>e. 有一次旺财对一批学生进行了批量处理， 选取了age=18的数据， 处理完后发现有一行竟然是没处理的数据, 查了半天才发现， 在旺财查询修改数据期间，小强也新增了一条数据，正是新增的这条数据让旺财产生了幻觉。 为了解决这种问题， 旺财和小强决定串行执行， 这里就对应了<strong>串行化</strong>。</li></ul><h1 id="死锁问题"><a href="#死锁问题" class="headerlink" title="死锁问题"></a>死锁问题</h1><p>两个或多个事务对同一资源的抢占，并请求锁定对方的资源；</p><pre><code>事务1：    START TRANSACTION;    UPDATE StockPrice SET close = 45.50 WHERE stock_id = 4 and date = &apos;2020-02-08&apos;;    UPDATE StockPrice SET close = 45.50 WHERE stock_id = 3 and date = &apos;2020-02-09&apos;;    COMMIT;事务2：    START TRANSACTION;    UPDATE StockPrice SET close = 45.50 WHERE stock_id = 3 and date = &apos;2020-02-09&apos;;    UPDATE StockPrice SET close = 45.50 WHERE stock_id = 4 and date = &apos;2020-02-08&apos;;    COMMIT;</code></pre><p>如果两个事务通知执行第一条UPDATE语句，更新了该行数据，同时对改行数据进行锁定； </p><p>当执行到第二条UPDATE语句时，事务1需要获得stock_id = 3的写锁， 事务2需要stock_id = 4的写锁， 然而这两个写锁都被对方占有，两个事务都等对方释放锁， 此时就造成了死锁。</p><p>解决死锁的方法：<br>    * 超时解除;<br>    * 最少行级别的排他锁（写锁）进行回滚。</p><h1 id="事务日志"><a href="#事务日志" class="headerlink" title="事务日志"></a>事务日志</h1><p>通过事务日志， 存储引擎先将数据在内存中进行修改， 然后再持久化到硬盘中的事务日志， 不用每次都写进硬盘； 就算系统奔溃， 在重启时也会恢复修改的数据。<br>两次写操作， 修改数据需要写两次硬盘； </p><h1 id="混合事务与显示锁定"><a href="#混合事务与显示锁定" class="headerlink" title="混合事务与显示锁定"></a>混合事务与显示锁定</h1><p>MySQL采用的是自动提交模式，默认每个查询都会开启事务； 如果关闭自动提交， 需要显式commit或者rollback结束一个事务， 此间的所有查询都在一个事务中。</p><p>不推荐在事务中混合事务引擎和非事务引擎， 当数据需要回滚时， 非事务引擎数据无法回滚， 会造成数据的非一致性</p><p>InnoDB采用的是两阶段锁（疑问： 什么是两阶段锁， 在哪两阶段）：事务在执行过程中随时都可以锁定， 只有在commit或者rollback后锁才会释放，其中 select … for update 就是显式锁定</p><p>此外不要使用AUTOCOMMIT 以及LOCK TABLES ， 性能太差</p><h1 id="MVCC-多版本控制（MVCC算法）"><a href="#MVCC-多版本控制（MVCC算法）" class="headerlink" title="MVCC 多版本控制（MVCC算法）"></a>MVCC 多版本控制（MVCC算法）</h1><p>MVCC是行级锁的一个变种， 相比于行级锁性能更高一些， 避免了很多加锁操作， 开销更低；<br>实现原理：为每行数据赋予一个版本号， 每次修改数据都会版本号+1， 读取数据时开启事务，给当前事务一个版本号a， 查询数据库中版本号&lt;=当前版本号a的数据， 就算此时新增了数据，版本号为b， 此时b&gt;a， 在之前的查询事务中继续查询， 得到的数据是没有发生变化的）。 以REPEATABLE READ为例：</p><pre><code>SELECT :    a. InnoDB 会查找当前事务版本号之前（小于等于当前版本号的）的数据行；    b. 行的删除版本号要么未定义， 要么大于当前版本号。这样可以确保事务读取到的行在事务开始前未被删除INSERT: 为新插入的每一行保存当前版本号作为行版本号DELETE： 为删除的每一行保存当前版本号作为行版本号UPDATE:  先新增一行数据，保存当前事务版本号作为行版本号， 再将当前版本行作为之前数据的行删除标识（先增后删）</code></pre><p>MVCC只在REPEATABLE READ 和 READ COMMITED下工作， READ UNCOMMITED总是读取最新的数据行， SERIALIZABLE对每行数据都加锁</p><h1 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h1><p>InnoDB, MyisAM为官方引擎， 第三方还有XtraDB等</p><p>InnoDB 特性：</p><ul><li>采用MVCC支持高并发， 实现了四个标准的隔离级别， 默认REPEATABLE READ, 通过间隙锁防止幻读出现</li><li>InnoDB基于聚簇索引， 使得主键查询的性能很高</li><li>InnoDB 内部做了优化， 从磁盘读取数据是采用可预测性读， 读操作的自适应哈希索引， 写操作的插入缓存区</li></ul><p>MyISAM特性：全文索引， 压缩， 空间函数(GIS), 不足： 不支持事务和行级锁， 崩溃后无法恢复</p><ul><li><p>加锁与并发， 对整张表加锁，对需要读取的所有表加共享锁， 写入时加排他锁，  这里引入了一个概念叫做并发插入（读操作的同时， 往表中写数据）</p></li><li><p>修复： 这里的修复和崩溃后恢复不是一个概念，执行CHECK TABLE table_name 后有错误时再REPAIR TABLE table_name</p></li><li><p>索引特性：支持全文索引， 对于BLOB, TEXT等长字段， 也可以基于前500个字符创建索引； 如果设置了延迟更新索引建DELAY_KEY_WRITE， 每次修改完成后不会立即将修改的索引写入磁盘，而是先写入内存的缓存区</p></li><li><p>可压缩：对于不再修改的内容可以进行压缩</p></li></ul><h1 id="如何选择合适的引擎-尽量不要使用混合引擎"><a href="#如何选择合适的引擎-尽量不要使用混合引擎" class="headerlink" title="如何选择合适的引擎(尽量不要使用混合引擎)"></a>如何选择合适的引擎(尽量不要使用混合引擎)</h1><p>事务支持：InnoDB, XtraDB, 不需要事务支持时MyISAM<br>备份：在线备份InnoDB 首选， 定期关闭服务器备份无论哪种引擎都可以<br>崩溃恢复： InnoDB 首选， MyISAM损坏概率更改， 切恢复速度更慢， 这都是相比于InnoDB来说的<br>特性： MyISAM的GIS， 支持地理空间搜索</p><h1 id="转换引擎：-常见的三种方法"><a href="#转换引擎：-常见的三种方法" class="headerlink" title="转换引擎： 常见的三种方法"></a>转换引擎： 常见的三种方法</h1><p><strong>ALTER TABLE</strong>:   ALTER TABLE table_name ENGINE = InnoDB;<br>    该方法适用于任何引擎， 但是执行时间很长， 原理是将原表复制到一张新表中，复制期间会对原表加锁， 而且会丢失原引擎的特性， 例如InnoDB转换到MyISAM再转回InnoDB时会丢失外键索引。</p><p><strong>导出与导入</strong>：利用MySQLdump 导出到文件， 修改MySQL文件中create table  的引擎选项， 同时修改表名。</p><p><strong>创建与查询：</strong>结合第一种方法的高效（相比于导出）和第二种安全（相比于1）特性。</p><pre><code>1.先创建一张空表       CREATE TEBLE innodb_table Like myisam_table;2.再修改引擎          ALTER TABLE innodb_table ENGINE = InnoDB;3.最后复制数据         INSERT INTO innodb_table SELECT * FROM myisam_table;</code></pre><p> 参考：  <a href="https://mp.weixin.qq.com/s/bM_g6Z0K93DNFycvfJIbwQ" target="_blank" rel="noopener">码农翻身</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 24. Swap Nodes in Pairs</title>
      <link href="/2020/01/15/leetcode/linkedlist/SwapPairs/"/>
      <url>/2020/01/15/leetcode/linkedlist/SwapPairs/</url>
      
        <content type="html"><![CDATA[<p>Given a linked list, swap every two adjacent nodes and return its head.</p><p>You may not modify the values in the list’s nodes, only nodes itself may be changed.</p><a id="more"></a><h1 id="Example"><a href="#Example" class="headerlink" title="Example:"></a>Example:</h1><blockquote><p>Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3.</p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>题意为两两交换链表中的元素，<strong>不能改变链表的值</strong>， 而是要交换链表结点；</p><p>具体思路：</p><blockquote><p>cur为待交换结点的前一个结点，用于链接交换后的结点;<br>当两个结点交换完毕后， cur指向下一次待交换两个结点的前一个结点;</p></blockquote><p>示意图如下：</p><p><img src="/2020/01/15/leetcode/linkedlist/SwapPairs/demo.jpg" alt="demo"></p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode dummyHead = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        dummyHead.next = head;</span><br><span class="line">        ListNode cur = dummyHead;</span><br><span class="line">        <span class="keyword">while</span> (cur.next != <span class="keyword">null</span> &amp;&amp; cur.next.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ListNode first = cur.next;</span><br><span class="line">            ListNode second = first.next;</span><br><span class="line">            first.next = second.next;</span><br><span class="line">            second.next = first;</span><br><span class="line">            cur.next = second;</span><br><span class="line">            cur = first;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每周一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> linkedlist </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代理模式</title>
      <link href="/2019/12/21/design-pattern/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/12/21/design-pattern/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>在国内时访问谷歌， 就是标准的代理模式。 通过VPN进行科学上网， VPN就是一个代理</p><a id="more"></a><h1 id="什么是代理模式"><a href="#什么是代理模式" class="headerlink" title="什么是代理模式"></a>什么是代理模式</h1><p>给某一个对象提供一个代理，并由代理对象来<strong>控制</strong>对真实对象的访问。</p><p>代理模式场景描述：　　　　</p><ul><li>当我们想要隐藏某个类时，可以为其提供代理类；</li><li>当一个类需要对不同的调用者提供不同的调用权限时，可以使用代理类来实现（代理类不一定只有一个，我们可以建立多个代理类来实现，也可以在一个代理类中进行权限判断来进行不同权限的功能调用）；　　　　</li><li>当我们要扩展某个类的某个功能时，可以使用代理模式，在代理类中进行简单扩展（只针对简单扩展，可在引用委托类的语句之前与之后进行）。</li></ul><h1 id="代理模式组成"><a href="#代理模式组成" class="headerlink" title="代理模式组成"></a>代理模式组成</h1><p><strong>抽象对象</strong>: Subject<br><strong>目标对象</strong>: RealSubject, 委托类<br><strong>代理对象</strong>: ProxySubject, 代理类</p><h1 id="代理模式UML"><a href="#代理模式UML" class="headerlink" title="代理模式UML"></a>代理模式UML</h1><p><img src="/2019/12/21/design-pattern/代理模式/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.png" alt="代理模式"></p><h1 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h1><p>举个例子， 常见的对用户信息的查询、更新操作<br>首先定义UserService(Subject)接口， 接口中有两个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着定义UserServiceImpl(RealSubject), 实现UserService接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"select by name!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"update by id!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将通过代理对访问 UserServiceImpl 时进行控制，在调用 select 和 update 之前打印日志</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceProxy</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> UserService realSubject;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserServiceProxy</span><span class="params">(UserService realSubject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.realSubject = realSubject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        befor();</span><br><span class="line">        realSubject.select();</span><br><span class="line">        after();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        befor();</span><br><span class="line">        realSubject.update();</span><br><span class="line">        after();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(String.format(<span class="string">"log start time [%s] "</span>, <span class="keyword">new</span> Date()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(String.format(<span class="string">"log end time [%s] "</span>, <span class="keyword">new</span> Date()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端发起调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        UserService proxyUserService = <span class="keyword">new</span> UserServiceProxy(<span class="keyword">new</span> UserServiceImpl());</span><br><span class="line">        </span><br><span class="line">        proxyUserService.select();</span><br><span class="line">        </span><br><span class="line">        proxyUserService.update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><pre><code>log start time [Mon Dec 16 18:21:29 CST 2019] select by name!log end time [Mon Dec 16 18:21:29 CST 2019] log start time [Mon Dec 16 18:21:29 CST 2019] update by id!log end time [Mon Dec 16 18:21:29 CST 2019] </code></pre><p>通过代理对象UserServiceProxy， 我们对UserServiceImpl进行间接访问， 并且对目标对象的方法执行前后进行了日志打印，而且对代码没有侵入性。</p><h1 id="代理模式的特点"><a href="#代理模式的特点" class="headerlink" title="代理模式的特点"></a>代理模式的特点</h1><ul><li>代理类与委托类实现同一接口　　　　</li><li>在委托类中实现功能，在代理类的方法中中引用委托类的同名方法</li><li>外部类调用委托类某个方法时，直接以接口指向代理类的实例，这正是代理的意义所在：控制。</li></ul><h1 id="存在什么问题"><a href="#存在什么问题" class="headerlink" title="存在什么问题"></a>存在什么问题</h1><p>刚才例子中我们使用的是<strong>静态代理</strong>，静态代理已经完美解决了打印日志的问题。但是，如果我们需要对代理类100个方法的都打印方法执行前和执行后，同样的代码至少需要重复100次。 如果再受不同的委托，实现100个代理类，同样的代码也至少需要重复多次。因此，静态代理至少有以下两个局限性问题：</p><ul><li>如果同时代理多个类，依然会导致类无限制扩展</li><li>如果类中有多个方法，同样的逻辑需要反复实现</li></ul><p>这个时候就需要<strong>动态代理</strong>了，后续的文章会讲到。</p><h1 id="代理模式与装饰者模式、适配器模式的区别"><a href="#代理模式与装饰者模式、适配器模式的区别" class="headerlink" title="代理模式与装饰者模式、适配器模式的区别"></a>代理模式与装饰者模式、适配器模式的区别</h1><blockquote><p>装饰者模式相比于代理模式， 不同点在于装饰者为对象增加行为， 代理模式控制对象的访问，让用户通过代理来访问RealSubject， 而不是直接访问。</p></blockquote><blockquote><p>适配器模式会改变对象适配的接口， 而代理模式实现的是相同的接口</p></blockquote><h1 id="代理模式的应用"><a href="#代理模式的应用" class="headerlink" title="代理模式的应用"></a>代理模式的应用</h1><ul><li>日志打印 （如文中举的例子）</li><li>事务提交或回退（Web开发中很常见）</li><li>权限管理</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 结构型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 23. Merge k Sorted Lists</title>
      <link href="/2019/12/18/leetcode/linkedlist/MergeKLists/"/>
      <url>/2019/12/18/leetcode/linkedlist/MergeKLists/</url>
      
        <content type="html"><![CDATA[<p>Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.</p><a id="more"></a><h1 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h1><pre><code>Input:[  1-&gt;4-&gt;5,  1-&gt;3-&gt;4,  2-&gt;6]Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</code></pre><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>LeetCode hard难度题， 看到这道题我的第一思路是链表两两比较生成新的链表， 再将新的链表与剩余的链表进行比较生成新的链表，这个思路也是可行的， 但是效率不高， 具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lists.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(lists.length == <span class="number">1</span>) <span class="keyword">return</span> lists[<span class="number">0</span>];</span><br><span class="line">    </span><br><span class="line">    ListNode newList = mergeTwoLists(lists[<span class="number">0</span>], lists[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;lists.length; i++) &#123;</span><br><span class="line">       newList =  mergeTwoLists(newList, lists[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mergeTwoLists(ListNode l1, ListNode l2); 参见<a href="/2019/12/17/leetcode/linkedlist/MergeTwoLists">合并两个有序联链表</a></p><p>算法复杂度 k * n， ac结果如下：<br><img src="/2019/12/18/leetcode/linkedlist/MergeKLists/n-1%E6%AC%A1%E6%AF%94%E8%BE%83.JPG" alt="n-1次比较"></p><h1 id="新的思路"><a href="#新的思路" class="headerlink" title="新的思路"></a>新的思路</h1><p>利用优先级队列的排序功能， 每次队列中的结点都是有序的</p><ul><li>新建一个队列， 依次存入链表数组lists中所有链表的头结点；</li><li>创建虚拟头结点dummyHead；</li><li>队列弹出元素（始终是队列中最小的元素）, 链接到现有的链表上；</li><li>判断当前元素的下一个结点是否为空， 不为空插入到优先级队列中（此时会继续调整队列顺序）；</li><li>重复之前的步骤， 直到队列为空。</li></ul><p>示意图如下：<br><img src="/2019/12/18/leetcode/linkedlist/MergeKLists/demo.jpg" alt="示例"></p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (lists == <span class="keyword">null</span> || lists.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建优先级队列</span></span><br><span class="line">        PriorityQueue&lt;ListNode&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;ListNode&gt;(lists.length, <span class="keyword">new</span> Comparator&lt;ListNode&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(ListNode o1, ListNode o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(o1.val  &lt; o2.val) &#123;</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span>  <span class="keyword">if</span>(o1.val  &gt; o2.val)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 所有链表的头结点插入优先级队列</span></span><br><span class="line">        <span class="keyword">for</span>(ListNode node : lists) &#123;</span><br><span class="line">            <span class="keyword">if</span>(node != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 构建新的链表</span></span><br><span class="line">        ListNode dummyHead = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        ListNode tail = dummyHead;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            tail.next = queue.poll();</span><br><span class="line">            tail = tail.next;</span><br><span class="line">            <span class="keyword">if</span>(tail.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.add(tail.next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看下优化后的方法的ac结果， 相比之前快了很多：<br><img src="/2019/12/18/leetcode/linkedlist/MergeKLists/better.jpg" alt="better"></p>]]></content>
      
      
      <categories>
          
          <category> 每周一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> linkedlist </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 21. Merge Two Sorted Lists</title>
      <link href="/2019/12/17/leetcode/linkedlist/MergeTwoLists/"/>
      <url>/2019/12/17/leetcode/linkedlist/MergeTwoLists/</url>
      
        <content type="html"><![CDATA[<p>Merge two sorted linked lists and return it as a new list.The new list should be made by splicing together the nodes of the first two lists.</p><a id="more"></a><h1 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h1><blockquote><p>Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br>Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>LeetCode简单难度题， 合并两个<strong>有序</strong>链表，因为两个链表都是有序的就好办了。</p><ul><li>循环遍历两个链表，进行大小比较；</li><li>利用临时结点， 将每次较小的结点链接在临时结点之后；</li><li>当其中一个链表遍历结束后， 将另一个结点链接到临时结点之后。</li></ul><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        ListNode dummyHead = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        ListNode curr = dummyHead;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">if</span>(l1.val &lt;= l2.val) &#123;</span><br><span class="line">                curr.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                curr.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            curr = curr.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(l1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            curr.next = l1;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            curr.next = l2;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每周一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> linkedlist </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 19. Remove Nth From End of List</title>
      <link href="/2019/12/09/leetcode/linkedlist/RemoveNthFromEnd/"/>
      <url>/2019/12/09/leetcode/linkedlist/RemoveNthFromEnd/</url>
      
        <content type="html"><![CDATA[<p>Given a linked list, remove the n-th node from the end of list and return its head.</p><a id="more"></a><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><blockquote><p>Given linked list:<br><strong>1-&gt;2-&gt;3-&gt;4-&gt;5</strong> ,  and n = 2.<br>After removing the second node from the end, the linked list becomes<br><strong>1-&gt;2-&gt;3-&gt;5</strong>.</p></blockquote><p>Note:</p><p>Given n will always be valid.</p><p><strong>Could you do this in one pass?</strong></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>本题重点在于<strong>一次遍历</strong>解决问题， 原本的思路是：</p><ul><li>先遍历算出链表的长度<strong>length</strong></li><li>再从head结点移动到第<strong>length-n-1</strong>个结点</li><li>删除第<strong>length-n-1</strong>结点的下一个结点来解决</li></ul><p>但是这样是不符合题意的， 因为遍历了两遍链表。</p><p>正确的解题思路，利用三指针（slow, fast, pre）来解决问题：</p><ul><li>fast指针先遍历n个节点</li><li>定义pre结点，位于slow结点之前， slow结点此时指向head结点</li><li>pre, slow, fast结点同时移动， 当fast结点为null时， slow结点位于待删除结点</li><li>pre结点指向slow结点的下一个结点，即删除倒数第n个节点</li></ul><h2 id="示意图"><a href="#示意图" class="headerlink" title="示意图"></a>示意图</h2><p><img src="/2019/12/09/leetcode/linkedlist/RemoveNthFromEnd/demo.jpg" alt="示意图"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        ListNode first = head;</span><br><span class="line">        ListNode dummyHead = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        dummyHead.next = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (n-- &gt; <span class="number">0</span> &amp;&amp; first != <span class="keyword">null</span>) &#123;</span><br><span class="line">            first = first.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode pre = dummyHead;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (first != <span class="keyword">null</span>) &#123;</span><br><span class="line">            pre = slow;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            first = first.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pre.next = slow.next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每周一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> linkedlist </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>装饰者模式</title>
      <link href="/2019/12/07/design-pattern/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/12/07/design-pattern/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>咖啡店中的不同咖啡， 加奶泡、加糖其实就是一种装饰者模式。</p><a id="more"></a><h1 id="什么是装饰者模式"><a href="#什么是装饰者模式" class="headerlink" title="什么是装饰者模式"></a>什么是装饰者模式</h1><p>动态地给一个对象添加一些额外的职责。 使用装饰者模式的动机在于想要给一个对象动态地增加新的职责， 并且不修改原有的类。 举个例子就是咖啡加奶泡， 并不改变咖啡原有的特性。</p><h1 id="装饰者模式组成"><a href="#装饰者模式组成" class="headerlink" title="装饰者模式组成"></a>装饰者模式组成</h1><p><strong>Component</strong>: 组件类，装饰者和被装饰者共同的父类，用来定义基本行为。 是一个接口或者抽象类。</p><p><strong>ConcreteComponent</strong>: 具体组件，即被装饰者。</p><p><strong>Decorator</strong>: 继承自Component。</p><p><strong>ConcreteDecorator</strong>: 具体装饰者， 用于扩展ConcreteComponent。</p><h1 id="装饰者模式UML"><a href="#装饰者模式UML" class="headerlink" title="装饰者模式UML"></a>装饰者模式UML</h1><p><img src="/2019/12/07/design-pattern/装饰者模式/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F-UML.jpg" alt="UML"><br>注：装饰者和被装饰者对象有相同的超类型，因为装饰者和被装饰者必须是一样的类型，<strong><em>这里利用继承是为了达到类型匹配，而不是利用继承获得行为</em></strong>。</p><h1 id="具体例子"><a href="#具体例子" class="headerlink" title="具体例子"></a>具体例子</h1><p>以星巴克为例子， 提供的菜单中有咖啡（<strong>ConcreteComponentA</strong>）、星冰乐（<strong>ConcreteComponentB</strong>）等饮品， 每个人针对每种咖啡又有自己的口味喜好， 比如有的人喜欢加奶泡（<strong>ConcreteDecoratorA</strong>），有的人喜欢要全糖(<strong>ConcreteDecoratorB</strong>)， 这里面就对应上了装饰者模式。</p><p>首先定义装饰者与被装饰者的超类，Beverage代表饮料，是一个抽象类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Beverage</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">getCost</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"饮品"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来定义具体的被装饰者Coffee，继承自组件类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Coffee</span> <span class="keyword">extends</span> <span class="title">Beverage</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getCost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">24</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"一份咖啡"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来定义装饰者，Sugar与被装饰者同样继承自组件类，定义为抽象类，当然也可以定义为普通类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> <span class="keyword">extends</span> <span class="title">Beverage</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">getCost</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getDescription</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下定义具体的装饰者Whip，Sugar，都继承自抽象装饰者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Whip</span> <span class="keyword">extends</span> <span class="title">Decorator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Beverage beverage;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Whip</span><span class="params">(Beverage beverage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beverage = beverage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getCost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beverage.getCost() + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beverage.getDescription() + <span class="string">", 奶泡"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sugar</span> <span class="keyword">extends</span> <span class="title">Decorator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Beverage beverage;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Sugar</span><span class="params">(Beverage beverage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beverage = beverage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getCost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beverage.getCost() + <span class="number">5.5</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beverage.getDescription() + <span class="string">", 一份糖"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后根据不同的组合计算价格：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StarBucks</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Coffee coffee = <span class="keyword">new</span> Coffee();</span><br><span class="line">        System.out.println(coffee.getDescription() + <span class="string">", cost: "</span> + coffee.getCost());</span><br><span class="line"></span><br><span class="line">        Whip whip = <span class="keyword">new</span> Whip(coffee);</span><br><span class="line">        System.out.println(whip.getDescription() + <span class="string">", cost: "</span> + whip.getCost());</span><br><span class="line"></span><br><span class="line">        Sugar sugar = <span class="keyword">new</span> Sugar(whip);</span><br><span class="line">        System.out.println(sugar.getDescription() + <span class="string">", cost: "</span> + sugar.getCost());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 以上的代码也可以这样写， 看着像不像Builder模式？</span></span><br><span class="line">        Sugar sugar = <span class="keyword">new</span> Sugar(<span class="keyword">new</span> Whip(<span class="keyword">new</span> Coffee()));</span><br><span class="line">        System.out.println(sugar.getDescription() + <span class="string">", cost: "</span> + sugar.getCost());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出： </p><blockquote><p>一份咖啡, cost: 24.0</p></blockquote><blockquote><p>一份咖啡, 奶泡, cost: 34.0</p></blockquote><blockquote><p>一份咖啡, 奶泡, 一份糖, cost: 39.5</p></blockquote><p>当然， 在咖啡店里不仅能生产咖啡还可以提供奶茶等饮品。所以说ConcreateComponent可以有多个，ConcreateDecorator也可以有多个。</p><p>由以上可以看到装饰者模式可以动态地给被装饰者添加新的行为， 在这个例子中我们可以对咖啡进行各种装饰， 加奶泡， 加糖等等操作。 但是来带一个问题，如果我们要添加多种行为时要维护很多类。</p><h1 id="透明性要求与半透明装饰者"><a href="#透明性要求与半透明装饰者" class="headerlink" title="透明性要求与半透明装饰者"></a>透明性要求与半透明装饰者</h1><p>透明性要求客户端在创建被装饰者时不能声明一个ConcreteComponent类型的变量， 而应当声明一个Component类型的变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Coffee coffee = <span class="keyword">new</span> Coffee();</span><br><span class="line"></span><br><span class="line">Whip whip = <span class="keyword">new</span> Whip(coffee);</span><br><span class="line"></span><br><span class="line">Sugar sugar = <span class="keyword">new</span> Sugar(whip);</span><br></pre></td></tr></table></figure><p>应该按下面这种写法才满足透明性要求, 饮料：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Beverage coffee = <span class="keyword">new</span> Coffee();</span><br><span class="line"></span><br><span class="line">Beverage whip = <span class="keyword">new</span> Whip(coffee);</span><br><span class="line"></span><br><span class="line">Beverage sugar = <span class="keyword">new</span> Sugar(whip);</span><br></pre></td></tr></table></figure><p>而半透明的装饰者模式是指在具体的装饰者具有自己特有的属性, 例如在Sugar中添加getDouble()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sugar</span> <span class="keyword">extends</span> <span class="title">Decorator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Beverage beverage;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Sugar</span><span class="params">(Beverage beverage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beverage = beverage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getCost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beverage.getCost() + <span class="number">5.5</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beverage.getDescription() + <span class="string">", 一份糖"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 装饰者中加入超类不具有的特性</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDouble</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"俩份糖"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用时</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Sugar sugar = <span class="keyword">new</span> Sugar(<span class="keyword">new</span> Whip(<span class="keyword">new</span> Coffee()));</span><br><span class="line">sugar.getDouble();</span><br></pre></td></tr></table></figure><p>半透明模式有点类似于适配器模式， 增强了功能， 但是相比于透明的装饰者模式改变了接口的定义，在具体的装饰者中加入了自己的特性。</p><h1 id="装配者模式在JDK应用：InputSream"><a href="#装配者模式在JDK应用：InputSream" class="headerlink" title="装配者模式在JDK应用：InputSream"></a>装配者模式在JDK应用：<strong>InputSream</strong></h1><p><img src="/2019/12/07/design-pattern/装饰者模式/InputStream.jpg" alt="InputStream"></p><p>根据上图可以看出：</p><p>　　●　　抽象构件(Component)角色：由InputStream扮演。这是一个抽象类，为各种子类型提供统一的接口。</p><p>　　●　　具体构件(ConcreteComponent)角色：由ByteArrayInputStream、FileInputStream、PipedInputStream、StringBufferInputStream等类扮演。它们实现了抽象构件角色所规定的接口。</p><p>　　●　　抽象装饰(Decorator)角色：由FilterInputStream扮演。它实现了InputStream所规定的接口。</p><p>　　●　　具体装饰(ConcreteDecorator)角色：由几个类扮演，分别是BufferedInputStream、DataInputStream以及不常用到的类、PushbackInputStream。</p><p>　　<br>具体的调用如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> ObjectInputputStream(<span class="keyword">new</span> BufferedInputputStream(<span class="keyword">new</span> FileInputputStream( <span class="string">"io.txt"</span> )));</span><br></pre></td></tr></table></figure><p>最里层是一个FileInputStream对象，然后把它传递给一个BufferedInputStream对象，经过BufferedInputStream处理，再把处理后的对象传递给了ObjectInputputStream对象进行处理，这个过程其实就是装饰器的组装过程，FileInputStream对象相当于原始的被装饰的对象，而BufferedInputStream对象和DataInputStream对象则相当于装饰器。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>装饰者和被装饰者对象有相同的超类型，所以在任何需要原始对象（被装饰者）的场合，都可以用装饰过得对象代替原始对象；</li><li>可以用一个或多个装饰者包装一个对象（被装饰者）；</li><li>装饰者可以在所委托的装饰者行为之前或之后加上自己的行为，以达到特定的目的；</li><li>被装饰者可以在任何时候被装饰，所以可以在运行时动态地、不限量地用你喜欢的装饰者来装饰对象；</li><li>装饰者会导致出现很多小对象，如果过度使用，会让程序变得复杂。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 结构型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 2. Add Two Numbers</title>
      <link href="/2019/12/02/leetcode/linkedlist/AddTwoNumbers/"/>
      <url>/2019/12/02/leetcode/linkedlist/AddTwoNumbers/</url>
      
        <content type="html"><![CDATA[<p><strong>两链表相加， 以链表形式顺序输出结果</strong></p><a id="more"></a><p>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p><h1 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h1><blockquote><p>Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</p><p>Output: 7 -&gt; 0 -&gt; 8</p><p>Explanation: 342 + 465 = 807.</p></blockquote><blockquote><p>Input: (1 -&gt; 2 -&gt; 4) + (1 -&gt; 5 -&gt; 6)</p><p>Output: 2 -&gt; 7 -&gt; 0 -&gt; 1</p><p>Explanation: 421 + 651 = 1072.</p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>Medium 难度题，两个链表相加， 同步遍历两个链表结点， 将两个节点值的和存储为新结点。</p><blockquote><p>需要考虑三个点：</p></blockquote><blockquote><ul><li>一是头结点如何处理(利用虚拟结点处理)；</li><li>二是结点为空如何处理（空值取0计算）；</li><li>三是进位如何处理（进位保存到参与下一节点计算）</li></ul></blockquote><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode head1, ListNode head2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ListNode dummyHead = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    ListNode l1 = head1;</span><br><span class="line">    ListNode l2 = head2;</span><br><span class="line">    ListNode s = dummyHead;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (l1 != <span class="keyword">null</span> || l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> x = (l1 == <span class="keyword">null</span> ? <span class="number">0</span> : l1.val);</span><br><span class="line">        <span class="keyword">int</span> y = (l2 == <span class="keyword">null</span> ? <span class="number">0</span> : l2.val);</span><br><span class="line">        sum = carry + x + y;</span><br><span class="line">        s.next = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">        s = s.next;</span><br><span class="line">        carry = sum / <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span> (l1 != <span class="keyword">null</span>) l1 = l1.next;</span><br><span class="line">        <span class="keyword">if</span> (l2 != <span class="keyword">null</span>) l2 = l2.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (carry != <span class="number">0</span>) &#123;</span><br><span class="line">        s.next = <span class="keyword">new</span> ListNode(carry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每周一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> linkedlist </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Adapter模式</title>
      <link href="/2019/11/30/design-pattern/Adapter%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/11/30/design-pattern/Adapter%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>联想到日常生活中的适配器， 来看下程序设计中的适配器模式是什么样的</p><a id="more"></a><h1 id="什么是适配器模式"><a href="#什么是适配器模式" class="headerlink" title="什么是适配器模式"></a>什么是适配器模式</h1><blockquote><p>将一个目前自己不能使用的类，通过适配器进行包装，得到我们想要的功能</p></blockquote><h1 id="适配器组成"><a href="#适配器组成" class="headerlink" title="适配器组成"></a>适配器组成</h1><p>源角色（Adaptee）： 需要适配的类<br>适配器（Adapter）：把源角色转换成目标接口<br>目标（Target）： 客户所期待的接口<br>Client：…</p><h1 id="适配器uml"><a href="#适配器uml" class="headerlink" title="适配器uml"></a>适配器uml</h1><p><img src="/2019/11/30/design-pattern/Adapter模式/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F-UML.jpg" alt="UML"></p><p>通过uml图可以看到，适配器可以将Target一个类的接口变换成客户端所期待的另一种接口，从而使原本接口不匹配而无法在一起工作的两个类能够在一起工作。也有人把这种模式叫做包装（Wrapper）模式。</p><h1 id="具体例子"><a href="#具体例子" class="headerlink" title="具体例子"></a>具体例子</h1><h2 id="类适配器模式"><a href="#类适配器模式" class="headerlink" title="类适配器模式"></a>类适配器模式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ITiger flyTiger = <span class="keyword">new</span> FlyTiger(<span class="string">"飞天虎"</span>);</span><br><span class="line">        flyTiger.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ITiger</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Falcon</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Falcon</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">"%s 会飞！\n"</span>, <span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlyTiger</span> <span class="keyword">extends</span> <span class="title">Falcon</span> <span class="keyword">implements</span> <span class="title">ITiger</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FlyTiger</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.fly();</span><br><span class="line">        System.out.printf(<span class="string">"%s 要吃肉！\n"</span>, <span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">飞天虎 会飞！</span><br><span class="line">飞天虎 要吃肉！</span><br></pre></td></tr></table></figure><p>看一下类适配器的结构<br><img src="/2019/11/30/design-pattern/Adapter模式/%E7%B1%BB%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F.jpg" alt="类适配器模式"></p><h2 id="对象适配器模式"><a href="#对象适配器模式" class="headerlink" title="对象适配器模式"></a>对象适配器模式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ITiger flyTiger = <span class="keyword">new</span> FlyTiger();</span><br><span class="line">        flyTiger.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ITiger</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Falcon</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Falcon</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">"我会飞！\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlyTiger</span> <span class="keyword">implements</span> <span class="title">ITiger</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Falcon falcon = <span class="keyword">new</span> Falcon();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FlyTiger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        falcon.fly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一下对象适配器的结构</p><p><img src="/2019/11/30/design-pattern/Adapter模式/%E5%AF%B9%E8%B1%A1%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F.jpg" alt="对象适配器模式"></p><h1 id="类装配器与对象适配器的区别"><a href="#类装配器与对象适配器的区别" class="headerlink" title="类装配器与对象适配器的区别"></a>类装配器与对象适配器的区别</h1><h2 id="类适配器模式-1"><a href="#类适配器模式-1" class="headerlink" title="类适配器模式"></a>类适配器模式</h2><p><strong>优点：</strong></p><ul><li>使用方便， 代码简单</li><li>只需引用一个字段，不需要额外的字段引用Adaptee实例</li></ul><p><strong>缺点：</strong></p><ul><li>高耦合，灵活性差</li><li>使用继承</li></ul><h2 id="对象适配器模式-1"><a href="#对象适配器模式-1" class="headerlink" title="对象适配器模式"></a>对象适配器模式</h2><p><strong>优点：</strong></p><ul><li>灵活性高、低耦合</li><li>采用组合， 而非继承</li></ul><p><strong>缺点:</strong>：</p><ul><li>复杂</li><li>需要引入对象</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>需要重新定义Adaptee时， 采用类适配器;</p></blockquote><blockquote><p>需要同时使用源类和其子类时采用对象适配器;</p></blockquote><blockquote><p>建议多使用组合（对象适配器），少使用继承（类适配器）</p></blockquote><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><ul><li>系统复用现有的类， 当该类的接口不满足当前需求时， 利用适配器可以使得原本不兼容的接口一起工作</li><li>多个组件类似， 但接口不同意需要经常来回切换， 使用适配器模式可以让客户端统一调通， 节约成本</li></ul><h1 id="JDK中的应用"><a href="#JDK中的应用" class="headerlink" title="JDK中的应用"></a>JDK中的应用</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">java.util.Arrays#asList()</span><br><span class="line"></span><br><span class="line"><span class="comment">//InputStreamReader 继承了Readr类，但要创建它的对象必须在构造函数中传入一个InputStream）(InputStream→Reader 字节到字符)</span></span><br><span class="line">java.io.InputStreamReader</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同理 OutputStreamWriter</span></span><br><span class="line">java.io.OutputStreamWriter(OutputStream)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 结构型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>外观模式</title>
      <link href="/2019/11/22/design-pattern/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/11/22/design-pattern/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>当你打开了hao123.com访问你喜好的网站时， 这个时候就用到了外观模式！</p><a id="more"></a><h1 id="什么是Facade模式"><a href="#什么是Facade模式" class="headerlink" title="什么是Facade模式"></a>什么是Facade模式</h1><p>对外提供一个统一的接口， 外部通过这一个统一的接口对内部子系统接口进行访问</p><p>举个网站的导航例子你就懂了：每个用户上网时需要在记住每个需要浏览的网站的地址；有了hao123网站导航（用了外观模式）后，就方便了很多。<br><img src="/2019/11/22/design-pattern/外观模式/%E4%BE%8B%E5%AD%901.jpg" alt="例子"></p><h1 id="Facade模式组成"><a href="#Facade模式组成" class="headerlink" title="Facade模式组成"></a>Facade模式组成</h1><p>外观角色: Facade<br>子系统: SubSystem<br>客户端: Client</p><h1 id="Facade模式UML"><a href="#Facade模式UML" class="headerlink" title="Facade模式UML"></a>Facade模式UML</h1><p><img src="/2019/11/22/design-pattern/外观模式/Facade%E6%A8%A1%E5%BC%8F.jpg" alt="Facade模式uml"></p><h1 id="Facade模式举例"><a href="#Facade模式举例" class="headerlink" title="Facade模式举例"></a>Facade模式举例</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FacadeDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Facade facade = <span class="keyword">new</span> Facade(<span class="keyword">new</span> Light(), <span class="keyword">new</span> TV(), <span class="keyword">new</span> AirCondition());</span><br><span class="line">        facade.turnOn();</span><br><span class="line">        facade.turnOff();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Light</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lightOn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"打开灯！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lightOff</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"把灯关了！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TV</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tvOn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"打开电视！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tvOff</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"把电视关了！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AirCondition</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">airConditionOn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"打开空调！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">airConditionOff</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"把空调关了！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Facade</span> </span>&#123;</span><br><span class="line">    Light light;</span><br><span class="line">    TV tv;</span><br><span class="line">    AirCondition airCondition;</span><br><span class="line"></span><br><span class="line">    Facade(Light light, TV tv, AirCondition airCondition) &#123;</span><br><span class="line">        <span class="keyword">this</span>.light = light;</span><br><span class="line">        <span class="keyword">this</span>.tv = tv;</span><br><span class="line">        <span class="keyword">this</span>.airCondition = airCondition;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turnOn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        light.lightOn();</span><br><span class="line">        tv.tvOn();</span><br><span class="line">        airCondition.airConditionOn();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turnOff</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        light.lightOff();</span><br><span class="line">        tv.tvOff();</span><br><span class="line">        airCondition.airConditionOff();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">打开灯！</span><br><span class="line">打开电视！</span><br><span class="line">打开空调！</span><br><span class="line">把灯关了！</span><br><span class="line">把电视关了！</span><br><span class="line">把空调关了！</span><br></pre></td></tr></table></figure><h1 id="Facade模式优缺点"><a href="#Facade模式优缺点" class="headerlink" title="Facade模式优缺点"></a>Facade模式优缺点</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>对客户屏蔽了子系统组件， 主需要调用facade即可</li><li>解耦， 子系统与客户端的解耦， 子系统的变化不会影响到客户端， 子系统变化时只需更新facade</li><li>提供访问子系统的入口，不影响客户端直接使用子系统类</li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li>违背开闭原则， 不引入抽象外观类的情况下，增加新的子系统需要修改外观类或客户端的源码</li></ul><h1 id="Facade模式应用场景"><a href="#Facade模式应用场景" class="headerlink" title="Facade模式应用场景"></a>Facade模式应用场景</h1><ul><li>为一个复杂系统提供一个简单的接口</li><li>增加子系统的独立性</li><li>客户端与多个子系统有很强的依赖性</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 结构型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>建造者模式</title>
      <link href="/2019/11/06/design-pattern/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/11/06/design-pattern/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>建造者模式让创建的流程统一， 针对不同的请求， 建造出不同的产品</p><a id="more"></a><h2 id="什么是建造者模式"><a href="#什么是建造者模式" class="headerlink" title="什么是建造者模式"></a>什么是建造者模式</h2><blockquote><p>不关心产品构建的过程， 只关心结果<br>将一个<strong>复杂对象</strong>的创建与<strong>具体部位</strong>创建分离，使得同样的构建过程可以创建不同的具体部位，比如电脑的各个部件。</p></blockquote><ul><li>建造者模式可以将一个产品的部件的生成过程和其组装过程分开，一步一步创建一个复杂的对象</li><li>用户只需要指定复杂对象的类型就可以得到该对象，而无须知道其内部的具体构造细节</li></ul><h2 id="建造者模式组成"><a href="#建造者模式组成" class="headerlink" title="建造者模式组成"></a>建造者模式组成</h2><ul><li>抽象建造者(<strong>Builder</strong>)</li><li>具体建造者(<strong>ConcreteBuilder</strong>)</li><li>具体产品(<strong>ConcreteProduct</strong>)</li><li>指挥类（<strong>Director</strong>,隔离了客户与生产过程；控制产品的生成过程）</li></ul><h2 id="建造者模式uml"><a href="#建造者模式uml" class="headerlink" title="建造者模式uml"></a>建造者模式uml</h2><p><img src="/2019/11/06/design-pattern/建造者模式/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F.jpg" alt="建造者模式"></p><h2 id="建造者模式举例"><a href="#建造者模式举例" class="headerlink" title="建造者模式举例"></a>建造者模式举例</h2><p>中关村电脑装机<br>小明（Client）要一台可以流畅吃鸡的游戏主机(Product)， 店老板(Director)让小美(Builder)去配置<br>店老板针对不同的人、不同的配置分别让小美或者其他装机员去装机， 但是装机流程是一样的， 这就是一个典型的建造者模式</p><p>具体代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createMainBoard</span><span class="params">(String mainBoard)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createCPU</span><span class="params">(String cpu)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createHardDisk</span><span class="params">(String hardDisk)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createMemory</span><span class="params">(String memory)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Computer <span class="title">createComputer</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AssembleComputerBuilder类， 每个具体的Builder在细节实现上可以不同</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AssembleComputerBuilder</span> <span class="keyword">implements</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Computer computer = <span class="keyword">new</span> Computer();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createMainBoard</span><span class="params">(String mainBoard)</span> </span>&#123;</span><br><span class="line">        computer.setMainBoard(mainBoard);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createCPU</span><span class="params">(String cpu)</span> </span>&#123;</span><br><span class="line">        computer.setCpu(cpu);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createHardDisk</span><span class="params">(String hardDisk)</span> </span>&#123;</span><br><span class="line">        computer.setHardDisk(hardDisk);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createMemory</span><span class="params">(String memory)</span> </span>&#123;</span><br><span class="line">        computer.setMemory(memory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Computer <span class="title">createComputer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> computer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Director</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Builder builder;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Director</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.builder = builder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Computer <span class="title">createGameComputer</span><span class="params">(String mainBoard, String cpu, String memory, String hardDisk)</span> </span>&#123;</span><br><span class="line">        builder.createCPU(cpu);</span><br><span class="line">        builder.createHardDisk(hardDisk);</span><br><span class="line">        builder.createMainBoard(mainBoard);</span><br><span class="line">        builder.createMemory(memory);</span><br><span class="line">        <span class="keyword">return</span> builder.createComputer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String cpu ;</span><br><span class="line">    <span class="keyword">private</span> String hardDisk ;</span><br><span class="line">    <span class="keyword">private</span> String mainBoard ;</span><br><span class="line">    <span class="keyword">private</span> String memory ;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Builder builder = <span class="keyword">new</span> AssembleComputerBuilder();</span><br><span class="line">        Director director = <span class="keyword">new</span> Director(builder);</span><br><span class="line"></span><br><span class="line">        Computer computer = director.createComputer(<span class="string">"技嘉B360"</span>, <span class="string">"Intel-9400F"</span>, <span class="string">"Hyper 8G"</span>, <span class="string">"希捷 2T"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(computer.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Computer computer = director.createComputer(<span class="string">"技嘉B360"</span>, <span class="string">"Intel-9400F"</span>, <span class="string">"Hyper 8G"</span>, <span class="string">"希捷 2T"</span>);</span><br></pre></td></tr></table></figure><p>如果Computer类不止mainBoard，cpu, memory, hardDisk这四个参数时，还有networkCard, soundCard等属性时，我们还要在一个构造函数中写入n多参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Computer computer = director.createComputer(<span class="string">"技嘉B360"</span>, <span class="string">"Intel-9400F"</span>, <span class="string">"Hyper 8G"</span>, <span class="string">"希捷 2T"</span>, <span class="string">"networkCard"</span>, <span class="string">"soundCard"</span>, <span class="string">"xxx"</span>);</span><br></pre></td></tr></table></figure><p>遇到这种参数很多的情况，也许有人会在Director重叠构造器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Computer <span class="title">createGameComputer</span><span class="params">(String mainBoard, String cpu, String memory, String hardDisk, String xxx, String xxx)</span> </span>&#123;</span><br></pre></td></tr></table></figure><p>但是重叠构造器有以下缺点</p><ul><li>层层嵌套，代码不灵活</li><li>不优雅</li><li>如果增加参数那就是噩梦</li></ul><h2 id="改进方案，简化版Builder，支持链式调用，-不再需要Director"><a href="#改进方案，简化版Builder，支持链式调用，-不再需要Director" class="headerlink" title="改进方案，简化版Builder，支持链式调用， 不再需要Director"></a>改进方案，简化版Builder，支持链式调用， 不再需要Director</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String cpu ;</span><br><span class="line"><span class="keyword">private</span> String hardDisk ;</span><br><span class="line"><span class="keyword">private</span> String mainBoard ;</span><br><span class="line"><span class="keyword">private</span> String memory ;</span><br><span class="line"><span class="keyword">private</span> String networkCard ;</span><br><span class="line"><span class="keyword">private</span> String soundCard ;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入Builder</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String cpu ;</span><br><span class="line"><span class="keyword">private</span> String hardDisk ;</span><br><span class="line"><span class="keyword">private</span> String mainBoard ;</span><br><span class="line"><span class="keyword">private</span> String memory ;</span><br><span class="line"><span class="keyword">private</span> String networkCard ;</span><br><span class="line"><span class="keyword">private</span> String soundCard ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Builder <span class="title">cpu</span><span class="params">(String cpu)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cpu = cpu;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Builder <span class="title">hardDisk</span><span class="params">(String cpu)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.hardDisk = hardDisk;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Builder <span class="title">mainBoard</span><span class="params">(String cpu)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mainBoard = mainBoard;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//... 网卡、声卡等其他组件构造略</span></span><br><span class="line"><span class="function">Computer <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Computer(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就可以这样创建 Computer 对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Computer computer  = <span class="keyword">new</span> Computer.Builder().cpu(<span class="string">"Intel-9400F"</span>).mainBoard(<span class="string">"技嘉360主板"</span>).graphics(<span class="string">"Nvida 显卡"</span>).hardDisk(<span class="string">"希捷2t硬盘"</span>). networkCard(<span class="string">"千兆网卡"</span>).soundCard(<span class="string">"高保真声卡"</span>).build();</span><br></pre></td></tr></table></figure><p>这样即便在属性很多时代码看起来也很简洁，当然这种链式调用也存在一定缺点，比如：</p><ul><li>每次创建外部类对象，都需要再创建一个内部类，所以需要消耗更多的内存</li><li>每个属性要同时在内部类和外部类中定义</li></ul><h2 id="建造者模式优缺点"><a href="#建造者模式优缺点" class="headerlink" title="建造者模式优缺点"></a>建造者模式优缺点</h2><blockquote><p><strong>优点</strong></p><ul><li>易于解耦，产品本身与创建过程进行解耦， 相同的创建过程得到不同的产品</li><li>更精细地控制创建过程，将复杂产品的创建步骤分解到不同方法中， 创建过程更清晰</li><li>易于拓展， 增加新的具体建造者无需修改原有类库，符合开闭原则 </li></ul></blockquote><blockquote><p><strong>缺点</strong></p><ul><li>要求所建造的产品有许多的相同点， 组成部分相似， 没办法让电脑装机店去盖房子</li><li>产品内部变化复杂， 可能会需要很多具体建造者实现这种变化</li></ul></blockquote><h2 id="建造者模式使用场景"><a href="#建造者模式使用场景" class="headerlink" title="建造者模式使用场景"></a>建造者模式使用场景</h2><ul><li>需要生成的产品对象有复杂的内部结构，这些产品对象具备多个相同的成员属性；</li><li>隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品。</li><li>需要生成的产品对象的属性相互依赖，需要指定其生成顺序。</li></ul><h2 id="建造者模式与工厂模式的区别"><a href="#建造者模式与工厂模式的区别" class="headerlink" title="建造者模式与工厂模式的区别"></a>建造者模式与工厂模式的区别</h2><ul><li>工厂模式是将对象的全部创建过程封装在工厂类中，由工厂类向客户端提供最终的产品；</li><li>建造者类一般只提供产品类中各个组件的建造，而将具体建造过程交付给导演类。由导演类负责将各个组件按照特定的规则组建为产品，然后将组建好的产品交付给客户端。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 创建型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例模式</title>
      <link href="/2019/10/23/design-pattern/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/10/23/design-pattern/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>面试必问的单例模式， 在这做个小小的总结</p><a id="more"></a><h1 id="为什么需要单例模式"><a href="#为什么需要单例模式" class="headerlink" title="为什么需要单例模式"></a>为什么需要单例模式</h1><p>一个全局使用的类频繁地创建和销毁，减少系统开销</p><h1 id="单例模式的特点是什么"><a href="#单例模式的特点是什么" class="headerlink" title="单例模式的特点是什么"></a>单例模式的特点是什么</h1><ul><li>只有一个实例</li><li>必须自己创建自己的实例（构造函数私有）</li><li>必须为所有其他对象提供这一实例</li></ul><h1 id="单例模式uml"><a href="#单例模式uml" class="headerlink" title="单例模式uml"></a>单例模式uml</h1><p><img src="/2019/10/23/design-pattern/单例模式/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.jpg" alt="单例模式"></p><h1 id="几种不同的单例模式"><a href="#几种不同的单例模式" class="headerlink" title="几种不同的单例模式"></a>几种不同的单例模式</h1><h2 id="懒汉式-线程不安全"><a href="#懒汉式-线程不安全" class="headerlink" title="懒汉式, 线程不安全"></a>懒汉式, 线程不安全</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonObject instance;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonObject <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance =  <span class="keyword">new</span> SingletonObject();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以加锁带到线程安全的目的， 但会影响到效率</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> SingletonObject <span class="title">getInstance</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><h2 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h2><p>类装载时就初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonObject instance = <span class="keyword">new</span> SingletonObject();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonObject <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DCL-双重锁监测"><a href="#DCL-双重锁监测" class="headerlink" title="DCL,双重锁监测"></a>DCL,双重锁监测</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonObject</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> SingletonObject singleton;</span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonObject</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonObject <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">synchronized</span> (SingletonObject.class) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            singleton = <span class="keyword">new</span> SingletonObject();  </span><br><span class="line">        &#125;  </span><br><span class="line">      &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> singleton;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="私有内部类"><a href="#私有内部类" class="headerlink" title="私有内部类"></a>私有内部类</h2><p>使用静态内部类，既可以实现延迟加载， 又可以保证多线程安全，不影响性能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonObject</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SingletonObject INSTANCE = <span class="keyword">new</span> SingletonObject();  </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonObject</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> SingletonObject <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> SingletonHolder.INSTANCE;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>私有内部类不能避免反序列化重新创建新的对象， 无法保证对象的唯一性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>JVM 会阻止反射获取枚举类的私有构造方法。</strong></p><h1 id="单例模式的优点"><a href="#单例模式的优点" class="headerlink" title="单例模式的优点"></a>单例模式的优点</h1><blockquote><p>单例模式提供了对唯一实例的受控访问。因为单例类封装了它的唯一实例，所以它可以严格控制客户怎样以及何时访问它。<br>由于在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象单例模式无疑可以提高系统的性能。<br>允许可变数目的实例。基于单例模式我们可以进行扩展，使用与单例控制相似的方法来获得指定个数的对象实例，既节省系统资源，又解决了单例单例对象共享过多有损性能的问题。</p></blockquote><h1 id="单例模式的不足"><a href="#单例模式的不足" class="headerlink" title="单例模式的不足"></a>单例模式的不足</h1><blockquote><p>没有借口， 不能被继承。 自身既是工厂又是产品， 违反了单一职责原则。<br>单例类的职责过重，在一定程度上违背了“单一职责原则”。因为单例类既充当了工厂角色，提供了工厂方法，同时又充当了产品角色，包含一些业务方法，将产品的创建和产品的本身的功能融合到一起。<br>面向对象语言(如Java、C#)的运行环境都提供了自动垃圾回收的技术，因此，如果实例化的共享对象长时间不被利用，系统会认为它是垃圾，会自动销毁并回收资源，下次利用时又将重新实例化，这将导致共享的单例对象状态的丢失。</p></blockquote><h1 id="单例模式具体应用"><a href="#单例模式具体应用" class="headerlink" title="单例模式具体应用"></a>单例模式具体应用</h1><p>系统只需要一个实例对象，如系统要求提供一个唯一的序列号生成器或资源管理器，或者需要考虑资源消耗太大而只允许创建一个对象。<br>客户调用类的单个实例只允许使用一个公共访问点，除了该公共访问点，不能通过其他途径访问该实例。</p><blockquote><p>java.lang.Runtime，在每一个Java应用程序里面，都有唯一的一个Runtime对象，应用程序可以与其运行环境发生相互作用。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Runtime <span class="title">getRuntime</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 创建型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>抽象工厂</title>
      <link href="/2019/10/17/design-pattern/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/"/>
      <url>/2019/10/17/design-pattern/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/</url>
      
        <content type="html"><![CDATA[<p>抽象工厂相比于工厂方法模式的不同在于，一个抽象工厂可以创建多个不同的产品</p><a id="more"></a><h3 id="引申概念"><a href="#引申概念" class="headerlink" title="引申概念"></a>引申概念</h3><blockquote><p><strong>产品等级结构</strong>: 产品的继承结构， 抽象类是键盘，子类就是hp键盘，罗技键盘，抽象的键盘与具体的键盘产品构成了一个产品等级，抽象键盘是父类，具体的键盘是子类<br><strong>产品族</strong>: 产品族指的是同一个工厂生产的， 位于不同产品等级的一组产品， 例如hp生产的键盘、鼠标是同一产品族，而键盘位于键盘产品等级，鼠标位于鼠标产品等级中</p></blockquote><h3 id="抽象工厂结构"><a href="#抽象工厂结构" class="headerlink" title="抽象工厂结构"></a>抽象工厂结构</h3><p><strong>AbstractFactory</strong>: 抽象工厂<br><strong>ContreteFactory</strong>: 具体工厂<br><strong>AbstractProduct</strong>: 抽象产品<br><strong>ContreteProduct</strong>: 具体产品</p><h3 id="抽象工厂uml"><a href="#抽象工厂uml" class="headerlink" title="抽象工厂uml"></a>抽象工厂uml</h3><p><img src="/2019/10/17/design-pattern/抽象工厂/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82.jpg" alt="抽象工厂"></p><h3 id="抽象工厂特点"><a href="#抽象工厂特点" class="headerlink" title="抽象工厂特点"></a>抽象工厂特点</h3><blockquote><p>抽象工厂模式与工厂方法模式最大的区别：而工厂方法每个工厂只能创建一类产品，抽象工厂中每个工厂可以创建多种产品；</p></blockquote><h3 id="抽象工厂解决的问题"><a href="#抽象工厂解决的问题" class="headerlink" title="抽象工厂解决的问题"></a>抽象工厂解决的问题</h3><blockquote><p>解决了每个工厂只能创建一类产品的问题-即解决了工厂模式的缺点， 当一个工厂中能生产多种产品等级的产品时，此时抽象工厂比工厂模式效率高</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">PcFactory dellFactory = <span class="keyword">new</span> DellFactory();</span><br><span class="line"><span class="comment">// create dell product</span></span><br><span class="line">KeyBoard dellKeyBoard = dellFactory.createKeyBoard();</span><br><span class="line">Mouse dellMouse = dellFactory.createMouse();</span><br><span class="line"><span class="comment">// use</span></span><br><span class="line">dellKeyBoard.type();</span><br><span class="line">dellMouse.click();</span><br><span class="line"></span><br><span class="line">PcFactory hpFactory = <span class="keyword">new</span> HpFactory();</span><br><span class="line"><span class="comment">// create hp product</span></span><br><span class="line">KeyBoard hpKeyBoard = hpFactory.createKeyBoard();</span><br><span class="line">Mouse hpMouse = hpFactory.createMouse();</span><br><span class="line"><span class="comment">// use</span></span><br><span class="line">hpKeyBoard.type();</span><br><span class="line">hpMouse.click();</span><br></pre></td></tr></table></figure><h3 id="抽象工厂优点"><a href="#抽象工厂优点" class="headerlink" title="抽象工厂优点"></a>抽象工厂优点</h3><blockquote><ul><li>降低耦合， 将具体产品的创建延迟到具体工厂的子类中去， 减少客户端与具体产品之间的依赖</li><li>更符合开闭原则，需要新增具体的产品族和相应的工厂即可，无需修改原有的系统</li><li>增加新的工厂和产品族很方便， 无需修改已有的系统，符合开闭原则</li></ul></blockquote><h3 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h3><blockquote><ul><li>违抽象工厂中已经确定了被创建的产品的组合，新增产品种类时， 需要修改抽象工厂的接口以及其所有子类， 带来不便</li><li>开闭原则的倾斜性， 增加工厂和产品族容易， 增加新的产品等级结构麻烦</li></ul></blockquote><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><blockquote><ul><li>一个系统不依赖于产品实例如何被创建、组合等细节</li><li>系统中有多个产品族，每次只使用其中一个产品族</li><li>属于同一个产品族的产品在一起使用</li></ul></blockquote><h3 id="具体应用"><a href="#具体应用" class="headerlink" title="具体应用"></a>具体应用</h3><blockquote><ul><li>系统更换主题时， 界面的按钮、文本、背景等一起发生改变 深色模式下的按钮、文本、背景属于一个产品族， 抽象的按钮与具体的按钮构成一个产品等级</li><li>公司在采购时， 采购了DELL公司的电脑、鼠标、键盘， 等下个季度采购HP公司的产品</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 创建型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工厂方法</title>
      <link href="/2019/10/17/design-pattern/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95/"/>
      <url>/2019/10/17/design-pattern/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>工厂方法相比于简单工厂解决了哪些问题？</p><a id="more"></a><h3 id="工厂模式结构"><a href="#工厂模式结构" class="headerlink" title="工厂模式结构"></a>工厂模式结构</h3><p><strong>Product</strong>: 抽象产品<br><strong>ConcreteProduct</strong>: 具体产品<br><strong>Factory</strong>: 抽象工厂<br><strong>ConcreteFactory</strong>: 具体工厂</p><h3 id="工厂模式uml图"><a href="#工厂模式uml图" class="headerlink" title="工厂模式uml图"></a>工厂模式uml图</h3><p><img src="/2019/10/17/design-pattern/工厂方法/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95.jpg" alt="工厂方法"></p><h3 id="工厂模式特点"><a href="#工厂模式特点" class="headerlink" title="工厂模式特点"></a>工厂模式特点</h3><blockquote><p>将实例的创建延迟到具体的工厂中去完成， 由子类决定实例化哪个类</p></blockquote><h3 id="工厂模式解决的问题"><a href="#工厂模式解决的问题" class="headerlink" title="工厂模式解决的问题"></a>工厂模式解决的问题</h3><blockquote><p>解决了简单工厂带来的问题：新增产品时需要修改工厂类的逻辑。 工厂类不再负责创建产品， 而是由具体工厂去实现， 具体的工厂实现工厂类中创建产品的接口</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 工厂中创建产品</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SquareFactory</span> <span class="keyword">implements</span>  <span class="title">ShapeFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Shape <span class="title">getShape</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Square();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用时</span></span><br><span class="line">ShapeFactory squareFactory = <span class="keyword">new</span> SquareFactory();</span><br><span class="line">Shape square = squareFactory.getShape();</span><br><span class="line">square.draw();</span><br></pre></td></tr></table></figure><h3 id="工厂方法模式优点"><a href="#工厂方法模式优点" class="headerlink" title="工厂方法模式优点"></a>工厂方法模式优点</h3><blockquote><ul><li>更符合开闭原则， 新增产品时只需要新增产品类以及相应的工厂子类,无需更改提供抽象产品的接口， 对应的简单工厂需要修改工厂类的逻辑</li><li>单一职责， 工厂只负责创建产品，客户端无需关心产品创建的细节， 只需要知道需要具体的工厂即可， 而简单工厂还需要判断创建何种产品</li></ul></blockquote><h3 id="工厂方法模式缺点"><a href="#工厂方法模式缺点" class="headerlink" title="工厂方法模式缺点"></a>工厂方法模式缺点</h3><blockquote><ul><li>新增产品除了新增产品类， 还需要新增具体的工厂类， 系统类成对增加， 复杂度上升</li><li>一个具体的工厂只能创建一种产品</li></ul></blockquote><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><blockquote><ul><li>客户不需要关心具体的产品， 只需要知道对应的工厂就好了</li><li>一个类通过其子类指定创建哪个对象，抽象工厂类提供一个创建产品的接口由子类来确定具体要创建的产品</li><li>可以将要创建的工厂类进行配置（数据库或者配置文件）， 在需要具体工厂时再动态指定</li></ul></blockquote><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JDBC connection, 通过JDBC.properties获取数据库dirver信息， 使用oracle或者mysql</span><br></pre></td></tr></table></figure><p><img src="/2019/10/17/design-pattern/工厂方法/JDBC.jpg" alt="JDBC工厂模式"><br><a href="https://www.zybuluo.com/pastqing/note/107544" target="_blank" rel="noopener">参考JDBC源码解析</a></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 创建型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单工厂</title>
      <link href="/2019/10/17/design-pattern/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82/"/>
      <url>/2019/10/17/design-pattern/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82/</url>
      
        <content type="html"><![CDATA[<p>简单工厂是平时使用最多的工厂模式， 一种特殊的工厂方法模式</p><a id="more"></a><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><blockquote><p>软件系统需要提供多个外观不同的按钮（圆形，菱形，三角形的按钮等）， 这些按钮都继承自同一个形状类，继承后通过修改部分属性就可呈现不同外观，当我们使用按钮时， 不需要关注具体的按钮类的名称， 只需要知道改按钮类的名称，提供一个调用的方法， 把该参数传入方法即可得到相应的按钮对象</p></blockquote><h3 id="简单工厂的结构"><a href="#简单工厂的结构" class="headerlink" title="简单工厂的结构"></a>简单工厂的结构</h3><p><strong>Factory</strong>: 工厂角色。负责实现和创建实例的内部逻辑<br><strong>Product</strong>: 抽象产品角色。创建的所有对象的父类，描述所有实例的通用接口<br><strong>ConcreteProduct</strong>: 具体产品</p><h3 id="简单工厂的uml图"><a href="#简单工厂的uml图" class="headerlink" title="简单工厂的uml图"></a>简单工厂的uml图</h3><p><img src="/2019/10/17/design-pattern/简单工厂/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82.png" alt="简单工厂"></p><h3 id="没有工厂时"><a href="#没有工厂时" class="headerlink" title="没有工厂时"></a>没有工厂时</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Shape rectangle = <span class="keyword">new</span> Rectangle();</span><br><span class="line">Shape square = <span class="keyword">new</span> Square();</span><br></pre></td></tr></table></figure><h3 id="有工厂时："><a href="#有工厂时：" class="headerlink" title="有工厂时："></a>有工厂时：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Shape rectangle = ShapeFactory.getShape(<span class="string">"rectangle"</span>);</span><br><span class="line">Shape square = ShapeFactory.getShape(<span class="string">"square"</span>);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Shape <span class="title">getShape</span><span class="params">(String shapeName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(shapeName == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(shapeName.equals(<span class="string">"rectangle"</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Rectangle();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(shapeName.equals(<span class="string">"square"</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Square();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="简单工厂的优点："><a href="#简单工厂的优点：" class="headerlink" title="简单工厂的优点："></a>简单工厂的优点：</h3><blockquote><p>将创建实例与使用实例分开， 进行解耦， 使使用者不关心对象如何创建， 实现了解耦初始化实例的工作放在工厂中进行， 代码更容易维护，面向接口编程</p></blockquote><h3 id="简单工厂的缺点："><a href="#简单工厂的缺点：" class="headerlink" title="简单工厂的缺点："></a>简单工厂的缺点：</h3><blockquote><ul><li>简单工厂集合了所有实例的创建逻辑，一旦新增新的产品就不得不修改工厂的逻辑，整个系统受到影响，违背了开闭原则</li><li>简单工厂使用了静态方法， 不能被继承和重写</li></ul></blockquote><h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li>工厂类创建的对象比较少， 不会造成工厂方法中的业务逻辑过于复杂</li><li>客户端只知道传入工厂类的参数，对如何创建对象不关心，甚至连产品的类名都不需要记住， 只需要记住对应的参数即可</li></ul><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> DateFormat <span class="title">getDateInstance</span><span class="params">(<span class="keyword">int</span> style)</span></span>;</span><br><span class="line">KeyGenerator keyGen = KeyGenerator.getInstance(<span class="string">"DESede"</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 创建型模式 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
